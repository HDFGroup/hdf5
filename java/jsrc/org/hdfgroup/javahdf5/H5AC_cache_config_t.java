// Generated by jextract

package org.hdfgroup.javahdf5;

import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * {@snippet lang=c :
 * struct H5AC_cache_config_t {
 *     int version;
 *     hbool_t rpt_fcn_enabled;
 *     hbool_t open_trace_file;
 *     hbool_t close_trace_file;
 *     char trace_file_name[1025];
 *     hbool_t evictions_enabled;
 *     hbool_t set_initial_size;
 *     size_t initial_size;
 *     double min_clean_fraction;
 *     size_t max_size;
 *     size_t min_size;
 *     long epoch_length;
 *     enum H5C_cache_incr_mode incr_mode;
 *     double lower_hr_threshold;
 *     double increment;
 *     hbool_t apply_max_increment;
 *     size_t max_increment;
 *     enum H5C_cache_flash_incr_mode flash_incr_mode;
 *     double flash_multiple;
 *     double flash_threshold;
 *     enum H5C_cache_decr_mode decr_mode;
 *     double upper_hr_threshold;
 *     double decrement;
 *     hbool_t apply_max_decrement;
 *     size_t max_decrement;
 *     int epochs_before_eviction;
 *     hbool_t apply_empty_reserve;
 *     double empty_reserve;
 *     size_t dirty_bytes_threshold;
 *     int metadata_write_strategy;
 * }
 * }
 */
public class H5AC_cache_config_t {

    H5AC_cache_config_t()
    {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT =
        MemoryLayout
            .structLayout(
                hdf5_h.C_INT.withName("version"), hdf5_h.C_BOOL.withName("rpt_fcn_enabled"),
                hdf5_h.C_BOOL.withName("open_trace_file"), hdf5_h.C_BOOL.withName("close_trace_file"),
                MemoryLayout.sequenceLayout(1025, hdf5_h.C_CHAR).withName("trace_file_name"),
                hdf5_h.C_BOOL.withName("evictions_enabled"), hdf5_h.C_BOOL.withName("set_initial_size"),
                MemoryLayout.paddingLayout(6), hdf5_h.C_LONG.withName("initial_size"),
                hdf5_h.C_DOUBLE.withName("min_clean_fraction"), hdf5_h.C_LONG.withName("max_size"),
                hdf5_h.C_LONG.withName("min_size"), hdf5_h.C_LONG.withName("epoch_length"),
                hdf5_h.C_INT.withName("incr_mode"), MemoryLayout.paddingLayout(4),
                hdf5_h.C_DOUBLE.withName("lower_hr_threshold"), hdf5_h.C_DOUBLE.withName("increment"),
                hdf5_h.C_BOOL.withName("apply_max_increment"), MemoryLayout.paddingLayout(7),
                hdf5_h.C_LONG.withName("max_increment"), hdf5_h.C_INT.withName("flash_incr_mode"),
                MemoryLayout.paddingLayout(4), hdf5_h.C_DOUBLE.withName("flash_multiple"),
                hdf5_h.C_DOUBLE.withName("flash_threshold"), hdf5_h.C_INT.withName("decr_mode"),
                MemoryLayout.paddingLayout(4), hdf5_h.C_DOUBLE.withName("upper_hr_threshold"),
                hdf5_h.C_DOUBLE.withName("decrement"), hdf5_h.C_BOOL.withName("apply_max_decrement"),
                MemoryLayout.paddingLayout(7), hdf5_h.C_LONG.withName("max_decrement"),
                hdf5_h.C_INT.withName("epochs_before_eviction"),
                hdf5_h.C_BOOL.withName("apply_empty_reserve"), MemoryLayout.paddingLayout(3),
                hdf5_h.C_DOUBLE.withName("empty_reserve"), hdf5_h.C_LONG.withName("dirty_bytes_threshold"),
                hdf5_h.C_INT.withName("metadata_write_strategy"), MemoryLayout.paddingLayout(4))
            .withName("H5AC_cache_config_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() { return $LAYOUT; }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int version
     * }
     */
    public static final OfInt version$layout() { return version$LAYOUT; }

    private static final long version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int version
     * }
     */
    public static final long version$offset() { return version$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int version
     * }
     */
    public static int version(MemorySegment struct) { return struct.get(version$LAYOUT, version$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue)
    {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfBoolean rpt_fcn_enabled$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("rpt_fcn_enabled"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t rpt_fcn_enabled
     * }
     */
    public static final OfBoolean rpt_fcn_enabled$layout() { return rpt_fcn_enabled$LAYOUT; }

    private static final long rpt_fcn_enabled$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t rpt_fcn_enabled
     * }
     */
    public static final long rpt_fcn_enabled$offset() { return rpt_fcn_enabled$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t rpt_fcn_enabled
     * }
     */
    public static boolean rpt_fcn_enabled(MemorySegment struct)
    {
        return struct.get(rpt_fcn_enabled$LAYOUT, rpt_fcn_enabled$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t rpt_fcn_enabled
     * }
     */
    public static void rpt_fcn_enabled(MemorySegment struct, boolean fieldValue)
    {
        struct.set(rpt_fcn_enabled$LAYOUT, rpt_fcn_enabled$OFFSET, fieldValue);
    }

    private static final OfBoolean open_trace_file$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("open_trace_file"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t open_trace_file
     * }
     */
    public static final OfBoolean open_trace_file$layout() { return open_trace_file$LAYOUT; }

    private static final long open_trace_file$OFFSET = 5;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t open_trace_file
     * }
     */
    public static final long open_trace_file$offset() { return open_trace_file$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t open_trace_file
     * }
     */
    public static boolean open_trace_file(MemorySegment struct)
    {
        return struct.get(open_trace_file$LAYOUT, open_trace_file$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t open_trace_file
     * }
     */
    public static void open_trace_file(MemorySegment struct, boolean fieldValue)
    {
        struct.set(open_trace_file$LAYOUT, open_trace_file$OFFSET, fieldValue);
    }

    private static final OfBoolean close_trace_file$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("close_trace_file"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t close_trace_file
     * }
     */
    public static final OfBoolean close_trace_file$layout() { return close_trace_file$LAYOUT; }

    private static final long close_trace_file$OFFSET = 6;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t close_trace_file
     * }
     */
    public static final long close_trace_file$offset() { return close_trace_file$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t close_trace_file
     * }
     */
    public static boolean close_trace_file(MemorySegment struct)
    {
        return struct.get(close_trace_file$LAYOUT, close_trace_file$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t close_trace_file
     * }
     */
    public static void close_trace_file(MemorySegment struct, boolean fieldValue)
    {
        struct.set(close_trace_file$LAYOUT, close_trace_file$OFFSET, fieldValue);
    }

    private static final SequenceLayout trace_file_name$LAYOUT =
        (SequenceLayout)$LAYOUT.select(groupElement("trace_file_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static final SequenceLayout trace_file_name$layout() { return trace_file_name$LAYOUT; }

    private static final long trace_file_name$OFFSET = 7;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static final long trace_file_name$offset() { return trace_file_name$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static MemorySegment trace_file_name(MemorySegment struct)
    {
        return struct.asSlice(trace_file_name$OFFSET, trace_file_name$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static void trace_file_name(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, trace_file_name$OFFSET, trace_file_name$LAYOUT.byteSize());
    }

    private static long[] trace_file_name$DIMS = {1025};

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static long[] trace_file_name$dimensions() { return trace_file_name$DIMS; }
    private static final VarHandle trace_file_name$ELEM_HANDLE =
        trace_file_name$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static byte trace_file_name(MemorySegment struct, long index0)
    {
        return (byte)trace_file_name$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char trace_file_name[1025]
     * }
     */
    public static void trace_file_name(MemorySegment struct, long index0, byte fieldValue)
    {
        trace_file_name$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfBoolean evictions_enabled$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("evictions_enabled"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t evictions_enabled
     * }
     */
    public static final OfBoolean evictions_enabled$layout() { return evictions_enabled$LAYOUT; }

    private static final long evictions_enabled$OFFSET = 1032;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t evictions_enabled
     * }
     */
    public static final long evictions_enabled$offset() { return evictions_enabled$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t evictions_enabled
     * }
     */
    public static boolean evictions_enabled(MemorySegment struct)
    {
        return struct.get(evictions_enabled$LAYOUT, evictions_enabled$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t evictions_enabled
     * }
     */
    public static void evictions_enabled(MemorySegment struct, boolean fieldValue)
    {
        struct.set(evictions_enabled$LAYOUT, evictions_enabled$OFFSET, fieldValue);
    }

    private static final OfBoolean set_initial_size$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("set_initial_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t set_initial_size
     * }
     */
    public static final OfBoolean set_initial_size$layout() { return set_initial_size$LAYOUT; }

    private static final long set_initial_size$OFFSET = 1033;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t set_initial_size
     * }
     */
    public static final long set_initial_size$offset() { return set_initial_size$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t set_initial_size
     * }
     */
    public static boolean set_initial_size(MemorySegment struct)
    {
        return struct.get(set_initial_size$LAYOUT, set_initial_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t set_initial_size
     * }
     */
    public static void set_initial_size(MemorySegment struct, boolean fieldValue)
    {
        struct.set(set_initial_size$LAYOUT, set_initial_size$OFFSET, fieldValue);
    }

    private static final OfLong initial_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("initial_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t initial_size
     * }
     */
    public static final OfLong initial_size$layout() { return initial_size$LAYOUT; }

    private static final long initial_size$OFFSET = 1040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t initial_size
     * }
     */
    public static final long initial_size$offset() { return initial_size$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t initial_size
     * }
     */
    public static long initial_size(MemorySegment struct)
    {
        return struct.get(initial_size$LAYOUT, initial_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t initial_size
     * }
     */
    public static void initial_size(MemorySegment struct, long fieldValue)
    {
        struct.set(initial_size$LAYOUT, initial_size$OFFSET, fieldValue);
    }

    private static final OfDouble min_clean_fraction$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("min_clean_fraction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double min_clean_fraction
     * }
     */
    public static final OfDouble min_clean_fraction$layout() { return min_clean_fraction$LAYOUT; }

    private static final long min_clean_fraction$OFFSET = 1048;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double min_clean_fraction
     * }
     */
    public static final long min_clean_fraction$offset() { return min_clean_fraction$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double min_clean_fraction
     * }
     */
    public static double min_clean_fraction(MemorySegment struct)
    {
        return struct.get(min_clean_fraction$LAYOUT, min_clean_fraction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double min_clean_fraction
     * }
     */
    public static void min_clean_fraction(MemorySegment struct, double fieldValue)
    {
        struct.set(min_clean_fraction$LAYOUT, min_clean_fraction$OFFSET, fieldValue);
    }

    private static final OfLong max_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t max_size
     * }
     */
    public static final OfLong max_size$layout() { return max_size$LAYOUT; }

    private static final long max_size$OFFSET = 1056;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t max_size
     * }
     */
    public static final long max_size$offset() { return max_size$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t max_size
     * }
     */
    public static long max_size(MemorySegment struct) { return struct.get(max_size$LAYOUT, max_size$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t max_size
     * }
     */
    public static void max_size(MemorySegment struct, long fieldValue)
    {
        struct.set(max_size$LAYOUT, max_size$OFFSET, fieldValue);
    }

    private static final OfLong min_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("min_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t min_size
     * }
     */
    public static final OfLong min_size$layout() { return min_size$LAYOUT; }

    private static final long min_size$OFFSET = 1064;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t min_size
     * }
     */
    public static final long min_size$offset() { return min_size$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t min_size
     * }
     */
    public static long min_size(MemorySegment struct) { return struct.get(min_size$LAYOUT, min_size$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t min_size
     * }
     */
    public static void min_size(MemorySegment struct, long fieldValue)
    {
        struct.set(min_size$LAYOUT, min_size$OFFSET, fieldValue);
    }

    private static final OfLong epoch_length$LAYOUT = (OfLong)$LAYOUT.select(groupElement("epoch_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * long epoch_length
     * }
     */
    public static final OfLong epoch_length$layout() { return epoch_length$LAYOUT; }

    private static final long epoch_length$OFFSET = 1072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * long epoch_length
     * }
     */
    public static final long epoch_length$offset() { return epoch_length$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * long epoch_length
     * }
     */
    public static long epoch_length(MemorySegment struct)
    {
        return struct.get(epoch_length$LAYOUT, epoch_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * long epoch_length
     * }
     */
    public static void epoch_length(MemorySegment struct, long fieldValue)
    {
        struct.set(epoch_length$LAYOUT, epoch_length$OFFSET, fieldValue);
    }

    private static final OfInt incr_mode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("incr_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum H5C_cache_incr_mode incr_mode
     * }
     */
    public static final OfInt incr_mode$layout() { return incr_mode$LAYOUT; }

    private static final long incr_mode$OFFSET = 1080;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum H5C_cache_incr_mode incr_mode
     * }
     */
    public static final long incr_mode$offset() { return incr_mode$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum H5C_cache_incr_mode incr_mode
     * }
     */
    public static int incr_mode(MemorySegment struct)
    {
        return struct.get(incr_mode$LAYOUT, incr_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum H5C_cache_incr_mode incr_mode
     * }
     */
    public static void incr_mode(MemorySegment struct, int fieldValue)
    {
        struct.set(incr_mode$LAYOUT, incr_mode$OFFSET, fieldValue);
    }

    private static final OfDouble lower_hr_threshold$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("lower_hr_threshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double lower_hr_threshold
     * }
     */
    public static final OfDouble lower_hr_threshold$layout() { return lower_hr_threshold$LAYOUT; }

    private static final long lower_hr_threshold$OFFSET = 1088;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double lower_hr_threshold
     * }
     */
    public static final long lower_hr_threshold$offset() { return lower_hr_threshold$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double lower_hr_threshold
     * }
     */
    public static double lower_hr_threshold(MemorySegment struct)
    {
        return struct.get(lower_hr_threshold$LAYOUT, lower_hr_threshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double lower_hr_threshold
     * }
     */
    public static void lower_hr_threshold(MemorySegment struct, double fieldValue)
    {
        struct.set(lower_hr_threshold$LAYOUT, lower_hr_threshold$OFFSET, fieldValue);
    }

    private static final OfDouble increment$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("increment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double increment
     * }
     */
    public static final OfDouble increment$layout() { return increment$LAYOUT; }

    private static final long increment$OFFSET = 1096;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double increment
     * }
     */
    public static final long increment$offset() { return increment$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double increment
     * }
     */
    public static double increment(MemorySegment struct)
    {
        return struct.get(increment$LAYOUT, increment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double increment
     * }
     */
    public static void increment(MemorySegment struct, double fieldValue)
    {
        struct.set(increment$LAYOUT, increment$OFFSET, fieldValue);
    }

    private static final OfBoolean apply_max_increment$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("apply_max_increment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t apply_max_increment
     * }
     */
    public static final OfBoolean apply_max_increment$layout() { return apply_max_increment$LAYOUT; }

    private static final long apply_max_increment$OFFSET = 1104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t apply_max_increment
     * }
     */
    public static final long apply_max_increment$offset() { return apply_max_increment$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t apply_max_increment
     * }
     */
    public static boolean apply_max_increment(MemorySegment struct)
    {
        return struct.get(apply_max_increment$LAYOUT, apply_max_increment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t apply_max_increment
     * }
     */
    public static void apply_max_increment(MemorySegment struct, boolean fieldValue)
    {
        struct.set(apply_max_increment$LAYOUT, apply_max_increment$OFFSET, fieldValue);
    }

    private static final OfLong max_increment$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_increment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t max_increment
     * }
     */
    public static final OfLong max_increment$layout() { return max_increment$LAYOUT; }

    private static final long max_increment$OFFSET = 1112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t max_increment
     * }
     */
    public static final long max_increment$offset() { return max_increment$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t max_increment
     * }
     */
    public static long max_increment(MemorySegment struct)
    {
        return struct.get(max_increment$LAYOUT, max_increment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t max_increment
     * }
     */
    public static void max_increment(MemorySegment struct, long fieldValue)
    {
        struct.set(max_increment$LAYOUT, max_increment$OFFSET, fieldValue);
    }

    private static final OfInt flash_incr_mode$LAYOUT =
        (OfInt)$LAYOUT.select(groupElement("flash_incr_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum H5C_cache_flash_incr_mode flash_incr_mode
     * }
     */
    public static final OfInt flash_incr_mode$layout() { return flash_incr_mode$LAYOUT; }

    private static final long flash_incr_mode$OFFSET = 1120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum H5C_cache_flash_incr_mode flash_incr_mode
     * }
     */
    public static final long flash_incr_mode$offset() { return flash_incr_mode$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum H5C_cache_flash_incr_mode flash_incr_mode
     * }
     */
    public static int flash_incr_mode(MemorySegment struct)
    {
        return struct.get(flash_incr_mode$LAYOUT, flash_incr_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum H5C_cache_flash_incr_mode flash_incr_mode
     * }
     */
    public static void flash_incr_mode(MemorySegment struct, int fieldValue)
    {
        struct.set(flash_incr_mode$LAYOUT, flash_incr_mode$OFFSET, fieldValue);
    }

    private static final OfDouble flash_multiple$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("flash_multiple"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double flash_multiple
     * }
     */
    public static final OfDouble flash_multiple$layout() { return flash_multiple$LAYOUT; }

    private static final long flash_multiple$OFFSET = 1128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double flash_multiple
     * }
     */
    public static final long flash_multiple$offset() { return flash_multiple$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double flash_multiple
     * }
     */
    public static double flash_multiple(MemorySegment struct)
    {
        return struct.get(flash_multiple$LAYOUT, flash_multiple$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double flash_multiple
     * }
     */
    public static void flash_multiple(MemorySegment struct, double fieldValue)
    {
        struct.set(flash_multiple$LAYOUT, flash_multiple$OFFSET, fieldValue);
    }

    private static final OfDouble flash_threshold$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("flash_threshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double flash_threshold
     * }
     */
    public static final OfDouble flash_threshold$layout() { return flash_threshold$LAYOUT; }

    private static final long flash_threshold$OFFSET = 1136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double flash_threshold
     * }
     */
    public static final long flash_threshold$offset() { return flash_threshold$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double flash_threshold
     * }
     */
    public static double flash_threshold(MemorySegment struct)
    {
        return struct.get(flash_threshold$LAYOUT, flash_threshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double flash_threshold
     * }
     */
    public static void flash_threshold(MemorySegment struct, double fieldValue)
    {
        struct.set(flash_threshold$LAYOUT, flash_threshold$OFFSET, fieldValue);
    }

    private static final OfInt decr_mode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("decr_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum H5C_cache_decr_mode decr_mode
     * }
     */
    public static final OfInt decr_mode$layout() { return decr_mode$LAYOUT; }

    private static final long decr_mode$OFFSET = 1144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum H5C_cache_decr_mode decr_mode
     * }
     */
    public static final long decr_mode$offset() { return decr_mode$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum H5C_cache_decr_mode decr_mode
     * }
     */
    public static int decr_mode(MemorySegment struct)
    {
        return struct.get(decr_mode$LAYOUT, decr_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum H5C_cache_decr_mode decr_mode
     * }
     */
    public static void decr_mode(MemorySegment struct, int fieldValue)
    {
        struct.set(decr_mode$LAYOUT, decr_mode$OFFSET, fieldValue);
    }

    private static final OfDouble upper_hr_threshold$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("upper_hr_threshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double upper_hr_threshold
     * }
     */
    public static final OfDouble upper_hr_threshold$layout() { return upper_hr_threshold$LAYOUT; }

    private static final long upper_hr_threshold$OFFSET = 1152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double upper_hr_threshold
     * }
     */
    public static final long upper_hr_threshold$offset() { return upper_hr_threshold$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double upper_hr_threshold
     * }
     */
    public static double upper_hr_threshold(MemorySegment struct)
    {
        return struct.get(upper_hr_threshold$LAYOUT, upper_hr_threshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double upper_hr_threshold
     * }
     */
    public static void upper_hr_threshold(MemorySegment struct, double fieldValue)
    {
        struct.set(upper_hr_threshold$LAYOUT, upper_hr_threshold$OFFSET, fieldValue);
    }

    private static final OfDouble decrement$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("decrement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double decrement
     * }
     */
    public static final OfDouble decrement$layout() { return decrement$LAYOUT; }

    private static final long decrement$OFFSET = 1160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double decrement
     * }
     */
    public static final long decrement$offset() { return decrement$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double decrement
     * }
     */
    public static double decrement(MemorySegment struct)
    {
        return struct.get(decrement$LAYOUT, decrement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double decrement
     * }
     */
    public static void decrement(MemorySegment struct, double fieldValue)
    {
        struct.set(decrement$LAYOUT, decrement$OFFSET, fieldValue);
    }

    private static final OfBoolean apply_max_decrement$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("apply_max_decrement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t apply_max_decrement
     * }
     */
    public static final OfBoolean apply_max_decrement$layout() { return apply_max_decrement$LAYOUT; }

    private static final long apply_max_decrement$OFFSET = 1168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t apply_max_decrement
     * }
     */
    public static final long apply_max_decrement$offset() { return apply_max_decrement$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t apply_max_decrement
     * }
     */
    public static boolean apply_max_decrement(MemorySegment struct)
    {
        return struct.get(apply_max_decrement$LAYOUT, apply_max_decrement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t apply_max_decrement
     * }
     */
    public static void apply_max_decrement(MemorySegment struct, boolean fieldValue)
    {
        struct.set(apply_max_decrement$LAYOUT, apply_max_decrement$OFFSET, fieldValue);
    }

    private static final OfLong max_decrement$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_decrement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t max_decrement
     * }
     */
    public static final OfLong max_decrement$layout() { return max_decrement$LAYOUT; }

    private static final long max_decrement$OFFSET = 1176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t max_decrement
     * }
     */
    public static final long max_decrement$offset() { return max_decrement$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t max_decrement
     * }
     */
    public static long max_decrement(MemorySegment struct)
    {
        return struct.get(max_decrement$LAYOUT, max_decrement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t max_decrement
     * }
     */
    public static void max_decrement(MemorySegment struct, long fieldValue)
    {
        struct.set(max_decrement$LAYOUT, max_decrement$OFFSET, fieldValue);
    }

    private static final OfInt epochs_before_eviction$LAYOUT =
        (OfInt)$LAYOUT.select(groupElement("epochs_before_eviction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int epochs_before_eviction
     * }
     */
    public static final OfInt epochs_before_eviction$layout() { return epochs_before_eviction$LAYOUT; }

    private static final long epochs_before_eviction$OFFSET = 1184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int epochs_before_eviction
     * }
     */
    public static final long epochs_before_eviction$offset() { return epochs_before_eviction$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int epochs_before_eviction
     * }
     */
    public static int epochs_before_eviction(MemorySegment struct)
    {
        return struct.get(epochs_before_eviction$LAYOUT, epochs_before_eviction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int epochs_before_eviction
     * }
     */
    public static void epochs_before_eviction(MemorySegment struct, int fieldValue)
    {
        struct.set(epochs_before_eviction$LAYOUT, epochs_before_eviction$OFFSET, fieldValue);
    }

    private static final OfBoolean apply_empty_reserve$LAYOUT =
        (OfBoolean)$LAYOUT.select(groupElement("apply_empty_reserve"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hbool_t apply_empty_reserve
     * }
     */
    public static final OfBoolean apply_empty_reserve$layout() { return apply_empty_reserve$LAYOUT; }

    private static final long apply_empty_reserve$OFFSET = 1188;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hbool_t apply_empty_reserve
     * }
     */
    public static final long apply_empty_reserve$offset() { return apply_empty_reserve$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hbool_t apply_empty_reserve
     * }
     */
    public static boolean apply_empty_reserve(MemorySegment struct)
    {
        return struct.get(apply_empty_reserve$LAYOUT, apply_empty_reserve$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hbool_t apply_empty_reserve
     * }
     */
    public static void apply_empty_reserve(MemorySegment struct, boolean fieldValue)
    {
        struct.set(apply_empty_reserve$LAYOUT, apply_empty_reserve$OFFSET, fieldValue);
    }

    private static final OfDouble empty_reserve$LAYOUT =
        (OfDouble)$LAYOUT.select(groupElement("empty_reserve"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double empty_reserve
     * }
     */
    public static final OfDouble empty_reserve$layout() { return empty_reserve$LAYOUT; }

    private static final long empty_reserve$OFFSET = 1192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double empty_reserve
     * }
     */
    public static final long empty_reserve$offset() { return empty_reserve$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double empty_reserve
     * }
     */
    public static double empty_reserve(MemorySegment struct)
    {
        return struct.get(empty_reserve$LAYOUT, empty_reserve$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double empty_reserve
     * }
     */
    public static void empty_reserve(MemorySegment struct, double fieldValue)
    {
        struct.set(empty_reserve$LAYOUT, empty_reserve$OFFSET, fieldValue);
    }

    private static final OfLong dirty_bytes_threshold$LAYOUT =
        (OfLong)$LAYOUT.select(groupElement("dirty_bytes_threshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t dirty_bytes_threshold
     * }
     */
    public static final OfLong dirty_bytes_threshold$layout() { return dirty_bytes_threshold$LAYOUT; }

    private static final long dirty_bytes_threshold$OFFSET = 1200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t dirty_bytes_threshold
     * }
     */
    public static final long dirty_bytes_threshold$offset() { return dirty_bytes_threshold$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t dirty_bytes_threshold
     * }
     */
    public static long dirty_bytes_threshold(MemorySegment struct)
    {
        return struct.get(dirty_bytes_threshold$LAYOUT, dirty_bytes_threshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t dirty_bytes_threshold
     * }
     */
    public static void dirty_bytes_threshold(MemorySegment struct, long fieldValue)
    {
        struct.set(dirty_bytes_threshold$LAYOUT, dirty_bytes_threshold$OFFSET, fieldValue);
    }

    private static final OfInt metadata_write_strategy$LAYOUT =
        (OfInt)$LAYOUT.select(groupElement("metadata_write_strategy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int metadata_write_strategy
     * }
     */
    public static final OfInt metadata_write_strategy$layout() { return metadata_write_strategy$LAYOUT; }

    private static final long metadata_write_strategy$OFFSET = 1208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int metadata_write_strategy
     * }
     */
    public static final long metadata_write_strategy$offset() { return metadata_write_strategy$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int metadata_write_strategy
     * }
     */
    public static int metadata_write_strategy(MemorySegment struct)
    {
        return struct.get(metadata_write_strategy$LAYOUT, metadata_write_strategy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int metadata_write_strategy
     * }
     */
    public static void metadata_write_strategy(MemorySegment struct, int fieldValue)
    {
        struct.set(metadata_write_strategy$LAYOUT, metadata_write_strategy$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index)
    {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate(layout()); }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator)
    {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup)
    {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
                                            Consumer<MemorySegment> cleanup)
    {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
