// Generated by jextract

package org.hdfgroup.javahdf5;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct H5VL_file_get_args_t {
 *     H5VL_file_get_t op_type;
 *     union {
 *         struct {
 *             H5VL_file_cont_info_t *info;
 *         } get_cont_info;
 *         struct {
 *             hid_t fapl_id;
 *         } get_fapl;
 *         struct {
 *             hid_t fcpl_id;
 *         } get_fcpl;
 *         struct {
 *             unsigned long *fileno;
 *         } get_fileno;
 *         struct {
 *             unsigned int *flags;
 *         } get_intent;
 *         H5VL_file_get_name_args_t get_name;
 *         struct {
 *             unsigned int types;
 *             size_t *count;
 *         } get_obj_count;
 *         H5VL_file_get_obj_ids_args_t get_obj_ids;
 *     } args;
 * }
 * }
 */
public class H5VL_file_get_args_t {

    H5VL_file_get_args_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        hdf5_h.C_INT.withName("op_type"),
        MemoryLayout.paddingLayout(4),
        H5VL_file_get_args_t.args.layout().withName("args")
    ).withName("H5VL_file_get_args_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt op_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("op_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_file_get_t op_type
     * }
     */
    public static final OfInt op_type$layout() {
        return op_type$LAYOUT;
    }

    private static final long op_type$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_file_get_t op_type
     * }
     */
    public static final long op_type$offset() {
        return op_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_file_get_t op_type
     * }
     */
    public static int op_type(MemorySegment struct) {
        return struct.get(op_type$LAYOUT, op_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_file_get_t op_type
     * }
     */
    public static void op_type(MemorySegment struct, int fieldValue) {
        struct.set(op_type$LAYOUT, op_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union {
     *     struct {
     *         H5VL_file_cont_info_t *info;
     *     } get_cont_info;
     *     struct {
     *         hid_t fapl_id;
     *     } get_fapl;
     *     struct {
     *         hid_t fcpl_id;
     *     } get_fcpl;
     *     struct {
     *         unsigned long *fileno;
     *     } get_fileno;
     *     struct {
     *         unsigned int *flags;
     *     } get_intent;
     *     H5VL_file_get_name_args_t get_name;
     *     struct {
     *         unsigned int types;
     *         size_t *count;
     *     } get_obj_count;
     *     H5VL_file_get_obj_ids_args_t get_obj_ids;
     * }
     * }
     */
    public static class args {

        args() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            H5VL_file_get_args_t.args.get_cont_info.layout().withName("get_cont_info"),
            H5VL_file_get_args_t.args.get_fapl.layout().withName("get_fapl"),
            H5VL_file_get_args_t.args.get_fcpl.layout().withName("get_fcpl"),
            H5VL_file_get_args_t.args.get_fileno.layout().withName("get_fileno"),
            H5VL_file_get_args_t.args.get_intent.layout().withName("get_intent"),
            H5VL_file_get_name_args_t.layout().withName("get_name"),
            H5VL_file_get_args_t.args.get_obj_count.layout().withName("get_obj_count"),
            H5VL_file_get_obj_ids_args_t.layout().withName("get_obj_ids")
        ).withName("$anon$399:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     H5VL_file_cont_info_t *info;
         * }
         * }
         */
        public static class get_cont_info {

            get_cont_info() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_POINTER.withName("info")
            ).withName("$anon$401:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final AddressLayout info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("info"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * H5VL_file_cont_info_t *info
             * }
             */
            public static final AddressLayout info$layout() {
                return info$LAYOUT;
            }

            private static final long info$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * H5VL_file_cont_info_t *info
             * }
             */
            public static final long info$offset() {
                return info$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * H5VL_file_cont_info_t *info
             * }
             */
            public static MemorySegment info(MemorySegment struct) {
                return struct.get(info$LAYOUT, info$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * H5VL_file_cont_info_t *info
             * }
             */
            public static void info(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(info$LAYOUT, info$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_cont_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_cont_info"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     H5VL_file_cont_info_t *info;
         * } get_cont_info
         * }
         */
        public static final GroupLayout get_cont_info$layout() {
            return get_cont_info$LAYOUT;
        }

        private static final long get_cont_info$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     H5VL_file_cont_info_t *info;
         * } get_cont_info
         * }
         */
        public static final long get_cont_info$offset() {
            return get_cont_info$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     H5VL_file_cont_info_t *info;
         * } get_cont_info
         * }
         */
        public static MemorySegment get_cont_info(MemorySegment union) {
            return union.asSlice(get_cont_info$OFFSET, get_cont_info$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     H5VL_file_cont_info_t *info;
         * } get_cont_info
         * }
         */
        public static void get_cont_info(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_cont_info$OFFSET, get_cont_info$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     hid_t fapl_id;
         * }
         * }
         */
        public static class get_fapl {

            get_fapl() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_LONG.withName("fapl_id")
            ).withName("$anon$406:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfLong fapl_id$LAYOUT = (OfLong)$LAYOUT.select(groupElement("fapl_id"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * hid_t fapl_id
             * }
             */
            public static final OfLong fapl_id$layout() {
                return fapl_id$LAYOUT;
            }

            private static final long fapl_id$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * hid_t fapl_id
             * }
             */
            public static final long fapl_id$offset() {
                return fapl_id$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * hid_t fapl_id
             * }
             */
            public static long fapl_id(MemorySegment struct) {
                return struct.get(fapl_id$LAYOUT, fapl_id$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * hid_t fapl_id
             * }
             */
            public static void fapl_id(MemorySegment struct, long fieldValue) {
                struct.set(fapl_id$LAYOUT, fapl_id$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_fapl$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_fapl"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fapl_id;
         * } get_fapl
         * }
         */
        public static final GroupLayout get_fapl$layout() {
            return get_fapl$LAYOUT;
        }

        private static final long get_fapl$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fapl_id;
         * } get_fapl
         * }
         */
        public static final long get_fapl$offset() {
            return get_fapl$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fapl_id;
         * } get_fapl
         * }
         */
        public static MemorySegment get_fapl(MemorySegment union) {
            return union.asSlice(get_fapl$OFFSET, get_fapl$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fapl_id;
         * } get_fapl
         * }
         */
        public static void get_fapl(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_fapl$OFFSET, get_fapl$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     hid_t fcpl_id;
         * }
         * }
         */
        public static class get_fcpl {

            get_fcpl() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_LONG.withName("fcpl_id")
            ).withName("$anon$411:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfLong fcpl_id$LAYOUT = (OfLong)$LAYOUT.select(groupElement("fcpl_id"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * hid_t fcpl_id
             * }
             */
            public static final OfLong fcpl_id$layout() {
                return fcpl_id$LAYOUT;
            }

            private static final long fcpl_id$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * hid_t fcpl_id
             * }
             */
            public static final long fcpl_id$offset() {
                return fcpl_id$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * hid_t fcpl_id
             * }
             */
            public static long fcpl_id(MemorySegment struct) {
                return struct.get(fcpl_id$LAYOUT, fcpl_id$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * hid_t fcpl_id
             * }
             */
            public static void fcpl_id(MemorySegment struct, long fieldValue) {
                struct.set(fcpl_id$LAYOUT, fcpl_id$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_fcpl$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_fcpl"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fcpl_id;
         * } get_fcpl
         * }
         */
        public static final GroupLayout get_fcpl$layout() {
            return get_fcpl$LAYOUT;
        }

        private static final long get_fcpl$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fcpl_id;
         * } get_fcpl
         * }
         */
        public static final long get_fcpl$offset() {
            return get_fcpl$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fcpl_id;
         * } get_fcpl
         * }
         */
        public static MemorySegment get_fcpl(MemorySegment union) {
            return union.asSlice(get_fcpl$OFFSET, get_fcpl$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     hid_t fcpl_id;
         * } get_fcpl
         * }
         */
        public static void get_fcpl(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_fcpl$OFFSET, get_fcpl$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     unsigned long *fileno;
         * }
         * }
         */
        public static class get_fileno {

            get_fileno() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_POINTER.withName("fileno")
            ).withName("$anon$416:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final AddressLayout fileno$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileno"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * unsigned long *fileno
             * }
             */
            public static final AddressLayout fileno$layout() {
                return fileno$LAYOUT;
            }

            private static final long fileno$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * unsigned long *fileno
             * }
             */
            public static final long fileno$offset() {
                return fileno$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * unsigned long *fileno
             * }
             */
            public static MemorySegment fileno(MemorySegment struct) {
                return struct.get(fileno$LAYOUT, fileno$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * unsigned long *fileno
             * }
             */
            public static void fileno(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(fileno$LAYOUT, fileno$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_fileno$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_fileno"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned long *fileno;
         * } get_fileno
         * }
         */
        public static final GroupLayout get_fileno$layout() {
            return get_fileno$LAYOUT;
        }

        private static final long get_fileno$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned long *fileno;
         * } get_fileno
         * }
         */
        public static final long get_fileno$offset() {
            return get_fileno$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned long *fileno;
         * } get_fileno
         * }
         */
        public static MemorySegment get_fileno(MemorySegment union) {
            return union.asSlice(get_fileno$OFFSET, get_fileno$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned long *fileno;
         * } get_fileno
         * }
         */
        public static void get_fileno(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_fileno$OFFSET, get_fileno$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     unsigned int *flags;
         * }
         * }
         */
        public static class get_intent {

            get_intent() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_POINTER.withName("flags")
            ).withName("$anon$421:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final AddressLayout flags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flags"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * unsigned int *flags
             * }
             */
            public static final AddressLayout flags$layout() {
                return flags$LAYOUT;
            }

            private static final long flags$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * unsigned int *flags
             * }
             */
            public static final long flags$offset() {
                return flags$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * unsigned int *flags
             * }
             */
            public static MemorySegment flags(MemorySegment struct) {
                return struct.get(flags$LAYOUT, flags$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * unsigned int *flags
             * }
             */
            public static void flags(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_intent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_intent"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int *flags;
         * } get_intent
         * }
         */
        public static final GroupLayout get_intent$layout() {
            return get_intent$LAYOUT;
        }

        private static final long get_intent$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int *flags;
         * } get_intent
         * }
         */
        public static final long get_intent$offset() {
            return get_intent$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int *flags;
         * } get_intent
         * }
         */
        public static MemorySegment get_intent(MemorySegment union) {
            return union.asSlice(get_intent$OFFSET, get_intent$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int *flags;
         * } get_intent
         * }
         */
        public static void get_intent(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_intent$OFFSET, get_intent$LAYOUT.byteSize());
        }

        private static final GroupLayout get_name$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_name"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * H5VL_file_get_name_args_t get_name
         * }
         */
        public static final GroupLayout get_name$layout() {
            return get_name$LAYOUT;
        }

        private static final long get_name$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * H5VL_file_get_name_args_t get_name
         * }
         */
        public static final long get_name$offset() {
            return get_name$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * H5VL_file_get_name_args_t get_name
         * }
         */
        public static MemorySegment get_name(MemorySegment union) {
            return union.asSlice(get_name$OFFSET, get_name$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * H5VL_file_get_name_args_t get_name
         * }
         */
        public static void get_name(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_name$OFFSET, get_name$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     unsigned int types;
         *     size_t *count;
         * }
         * }
         */
        public static class get_obj_count {

            get_obj_count() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                hdf5_h.C_INT.withName("types"),
                MemoryLayout.paddingLayout(4),
                hdf5_h.C_POINTER.withName("count")
            ).withName("$anon$429:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt types$LAYOUT = (OfInt)$LAYOUT.select(groupElement("types"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * unsigned int types
             * }
             */
            public static final OfInt types$layout() {
                return types$LAYOUT;
            }

            private static final long types$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * unsigned int types
             * }
             */
            public static final long types$offset() {
                return types$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * unsigned int types
             * }
             */
            public static int types(MemorySegment struct) {
                return struct.get(types$LAYOUT, types$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * unsigned int types
             * }
             */
            public static void types(MemorySegment struct, int fieldValue) {
                struct.set(types$LAYOUT, types$OFFSET, fieldValue);
            }

            private static final AddressLayout count$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("count"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * size_t *count
             * }
             */
            public static final AddressLayout count$layout() {
                return count$LAYOUT;
            }

            private static final long count$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * size_t *count
             * }
             */
            public static final long count$offset() {
                return count$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * size_t *count
             * }
             */
            public static MemorySegment count(MemorySegment struct) {
                return struct.get(count$LAYOUT, count$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * size_t *count
             * }
             */
            public static void count(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(count$LAYOUT, count$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout get_obj_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_obj_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int types;
         *     size_t *count;
         * } get_obj_count
         * }
         */
        public static final GroupLayout get_obj_count$layout() {
            return get_obj_count$LAYOUT;
        }

        private static final long get_obj_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int types;
         *     size_t *count;
         * } get_obj_count
         * }
         */
        public static final long get_obj_count$offset() {
            return get_obj_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int types;
         *     size_t *count;
         * } get_obj_count
         * }
         */
        public static MemorySegment get_obj_count(MemorySegment union) {
            return union.asSlice(get_obj_count$OFFSET, get_obj_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     unsigned int types;
         *     size_t *count;
         * } get_obj_count
         * }
         */
        public static void get_obj_count(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_obj_count$OFFSET, get_obj_count$LAYOUT.byteSize());
        }

        private static final GroupLayout get_obj_ids$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_obj_ids"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * H5VL_file_get_obj_ids_args_t get_obj_ids
         * }
         */
        public static final GroupLayout get_obj_ids$layout() {
            return get_obj_ids$LAYOUT;
        }

        private static final long get_obj_ids$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * H5VL_file_get_obj_ids_args_t get_obj_ids
         * }
         */
        public static final long get_obj_ids$offset() {
            return get_obj_ids$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * H5VL_file_get_obj_ids_args_t get_obj_ids
         * }
         */
        public static MemorySegment get_obj_ids(MemorySegment union) {
            return union.asSlice(get_obj_ids$OFFSET, get_obj_ids$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * H5VL_file_get_obj_ids_args_t get_obj_ids
         * }
         */
        public static void get_obj_ids(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, get_obj_ids$OFFSET, get_obj_ids$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout args$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("args"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         H5VL_file_cont_info_t *info;
     *     } get_cont_info;
     *     struct {
     *         hid_t fapl_id;
     *     } get_fapl;
     *     struct {
     *         hid_t fcpl_id;
     *     } get_fcpl;
     *     struct {
     *         unsigned long *fileno;
     *     } get_fileno;
     *     struct {
     *         unsigned int *flags;
     *     } get_intent;
     *     H5VL_file_get_name_args_t get_name;
     *     struct {
     *         unsigned int types;
     *         size_t *count;
     *     } get_obj_count;
     *     H5VL_file_get_obj_ids_args_t get_obj_ids;
     * } args
     * }
     */
    public static final GroupLayout args$layout() {
        return args$LAYOUT;
    }

    private static final long args$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         H5VL_file_cont_info_t *info;
     *     } get_cont_info;
     *     struct {
     *         hid_t fapl_id;
     *     } get_fapl;
     *     struct {
     *         hid_t fcpl_id;
     *     } get_fcpl;
     *     struct {
     *         unsigned long *fileno;
     *     } get_fileno;
     *     struct {
     *         unsigned int *flags;
     *     } get_intent;
     *     H5VL_file_get_name_args_t get_name;
     *     struct {
     *         unsigned int types;
     *         size_t *count;
     *     } get_obj_count;
     *     H5VL_file_get_obj_ids_args_t get_obj_ids;
     * } args
     * }
     */
    public static final long args$offset() {
        return args$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         H5VL_file_cont_info_t *info;
     *     } get_cont_info;
     *     struct {
     *         hid_t fapl_id;
     *     } get_fapl;
     *     struct {
     *         hid_t fcpl_id;
     *     } get_fcpl;
     *     struct {
     *         unsigned long *fileno;
     *     } get_fileno;
     *     struct {
     *         unsigned int *flags;
     *     } get_intent;
     *     H5VL_file_get_name_args_t get_name;
     *     struct {
     *         unsigned int types;
     *         size_t *count;
     *     } get_obj_count;
     *     H5VL_file_get_obj_ids_args_t get_obj_ids;
     * } args
     * }
     */
    public static MemorySegment args(MemorySegment struct) {
        return struct.asSlice(args$OFFSET, args$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         H5VL_file_cont_info_t *info;
     *     } get_cont_info;
     *     struct {
     *         hid_t fapl_id;
     *     } get_fapl;
     *     struct {
     *         hid_t fcpl_id;
     *     } get_fcpl;
     *     struct {
     *         unsigned long *fileno;
     *     } get_fileno;
     *     struct {
     *         unsigned int *flags;
     *     } get_intent;
     *     H5VL_file_get_name_args_t get_name;
     *     struct {
     *         unsigned int types;
     *         size_t *count;
     *     } get_obj_count;
     *     H5VL_file_get_obj_ids_args_t get_obj_ids;
     * } args
     * }
     */
    public static void args(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, args$OFFSET, args$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

