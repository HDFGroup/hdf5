// Generated by jextract

package org.hdfgroup.javahdf5;

import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * {@snippet lang=c :
 * struct H5O_hdr_info_t {
 *     unsigned int version;
 *     unsigned int nmesgs;
 *     unsigned int nchunks;
 *     unsigned int flags;
 *     struct {
 *         hsize_t total;
 *         hsize_t meta;
 *         hsize_t mesg;
 *         hsize_t free;
 *     } space;
 *     struct {
 *         uint64_t present;
 *         uint64_t shared;
 *     } mesg;
 * }
 * }
 */
public class H5O_hdr_info_t {

    H5O_hdr_info_t()
    {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT =
        MemoryLayout
            .structLayout(hdf5_h.C_INT.withName("version"), hdf5_h.C_INT.withName("nmesgs"),
                          hdf5_h.C_INT.withName("nchunks"), hdf5_h.C_INT.withName("flags"),
                          H5O_hdr_info_t.space.layout().withName("space"),
                          H5O_hdr_info_t.mesg.layout().withName("mesg"))
            .withName("H5O_hdr_info_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() { return $LAYOUT; }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final OfInt version$layout() { return version$LAYOUT; }

    private static final long version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final long version$offset() { return version$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static int version(MemorySegment struct) { return struct.get(version$LAYOUT, version$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue)
    {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfInt nmesgs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nmesgs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nmesgs
     * }
     */
    public static final OfInt nmesgs$layout() { return nmesgs$LAYOUT; }

    private static final long nmesgs$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nmesgs
     * }
     */
    public static final long nmesgs$offset() { return nmesgs$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nmesgs
     * }
     */
    public static int nmesgs(MemorySegment struct) { return struct.get(nmesgs$LAYOUT, nmesgs$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nmesgs
     * }
     */
    public static void nmesgs(MemorySegment struct, int fieldValue)
    {
        struct.set(nmesgs$LAYOUT, nmesgs$OFFSET, fieldValue);
    }

    private static final OfInt nchunks$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nchunks"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nchunks
     * }
     */
    public static final OfInt nchunks$layout() { return nchunks$LAYOUT; }

    private static final long nchunks$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nchunks
     * }
     */
    public static final long nchunks$offset() { return nchunks$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nchunks
     * }
     */
    public static int nchunks(MemorySegment struct) { return struct.get(nchunks$LAYOUT, nchunks$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nchunks
     * }
     */
    public static void nchunks(MemorySegment struct, int fieldValue)
    {
        struct.set(nchunks$LAYOUT, nchunks$OFFSET, fieldValue);
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final OfInt flags$layout() { return flags$LAYOUT; }

    private static final long flags$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final long flags$offset() { return flags$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static int flags(MemorySegment struct) { return struct.get(flags$LAYOUT, flags$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue)
    {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     hsize_t total;
     *     hsize_t meta;
     *     hsize_t mesg;
     *     hsize_t free;
     * }
     * }
     */
    public static class space {

        space()
        {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT =
            MemoryLayout
                .structLayout(hdf5_h.C_LONG.withName("total"), hdf5_h.C_LONG.withName("meta"),
                              hdf5_h.C_LONG.withName("mesg"), hdf5_h.C_LONG.withName("free"))
                .withName("$anon$127:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() { return $LAYOUT; }

        private static final OfLong total$LAYOUT = (OfLong)$LAYOUT.select(groupElement("total"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t total
         * }
         */
        public static final OfLong total$layout() { return total$LAYOUT; }

        private static final long total$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t total
         * }
         */
        public static final long total$offset() { return total$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t total
         * }
         */
        public static long total(MemorySegment struct) { return struct.get(total$LAYOUT, total$OFFSET); }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t total
         * }
         */
        public static void total(MemorySegment struct, long fieldValue)
        {
            struct.set(total$LAYOUT, total$OFFSET, fieldValue);
        }

        private static final OfLong meta$LAYOUT = (OfLong)$LAYOUT.select(groupElement("meta"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t meta
         * }
         */
        public static final OfLong meta$layout() { return meta$LAYOUT; }

        private static final long meta$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t meta
         * }
         */
        public static final long meta$offset() { return meta$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t meta
         * }
         */
        public static long meta(MemorySegment struct) { return struct.get(meta$LAYOUT, meta$OFFSET); }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t meta
         * }
         */
        public static void meta(MemorySegment struct, long fieldValue)
        {
            struct.set(meta$LAYOUT, meta$OFFSET, fieldValue);
        }

        private static final OfLong mesg$LAYOUT = (OfLong)$LAYOUT.select(groupElement("mesg"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t mesg
         * }
         */
        public static final OfLong mesg$layout() { return mesg$LAYOUT; }

        private static final long mesg$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t mesg
         * }
         */
        public static final long mesg$offset() { return mesg$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t mesg
         * }
         */
        public static long mesg(MemorySegment struct) { return struct.get(mesg$LAYOUT, mesg$OFFSET); }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t mesg
         * }
         */
        public static void mesg(MemorySegment struct, long fieldValue)
        {
            struct.set(mesg$LAYOUT, mesg$OFFSET, fieldValue);
        }

        private static final OfLong free$LAYOUT = (OfLong)$LAYOUT.select(groupElement("free"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t free
         * }
         */
        public static final OfLong free$layout() { return free$LAYOUT; }

        private static final long free$OFFSET = 24;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t free
         * }
         */
        public static final long free$offset() { return free$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t free
         * }
         */
        public static long free(MemorySegment struct) { return struct.get(free$LAYOUT, free$OFFSET); }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t free
         * }
         */
        public static void free(MemorySegment struct, long fieldValue)
        {
            struct.set(free$LAYOUT, free$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index)
        {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator)
        {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator)
        {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena,
                                                Consumer<MemorySegment> cleanup)
        {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
                                                Consumer<MemorySegment> cleanup)
        {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout space$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("space"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t total;
     *     hsize_t meta;
     *     hsize_t mesg;
     *     hsize_t free;
     * } space
     * }
     */
    public static final GroupLayout space$layout() { return space$LAYOUT; }

    private static final long space$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t total;
     *     hsize_t meta;
     *     hsize_t mesg;
     *     hsize_t free;
     * } space
     * }
     */
    public static final long space$offset() { return space$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t total;
     *     hsize_t meta;
     *     hsize_t mesg;
     *     hsize_t free;
     * } space
     * }
     */
    public static MemorySegment space(MemorySegment struct)
    {
        return struct.asSlice(space$OFFSET, space$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t total;
     *     hsize_t meta;
     *     hsize_t mesg;
     *     hsize_t free;
     * } space
     * }
     */
    public static void space(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, space$OFFSET, space$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     uint64_t present;
     *     uint64_t shared;
     * }
     * }
     */
    public static class mesg {

        mesg()
        {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT =
            MemoryLayout.structLayout(hdf5_h.C_LONG.withName("present"), hdf5_h.C_LONG.withName("shared"))
                .withName("$anon$133:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() { return $LAYOUT; }

        private static final OfLong present$LAYOUT = (OfLong)$LAYOUT.select(groupElement("present"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * uint64_t present
         * }
         */
        public static final OfLong present$layout() { return present$LAYOUT; }

        private static final long present$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * uint64_t present
         * }
         */
        public static final long present$offset() { return present$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * uint64_t present
         * }
         */
        public static long present(MemorySegment struct)
        {
            return struct.get(present$LAYOUT, present$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * uint64_t present
         * }
         */
        public static void present(MemorySegment struct, long fieldValue)
        {
            struct.set(present$LAYOUT, present$OFFSET, fieldValue);
        }

        private static final OfLong shared$LAYOUT = (OfLong)$LAYOUT.select(groupElement("shared"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * uint64_t shared
         * }
         */
        public static final OfLong shared$layout() { return shared$LAYOUT; }

        private static final long shared$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * uint64_t shared
         * }
         */
        public static final long shared$offset() { return shared$OFFSET; }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * uint64_t shared
         * }
         */
        public static long shared(MemorySegment struct) { return struct.get(shared$LAYOUT, shared$OFFSET); }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * uint64_t shared
         * }
         */
        public static void shared(MemorySegment struct, long fieldValue)
        {
            struct.set(shared$LAYOUT, shared$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index)
        {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator)
        {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator)
        {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena,
                                                Consumer<MemorySegment> cleanup)
        {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
                                                Consumer<MemorySegment> cleanup)
        {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout mesg$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("mesg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t present;
     *     uint64_t shared;
     * } mesg
     * }
     */
    public static final GroupLayout mesg$layout() { return mesg$LAYOUT; }

    private static final long mesg$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t present;
     *     uint64_t shared;
     * } mesg
     * }
     */
    public static final long mesg$offset() { return mesg$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t present;
     *     uint64_t shared;
     * } mesg
     * }
     */
    public static MemorySegment mesg(MemorySegment struct)
    {
        return struct.asSlice(mesg$OFFSET, mesg$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t present;
     *     uint64_t shared;
     * } mesg
     * }
     */
    public static void mesg(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, mesg$OFFSET, mesg$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index)
    {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate(layout()); }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator)
    {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup)
    {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
                                            Consumer<MemorySegment> cleanup)
    {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
