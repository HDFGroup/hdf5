// Generated by jextract

package org.hdfgroup.javahdf5;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * union H5VL_native_file_optional_args_t {
 *     H5VL_native_file_get_file_image_t get_file_image;
 *     H5VL_native_file_get_free_sections_t get_free_sections;
 *     H5VL_native_file_get_freespace_t get_freespace;
 *     H5VL_native_file_get_info_t get_info;
 *     struct {
 *         H5AC_cache_config_t *config;
 *     } get_mdc_config;
 *     struct {
 *         double *hit_rate;
 *     } get_mdc_hit_rate;
 *     H5VL_native_file_get_mdc_size_t get_mdc_size;
 *     struct {
 *         hsize_t *size;
 *     } get_size;
 *     H5VL_native_file_get_vfd_handle_t get_vfd_handle;
 *     struct {
 *         const H5AC_cache_config_t *config;
 *     } set_mdc_config;
 *     struct {
 *         H5F_retry_info_t *info;
 *     } get_metadata_read_retry_info;
 *     H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status;
 *     H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats;
 *     H5VL_native_file_get_mdc_image_info_t get_mdc_image_info;
 *     struct {
 *         haddr_t *eoa;
 *     } get_eoa;
 *     struct {
 *         hsize_t increment;
 *     } increment_filesize;
 *     H5VL_native_file_set_libver_bounds_t set_libver_bounds;
 *     struct {
 *         hbool_t *minimize;
 *     } get_min_dset_ohdr_flag;
 *     struct {
 *         hbool_t minimize;
 *     } set_min_dset_ohdr_flag;
 * }
 * }
 */
public class H5VL_native_file_optional_args_t {

    H5VL_native_file_optional_args_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
        H5VL_native_file_get_file_image_t.layout().withName("get_file_image"),
        H5VL_native_file_get_free_sections_t.layout().withName("get_free_sections"),
        H5VL_native_file_get_freespace_t.layout().withName("get_freespace"),
        H5VL_native_file_get_info_t.layout().withName("get_info"),
        H5VL_native_file_optional_args_t.get_mdc_config.layout().withName("get_mdc_config"),
        H5VL_native_file_optional_args_t.get_mdc_hit_rate.layout().withName("get_mdc_hit_rate"),
        H5VL_native_file_get_mdc_size_t.layout().withName("get_mdc_size"),
        H5VL_native_file_optional_args_t.get_size.layout().withName("get_size"),
        H5VL_native_file_get_vfd_handle_t.layout().withName("get_vfd_handle"),
        H5VL_native_file_optional_args_t.set_mdc_config.layout().withName("set_mdc_config"),
        H5VL_native_file_optional_args_t.get_metadata_read_retry_info.layout().withName("get_metadata_read_retry_info"),
        H5VL_native_file_get_mdc_logging_status_t.layout().withName("get_mdc_logging_status"),
        H5VL_native_file_get_page_buffering_stats_t.layout().withName("get_page_buffering_stats"),
        H5VL_native_file_get_mdc_image_info_t.layout().withName("get_mdc_image_info"),
        H5VL_native_file_optional_args_t.get_eoa.layout().withName("get_eoa"),
        H5VL_native_file_optional_args_t.increment_filesize.layout().withName("increment_filesize"),
        H5VL_native_file_set_libver_bounds_t.layout().withName("set_libver_bounds"),
        H5VL_native_file_optional_args_t.get_min_dset_ohdr_flag.layout().withName("get_min_dset_ohdr_flag"),
        H5VL_native_file_optional_args_t.set_min_dset_ohdr_flag.layout().withName("set_min_dset_ohdr_flag")
    ).withName("H5VL_native_file_optional_args_t");

    /**
     * The layout of this union
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout get_file_image$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_file_image"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_file_image_t get_file_image
     * }
     */
    public static final GroupLayout get_file_image$layout() {
        return get_file_image$LAYOUT;
    }

    private static final long get_file_image$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_file_image_t get_file_image
     * }
     */
    public static final long get_file_image$offset() {
        return get_file_image$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_file_image_t get_file_image
     * }
     */
    public static MemorySegment get_file_image(MemorySegment union) {
        return union.asSlice(get_file_image$OFFSET, get_file_image$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_file_image_t get_file_image
     * }
     */
    public static void get_file_image(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_file_image$OFFSET, get_file_image$LAYOUT.byteSize());
    }

    private static final GroupLayout get_free_sections$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_free_sections"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_free_sections_t get_free_sections
     * }
     */
    public static final GroupLayout get_free_sections$layout() {
        return get_free_sections$LAYOUT;
    }

    private static final long get_free_sections$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_free_sections_t get_free_sections
     * }
     */
    public static final long get_free_sections$offset() {
        return get_free_sections$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_free_sections_t get_free_sections
     * }
     */
    public static MemorySegment get_free_sections(MemorySegment union) {
        return union.asSlice(get_free_sections$OFFSET, get_free_sections$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_free_sections_t get_free_sections
     * }
     */
    public static void get_free_sections(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_free_sections$OFFSET, get_free_sections$LAYOUT.byteSize());
    }

    private static final GroupLayout get_freespace$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_freespace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_freespace_t get_freespace
     * }
     */
    public static final GroupLayout get_freespace$layout() {
        return get_freespace$LAYOUT;
    }

    private static final long get_freespace$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_freespace_t get_freespace
     * }
     */
    public static final long get_freespace$offset() {
        return get_freespace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_freespace_t get_freespace
     * }
     */
    public static MemorySegment get_freespace(MemorySegment union) {
        return union.asSlice(get_freespace$OFFSET, get_freespace$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_freespace_t get_freespace
     * }
     */
    public static void get_freespace(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_freespace$OFFSET, get_freespace$LAYOUT.byteSize());
    }

    private static final GroupLayout get_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_info_t get_info
     * }
     */
    public static final GroupLayout get_info$layout() {
        return get_info$LAYOUT;
    }

    private static final long get_info$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_info_t get_info
     * }
     */
    public static final long get_info$offset() {
        return get_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_info_t get_info
     * }
     */
    public static MemorySegment get_info(MemorySegment union) {
        return union.asSlice(get_info$OFFSET, get_info$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_info_t get_info
     * }
     */
    public static void get_info(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_info$OFFSET, get_info$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     H5AC_cache_config_t *config;
     * }
     * }
     */
    public static class get_mdc_config {

        get_mdc_config() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("config")
        ).withName("$anon$310:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout config$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("config"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * H5AC_cache_config_t *config
         * }
         */
        public static final AddressLayout config$layout() {
            return config$LAYOUT;
        }

        private static final long config$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * H5AC_cache_config_t *config
         * }
         */
        public static final long config$offset() {
            return config$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * H5AC_cache_config_t *config
         * }
         */
        public static MemorySegment config(MemorySegment struct) {
            return struct.get(config$LAYOUT, config$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * H5AC_cache_config_t *config
         * }
         */
        public static void config(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(config$LAYOUT, config$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_mdc_config$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_mdc_config"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     H5AC_cache_config_t *config;
     * } get_mdc_config
     * }
     */
    public static final GroupLayout get_mdc_config$layout() {
        return get_mdc_config$LAYOUT;
    }

    private static final long get_mdc_config$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     H5AC_cache_config_t *config;
     * } get_mdc_config
     * }
     */
    public static final long get_mdc_config$offset() {
        return get_mdc_config$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     H5AC_cache_config_t *config;
     * } get_mdc_config
     * }
     */
    public static MemorySegment get_mdc_config(MemorySegment union) {
        return union.asSlice(get_mdc_config$OFFSET, get_mdc_config$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     H5AC_cache_config_t *config;
     * } get_mdc_config
     * }
     */
    public static void get_mdc_config(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_mdc_config$OFFSET, get_mdc_config$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     double *hit_rate;
     * }
     * }
     */
    public static class get_mdc_hit_rate {

        get_mdc_hit_rate() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("hit_rate")
        ).withName("$anon$315:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout hit_rate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hit_rate"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * double *hit_rate
         * }
         */
        public static final AddressLayout hit_rate$layout() {
            return hit_rate$LAYOUT;
        }

        private static final long hit_rate$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * double *hit_rate
         * }
         */
        public static final long hit_rate$offset() {
            return hit_rate$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * double *hit_rate
         * }
         */
        public static MemorySegment hit_rate(MemorySegment struct) {
            return struct.get(hit_rate$LAYOUT, hit_rate$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * double *hit_rate
         * }
         */
        public static void hit_rate(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(hit_rate$LAYOUT, hit_rate$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_mdc_hit_rate$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_mdc_hit_rate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     double *hit_rate;
     * } get_mdc_hit_rate
     * }
     */
    public static final GroupLayout get_mdc_hit_rate$layout() {
        return get_mdc_hit_rate$LAYOUT;
    }

    private static final long get_mdc_hit_rate$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     double *hit_rate;
     * } get_mdc_hit_rate
     * }
     */
    public static final long get_mdc_hit_rate$offset() {
        return get_mdc_hit_rate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     double *hit_rate;
     * } get_mdc_hit_rate
     * }
     */
    public static MemorySegment get_mdc_hit_rate(MemorySegment union) {
        return union.asSlice(get_mdc_hit_rate$OFFSET, get_mdc_hit_rate$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     double *hit_rate;
     * } get_mdc_hit_rate
     * }
     */
    public static void get_mdc_hit_rate(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_mdc_hit_rate$OFFSET, get_mdc_hit_rate$LAYOUT.byteSize());
    }

    private static final GroupLayout get_mdc_size$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_mdc_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_size_t get_mdc_size
     * }
     */
    public static final GroupLayout get_mdc_size$layout() {
        return get_mdc_size$LAYOUT;
    }

    private static final long get_mdc_size$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_size_t get_mdc_size
     * }
     */
    public static final long get_mdc_size$offset() {
        return get_mdc_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_size_t get_mdc_size
     * }
     */
    public static MemorySegment get_mdc_size(MemorySegment union) {
        return union.asSlice(get_mdc_size$OFFSET, get_mdc_size$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_size_t get_mdc_size
     * }
     */
    public static void get_mdc_size(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_mdc_size$OFFSET, get_mdc_size$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     hsize_t *size;
     * }
     * }
     */
    public static class get_size {

        get_size() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("size")
        ).withName("$anon$323:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout size$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("size"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t *size
         * }
         */
        public static final AddressLayout size$layout() {
            return size$LAYOUT;
        }

        private static final long size$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t *size
         * }
         */
        public static final long size$offset() {
            return size$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t *size
         * }
         */
        public static MemorySegment size(MemorySegment struct) {
            return struct.get(size$LAYOUT, size$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t *size
         * }
         */
        public static void size(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(size$LAYOUT, size$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_size$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t *size;
     * } get_size
     * }
     */
    public static final GroupLayout get_size$layout() {
        return get_size$LAYOUT;
    }

    private static final long get_size$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t *size;
     * } get_size
     * }
     */
    public static final long get_size$offset() {
        return get_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t *size;
     * } get_size
     * }
     */
    public static MemorySegment get_size(MemorySegment union) {
        return union.asSlice(get_size$OFFSET, get_size$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t *size;
     * } get_size
     * }
     */
    public static void get_size(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_size$OFFSET, get_size$LAYOUT.byteSize());
    }

    private static final GroupLayout get_vfd_handle$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_vfd_handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_vfd_handle_t get_vfd_handle
     * }
     */
    public static final GroupLayout get_vfd_handle$layout() {
        return get_vfd_handle$LAYOUT;
    }

    private static final long get_vfd_handle$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_vfd_handle_t get_vfd_handle
     * }
     */
    public static final long get_vfd_handle$offset() {
        return get_vfd_handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_vfd_handle_t get_vfd_handle
     * }
     */
    public static MemorySegment get_vfd_handle(MemorySegment union) {
        return union.asSlice(get_vfd_handle$OFFSET, get_vfd_handle$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_vfd_handle_t get_vfd_handle
     * }
     */
    public static void get_vfd_handle(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_vfd_handle$OFFSET, get_vfd_handle$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     const H5AC_cache_config_t *config;
     * }
     * }
     */
    public static class set_mdc_config {

        set_mdc_config() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("config")
        ).withName("$anon$334:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout config$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("config"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * const H5AC_cache_config_t *config
         * }
         */
        public static final AddressLayout config$layout() {
            return config$LAYOUT;
        }

        private static final long config$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * const H5AC_cache_config_t *config
         * }
         */
        public static final long config$offset() {
            return config$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * const H5AC_cache_config_t *config
         * }
         */
        public static MemorySegment config(MemorySegment struct) {
            return struct.get(config$LAYOUT, config$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * const H5AC_cache_config_t *config
         * }
         */
        public static void config(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(config$LAYOUT, config$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout set_mdc_config$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("set_mdc_config"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     const H5AC_cache_config_t *config;
     * } set_mdc_config
     * }
     */
    public static final GroupLayout set_mdc_config$layout() {
        return set_mdc_config$LAYOUT;
    }

    private static final long set_mdc_config$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     const H5AC_cache_config_t *config;
     * } set_mdc_config
     * }
     */
    public static final long set_mdc_config$offset() {
        return set_mdc_config$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     const H5AC_cache_config_t *config;
     * } set_mdc_config
     * }
     */
    public static MemorySegment set_mdc_config(MemorySegment union) {
        return union.asSlice(set_mdc_config$OFFSET, set_mdc_config$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     const H5AC_cache_config_t *config;
     * } set_mdc_config
     * }
     */
    public static void set_mdc_config(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, set_mdc_config$OFFSET, set_mdc_config$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     H5F_retry_info_t *info;
     * }
     * }
     */
    public static class get_metadata_read_retry_info {

        get_metadata_read_retry_info() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("info")
        ).withName("$anon$339:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("info"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * H5F_retry_info_t *info
         * }
         */
        public static final AddressLayout info$layout() {
            return info$LAYOUT;
        }

        private static final long info$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * H5F_retry_info_t *info
         * }
         */
        public static final long info$offset() {
            return info$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * H5F_retry_info_t *info
         * }
         */
        public static MemorySegment info(MemorySegment struct) {
            return struct.get(info$LAYOUT, info$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * H5F_retry_info_t *info
         * }
         */
        public static void info(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(info$LAYOUT, info$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_metadata_read_retry_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_metadata_read_retry_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     H5F_retry_info_t *info;
     * } get_metadata_read_retry_info
     * }
     */
    public static final GroupLayout get_metadata_read_retry_info$layout() {
        return get_metadata_read_retry_info$LAYOUT;
    }

    private static final long get_metadata_read_retry_info$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     H5F_retry_info_t *info;
     * } get_metadata_read_retry_info
     * }
     */
    public static final long get_metadata_read_retry_info$offset() {
        return get_metadata_read_retry_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     H5F_retry_info_t *info;
     * } get_metadata_read_retry_info
     * }
     */
    public static MemorySegment get_metadata_read_retry_info(MemorySegment union) {
        return union.asSlice(get_metadata_read_retry_info$OFFSET, get_metadata_read_retry_info$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     H5F_retry_info_t *info;
     * } get_metadata_read_retry_info
     * }
     */
    public static void get_metadata_read_retry_info(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_metadata_read_retry_info$OFFSET, get_metadata_read_retry_info$LAYOUT.byteSize());
    }

    private static final GroupLayout get_mdc_logging_status$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_mdc_logging_status"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status
     * }
     */
    public static final GroupLayout get_mdc_logging_status$layout() {
        return get_mdc_logging_status$LAYOUT;
    }

    private static final long get_mdc_logging_status$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status
     * }
     */
    public static final long get_mdc_logging_status$offset() {
        return get_mdc_logging_status$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status
     * }
     */
    public static MemorySegment get_mdc_logging_status(MemorySegment union) {
        return union.asSlice(get_mdc_logging_status$OFFSET, get_mdc_logging_status$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status
     * }
     */
    public static void get_mdc_logging_status(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_mdc_logging_status$OFFSET, get_mdc_logging_status$LAYOUT.byteSize());
    }

    private static final GroupLayout get_page_buffering_stats$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_page_buffering_stats"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats
     * }
     */
    public static final GroupLayout get_page_buffering_stats$layout() {
        return get_page_buffering_stats$LAYOUT;
    }

    private static final long get_page_buffering_stats$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats
     * }
     */
    public static final long get_page_buffering_stats$offset() {
        return get_page_buffering_stats$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats
     * }
     */
    public static MemorySegment get_page_buffering_stats(MemorySegment union) {
        return union.asSlice(get_page_buffering_stats$OFFSET, get_page_buffering_stats$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats
     * }
     */
    public static void get_page_buffering_stats(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_page_buffering_stats$OFFSET, get_page_buffering_stats$LAYOUT.byteSize());
    }

    private static final GroupLayout get_mdc_image_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_mdc_image_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_image_info_t get_mdc_image_info
     * }
     */
    public static final GroupLayout get_mdc_image_info$layout() {
        return get_mdc_image_info$LAYOUT;
    }

    private static final long get_mdc_image_info$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_image_info_t get_mdc_image_info
     * }
     */
    public static final long get_mdc_image_info$offset() {
        return get_mdc_image_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_image_info_t get_mdc_image_info
     * }
     */
    public static MemorySegment get_mdc_image_info(MemorySegment union) {
        return union.asSlice(get_mdc_image_info$OFFSET, get_mdc_image_info$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_get_mdc_image_info_t get_mdc_image_info
     * }
     */
    public static void get_mdc_image_info(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_mdc_image_info$OFFSET, get_mdc_image_info$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     haddr_t *eoa;
     * }
     * }
     */
    public static class get_eoa {

        get_eoa() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("eoa")
        ).withName("$anon$368:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout eoa$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("eoa"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * haddr_t *eoa
         * }
         */
        public static final AddressLayout eoa$layout() {
            return eoa$LAYOUT;
        }

        private static final long eoa$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * haddr_t *eoa
         * }
         */
        public static final long eoa$offset() {
            return eoa$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * haddr_t *eoa
         * }
         */
        public static MemorySegment eoa(MemorySegment struct) {
            return struct.get(eoa$LAYOUT, eoa$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * haddr_t *eoa
         * }
         */
        public static void eoa(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(eoa$LAYOUT, eoa$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_eoa$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_eoa"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     haddr_t *eoa;
     * } get_eoa
     * }
     */
    public static final GroupLayout get_eoa$layout() {
        return get_eoa$LAYOUT;
    }

    private static final long get_eoa$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     haddr_t *eoa;
     * } get_eoa
     * }
     */
    public static final long get_eoa$offset() {
        return get_eoa$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     haddr_t *eoa;
     * } get_eoa
     * }
     */
    public static MemorySegment get_eoa(MemorySegment union) {
        return union.asSlice(get_eoa$OFFSET, get_eoa$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     haddr_t *eoa;
     * } get_eoa
     * }
     */
    public static void get_eoa(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_eoa$OFFSET, get_eoa$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     hsize_t increment;
     * }
     * }
     */
    public static class increment_filesize {

        increment_filesize() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_LONG.withName("increment")
        ).withName("$anon$373:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfLong increment$LAYOUT = (OfLong)$LAYOUT.select(groupElement("increment"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hsize_t increment
         * }
         */
        public static final OfLong increment$layout() {
            return increment$LAYOUT;
        }

        private static final long increment$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hsize_t increment
         * }
         */
        public static final long increment$offset() {
            return increment$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hsize_t increment
         * }
         */
        public static long increment(MemorySegment struct) {
            return struct.get(increment$LAYOUT, increment$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hsize_t increment
         * }
         */
        public static void increment(MemorySegment struct, long fieldValue) {
            struct.set(increment$LAYOUT, increment$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout increment_filesize$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("increment_filesize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t increment;
     * } increment_filesize
     * }
     */
    public static final GroupLayout increment_filesize$layout() {
        return increment_filesize$LAYOUT;
    }

    private static final long increment_filesize$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t increment;
     * } increment_filesize
     * }
     */
    public static final long increment_filesize$offset() {
        return increment_filesize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t increment;
     * } increment_filesize
     * }
     */
    public static MemorySegment increment_filesize(MemorySegment union) {
        return union.asSlice(increment_filesize$OFFSET, increment_filesize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     hsize_t increment;
     * } increment_filesize
     * }
     */
    public static void increment_filesize(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, increment_filesize$OFFSET, increment_filesize$LAYOUT.byteSize());
    }

    private static final GroupLayout set_libver_bounds$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("set_libver_bounds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_native_file_set_libver_bounds_t set_libver_bounds
     * }
     */
    public static final GroupLayout set_libver_bounds$layout() {
        return set_libver_bounds$LAYOUT;
    }

    private static final long set_libver_bounds$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_native_file_set_libver_bounds_t set_libver_bounds
     * }
     */
    public static final long set_libver_bounds$offset() {
        return set_libver_bounds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_native_file_set_libver_bounds_t set_libver_bounds
     * }
     */
    public static MemorySegment set_libver_bounds(MemorySegment union) {
        return union.asSlice(set_libver_bounds$OFFSET, set_libver_bounds$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_native_file_set_libver_bounds_t set_libver_bounds
     * }
     */
    public static void set_libver_bounds(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, set_libver_bounds$OFFSET, set_libver_bounds$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     hbool_t *minimize;
     * }
     * }
     */
    public static class get_min_dset_ohdr_flag {

        get_min_dset_ohdr_flag() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_POINTER.withName("minimize")
        ).withName("$anon$381:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout minimize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("minimize"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hbool_t *minimize
         * }
         */
        public static final AddressLayout minimize$layout() {
            return minimize$LAYOUT;
        }

        private static final long minimize$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hbool_t *minimize
         * }
         */
        public static final long minimize$offset() {
            return minimize$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hbool_t *minimize
         * }
         */
        public static MemorySegment minimize(MemorySegment struct) {
            return struct.get(minimize$LAYOUT, minimize$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hbool_t *minimize
         * }
         */
        public static void minimize(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(minimize$LAYOUT, minimize$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout get_min_dset_ohdr_flag$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("get_min_dset_ohdr_flag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t *minimize;
     * } get_min_dset_ohdr_flag
     * }
     */
    public static final GroupLayout get_min_dset_ohdr_flag$layout() {
        return get_min_dset_ohdr_flag$LAYOUT;
    }

    private static final long get_min_dset_ohdr_flag$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t *minimize;
     * } get_min_dset_ohdr_flag
     * }
     */
    public static final long get_min_dset_ohdr_flag$offset() {
        return get_min_dset_ohdr_flag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t *minimize;
     * } get_min_dset_ohdr_flag
     * }
     */
    public static MemorySegment get_min_dset_ohdr_flag(MemorySegment union) {
        return union.asSlice(get_min_dset_ohdr_flag$OFFSET, get_min_dset_ohdr_flag$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t *minimize;
     * } get_min_dset_ohdr_flag
     * }
     */
    public static void get_min_dset_ohdr_flag(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, get_min_dset_ohdr_flag$OFFSET, get_min_dset_ohdr_flag$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     hbool_t minimize;
     * }
     * }
     */
    public static class set_min_dset_ohdr_flag {

        set_min_dset_ohdr_flag() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            hdf5_h.C_BOOL.withName("minimize")
        ).withName("$anon$386:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfBoolean minimize$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("minimize"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * hbool_t minimize
         * }
         */
        public static final OfBoolean minimize$layout() {
            return minimize$LAYOUT;
        }

        private static final long minimize$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * hbool_t minimize
         * }
         */
        public static final long minimize$offset() {
            return minimize$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * hbool_t minimize
         * }
         */
        public static boolean minimize(MemorySegment struct) {
            return struct.get(minimize$LAYOUT, minimize$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * hbool_t minimize
         * }
         */
        public static void minimize(MemorySegment struct, boolean fieldValue) {
            struct.set(minimize$LAYOUT, minimize$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout set_min_dset_ohdr_flag$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("set_min_dset_ohdr_flag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t minimize;
     * } set_min_dset_ohdr_flag
     * }
     */
    public static final GroupLayout set_min_dset_ohdr_flag$layout() {
        return set_min_dset_ohdr_flag$LAYOUT;
    }

    private static final long set_min_dset_ohdr_flag$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t minimize;
     * } set_min_dset_ohdr_flag
     * }
     */
    public static final long set_min_dset_ohdr_flag$offset() {
        return set_min_dset_ohdr_flag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t minimize;
     * } set_min_dset_ohdr_flag
     * }
     */
    public static MemorySegment set_min_dset_ohdr_flag(MemorySegment union) {
        return union.asSlice(set_min_dset_ohdr_flag$OFFSET, set_min_dset_ohdr_flag$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     hbool_t minimize;
     * } set_min_dset_ohdr_flag
     * }
     */
    public static void set_min_dset_ohdr_flag(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, set_min_dset_ohdr_flag$OFFSET, set_min_dset_ohdr_flag$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this union
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

