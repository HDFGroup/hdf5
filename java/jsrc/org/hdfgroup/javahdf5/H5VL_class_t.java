// Generated by jextract

package org.hdfgroup.javahdf5;

import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * {@snippet lang=c :
 * struct H5VL_class_t {
 *     unsigned int version;
 *     H5VL_class_value_t value;
 *     const char *name;
 *     unsigned int conn_version;
 *     uint64_t cap_flags;
 *     herr_t (*initialize)(hid_t);
 *     herr_t (*terminate)(void);
 *     H5VL_info_class_t info_cls;
 *     H5VL_wrap_class_t wrap_cls;
 *     H5VL_attr_class_t attr_cls;
 *     H5VL_dataset_class_t dataset_cls;
 *     H5VL_datatype_class_t datatype_cls;
 *     H5VL_file_class_t file_cls;
 *     H5VL_group_class_t group_cls;
 *     H5VL_link_class_t link_cls;
 *     H5VL_object_class_t object_cls;
 *     H5VL_introspect_class_t introspect_cls;
 *     H5VL_request_class_t request_cls;
 *     H5VL_blob_class_t blob_cls;
 *     H5VL_token_class_t token_cls;
 *     herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **);
 * }
 * }
 */
public class H5VL_class_t {

    H5VL_class_t()
    {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT =
        MemoryLayout
            .structLayout(hdf5_h.C_INT.withName("version"), hdf5_h.C_INT.withName("value"),
                          hdf5_h.C_POINTER.withName("name"), hdf5_h.C_INT.withName("conn_version"),
                          MemoryLayout.paddingLayout(4), hdf5_h.C_LONG.withName("cap_flags"),
                          hdf5_h.C_POINTER.withName("initialize"), hdf5_h.C_POINTER.withName("terminate"),
                          H5VL_info_class_t.layout().withName("info_cls"),
                          H5VL_wrap_class_t.layout().withName("wrap_cls"),
                          H5VL_attr_class_t.layout().withName("attr_cls"),
                          H5VL_dataset_class_t.layout().withName("dataset_cls"),
                          H5VL_datatype_class_t.layout().withName("datatype_cls"),
                          H5VL_file_class_t.layout().withName("file_cls"),
                          H5VL_group_class_t.layout().withName("group_cls"),
                          H5VL_link_class_t.layout().withName("link_cls"),
                          H5VL_object_class_t.layout().withName("object_cls"),
                          H5VL_introspect_class_t.layout().withName("introspect_cls"),
                          H5VL_request_class_t.layout().withName("request_cls"),
                          H5VL_blob_class_t.layout().withName("blob_cls"),
                          H5VL_token_class_t.layout().withName("token_cls"),
                          hdf5_h.C_POINTER.withName("optional"))
            .withName("H5VL_class_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() { return $LAYOUT; }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final OfInt version$layout() { return version$LAYOUT; }

    private static final long version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final long version$offset() { return version$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static int version(MemorySegment struct) { return struct.get(version$LAYOUT, version$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue)
    {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfInt value$LAYOUT = (OfInt)$LAYOUT.select(groupElement("value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_class_value_t value
     * }
     */
    public static final OfInt value$layout() { return value$LAYOUT; }

    private static final long value$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_class_value_t value
     * }
     */
    public static final long value$offset() { return value$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_class_value_t value
     * }
     */
    public static int value(MemorySegment struct) { return struct.get(value$LAYOUT, value$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_class_value_t value
     * }
     */
    public static void value(MemorySegment struct, int fieldValue)
    {
        struct.set(value$LAYOUT, value$OFFSET, fieldValue);
    }

    private static final AddressLayout name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final AddressLayout name$layout() { return name$LAYOUT; }

    private static final long name$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final long name$offset() { return name$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static MemorySegment name(MemorySegment struct) { return struct.get(name$LAYOUT, name$OFFSET); }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static void name(MemorySegment struct, MemorySegment fieldValue)
    {
        struct.set(name$LAYOUT, name$OFFSET, fieldValue);
    }

    private static final OfInt conn_version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("conn_version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int conn_version
     * }
     */
    public static final OfInt conn_version$layout() { return conn_version$LAYOUT; }

    private static final long conn_version$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int conn_version
     * }
     */
    public static final long conn_version$offset() { return conn_version$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int conn_version
     * }
     */
    public static int conn_version(MemorySegment struct)
    {
        return struct.get(conn_version$LAYOUT, conn_version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int conn_version
     * }
     */
    public static void conn_version(MemorySegment struct, int fieldValue)
    {
        struct.set(conn_version$LAYOUT, conn_version$OFFSET, fieldValue);
    }

    private static final OfLong cap_flags$LAYOUT = (OfLong)$LAYOUT.select(groupElement("cap_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t cap_flags
     * }
     */
    public static final OfLong cap_flags$layout() { return cap_flags$LAYOUT; }

    private static final long cap_flags$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t cap_flags
     * }
     */
    public static final long cap_flags$offset() { return cap_flags$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t cap_flags
     * }
     */
    public static long cap_flags(MemorySegment struct)
    {
        return struct.get(cap_flags$LAYOUT, cap_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t cap_flags
     * }
     */
    public static void cap_flags(MemorySegment struct, long fieldValue)
    {
        struct.set(cap_flags$LAYOUT, cap_flags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*initialize)(hid_t)
     * }
     */
    public static class initialize {

        initialize()
        {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(long _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(hdf5_h.C_INT, hdf5_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() { return $DESC; }

        private static final MethodHandle UP$MH =
            hdf5_h.upcallHandle(initialize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(initialize.Function fi, Arena arena)
        {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, long _x0)
        {
            try {
                return (int)DOWN$MH.invokeExact(funcPtr, _x0);
            }
            catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout initialize$LAYOUT =
        (AddressLayout)$LAYOUT.select(groupElement("initialize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*initialize)(hid_t)
     * }
     */
    public static final AddressLayout initialize$layout() { return initialize$LAYOUT; }

    private static final long initialize$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*initialize)(hid_t)
     * }
     */
    public static final long initialize$offset() { return initialize$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*initialize)(hid_t)
     * }
     */
    public static MemorySegment initialize(MemorySegment struct)
    {
        return struct.get(initialize$LAYOUT, initialize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*initialize)(hid_t)
     * }
     */
    public static void initialize(MemorySegment struct, MemorySegment fieldValue)
    {
        struct.set(initialize$LAYOUT, initialize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static class terminate {

        terminate()
        {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(hdf5_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() { return $DESC; }

        private static final MethodHandle UP$MH =
            hdf5_h.upcallHandle(terminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(terminate.Function fi, Arena arena)
        {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr)
        {
            try {
                return (int)DOWN$MH.invokeExact(funcPtr);
            }
            catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout terminate$LAYOUT =
        (AddressLayout)$LAYOUT.select(groupElement("terminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static final AddressLayout terminate$layout() { return terminate$LAYOUT; }

    private static final long terminate$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static final long terminate$offset() { return terminate$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static MemorySegment terminate(MemorySegment struct)
    {
        return struct.get(terminate$LAYOUT, terminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static void terminate(MemorySegment struct, MemorySegment fieldValue)
    {
        struct.set(terminate$LAYOUT, terminate$OFFSET, fieldValue);
    }

    private static final GroupLayout info_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_info_class_t info_cls
     * }
     */
    public static final GroupLayout info_cls$layout() { return info_cls$LAYOUT; }

    private static final long info_cls$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_info_class_t info_cls
     * }
     */
    public static final long info_cls$offset() { return info_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_info_class_t info_cls
     * }
     */
    public static MemorySegment info_cls(MemorySegment struct)
    {
        return struct.asSlice(info_cls$OFFSET, info_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_info_class_t info_cls
     * }
     */
    public static void info_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, info_cls$OFFSET, info_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout wrap_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("wrap_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_wrap_class_t wrap_cls
     * }
     */
    public static final GroupLayout wrap_cls$layout() { return wrap_cls$LAYOUT; }

    private static final long wrap_cls$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_wrap_class_t wrap_cls
     * }
     */
    public static final long wrap_cls$offset() { return wrap_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_wrap_class_t wrap_cls
     * }
     */
    public static MemorySegment wrap_cls(MemorySegment struct)
    {
        return struct.asSlice(wrap_cls$OFFSET, wrap_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_wrap_class_t wrap_cls
     * }
     */
    public static void wrap_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, wrap_cls$OFFSET, wrap_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout attr_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("attr_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_attr_class_t attr_cls
     * }
     */
    public static final GroupLayout attr_cls$layout() { return attr_cls$LAYOUT; }

    private static final long attr_cls$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_attr_class_t attr_cls
     * }
     */
    public static final long attr_cls$offset() { return attr_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_attr_class_t attr_cls
     * }
     */
    public static MemorySegment attr_cls(MemorySegment struct)
    {
        return struct.asSlice(attr_cls$OFFSET, attr_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_attr_class_t attr_cls
     * }
     */
    public static void attr_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, attr_cls$OFFSET, attr_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout dataset_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("dataset_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_dataset_class_t dataset_cls
     * }
     */
    public static final GroupLayout dataset_cls$layout() { return dataset_cls$LAYOUT; }

    private static final long dataset_cls$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_dataset_class_t dataset_cls
     * }
     */
    public static final long dataset_cls$offset() { return dataset_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_dataset_class_t dataset_cls
     * }
     */
    public static MemorySegment dataset_cls(MemorySegment struct)
    {
        return struct.asSlice(dataset_cls$OFFSET, dataset_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_dataset_class_t dataset_cls
     * }
     */
    public static void dataset_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, dataset_cls$OFFSET, dataset_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout datatype_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("datatype_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_datatype_class_t datatype_cls
     * }
     */
    public static final GroupLayout datatype_cls$layout() { return datatype_cls$LAYOUT; }

    private static final long datatype_cls$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_datatype_class_t datatype_cls
     * }
     */
    public static final long datatype_cls$offset() { return datatype_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_datatype_class_t datatype_cls
     * }
     */
    public static MemorySegment datatype_cls(MemorySegment struct)
    {
        return struct.asSlice(datatype_cls$OFFSET, datatype_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_datatype_class_t datatype_cls
     * }
     */
    public static void datatype_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, datatype_cls$OFFSET, datatype_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout file_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("file_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_file_class_t file_cls
     * }
     */
    public static final GroupLayout file_cls$layout() { return file_cls$LAYOUT; }

    private static final long file_cls$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_file_class_t file_cls
     * }
     */
    public static final long file_cls$offset() { return file_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_file_class_t file_cls
     * }
     */
    public static MemorySegment file_cls(MemorySegment struct)
    {
        return struct.asSlice(file_cls$OFFSET, file_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_file_class_t file_cls
     * }
     */
    public static void file_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, file_cls$OFFSET, file_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout group_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("group_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_group_class_t group_cls
     * }
     */
    public static final GroupLayout group_cls$layout() { return group_cls$LAYOUT; }

    private static final long group_cls$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_group_class_t group_cls
     * }
     */
    public static final long group_cls$offset() { return group_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_group_class_t group_cls
     * }
     */
    public static MemorySegment group_cls(MemorySegment struct)
    {
        return struct.asSlice(group_cls$OFFSET, group_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_group_class_t group_cls
     * }
     */
    public static void group_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, group_cls$OFFSET, group_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout link_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("link_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_link_class_t link_cls
     * }
     */
    public static final GroupLayout link_cls$layout() { return link_cls$LAYOUT; }

    private static final long link_cls$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_link_class_t link_cls
     * }
     */
    public static final long link_cls$offset() { return link_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_link_class_t link_cls
     * }
     */
    public static MemorySegment link_cls(MemorySegment struct)
    {
        return struct.asSlice(link_cls$OFFSET, link_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_link_class_t link_cls
     * }
     */
    public static void link_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, link_cls$OFFSET, link_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout object_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("object_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_object_class_t object_cls
     * }
     */
    public static final GroupLayout object_cls$layout() { return object_cls$LAYOUT; }

    private static final long object_cls$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_object_class_t object_cls
     * }
     */
    public static final long object_cls$offset() { return object_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_object_class_t object_cls
     * }
     */
    public static MemorySegment object_cls(MemorySegment struct)
    {
        return struct.asSlice(object_cls$OFFSET, object_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_object_class_t object_cls
     * }
     */
    public static void object_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, object_cls$OFFSET, object_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout introspect_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("introspect_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_introspect_class_t introspect_cls
     * }
     */
    public static final GroupLayout introspect_cls$layout() { return introspect_cls$LAYOUT; }

    private static final long introspect_cls$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_introspect_class_t introspect_cls
     * }
     */
    public static final long introspect_cls$offset() { return introspect_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_introspect_class_t introspect_cls
     * }
     */
    public static MemorySegment introspect_cls(MemorySegment struct)
    {
        return struct.asSlice(introspect_cls$OFFSET, introspect_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_introspect_class_t introspect_cls
     * }
     */
    public static void introspect_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, introspect_cls$OFFSET, introspect_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout request_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("request_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_request_class_t request_cls
     * }
     */
    public static final GroupLayout request_cls$layout() { return request_cls$LAYOUT; }

    private static final long request_cls$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_request_class_t request_cls
     * }
     */
    public static final long request_cls$offset() { return request_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_request_class_t request_cls
     * }
     */
    public static MemorySegment request_cls(MemorySegment struct)
    {
        return struct.asSlice(request_cls$OFFSET, request_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_request_class_t request_cls
     * }
     */
    public static void request_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, request_cls$OFFSET, request_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout blob_cls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("blob_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_blob_class_t blob_cls
     * }
     */
    public static final GroupLayout blob_cls$layout() { return blob_cls$LAYOUT; }

    private static final long blob_cls$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_blob_class_t blob_cls
     * }
     */
    public static final long blob_cls$offset() { return blob_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_blob_class_t blob_cls
     * }
     */
    public static MemorySegment blob_cls(MemorySegment struct)
    {
        return struct.asSlice(blob_cls$OFFSET, blob_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_blob_class_t blob_cls
     * }
     */
    public static void blob_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, blob_cls$OFFSET, blob_cls$LAYOUT.byteSize());
    }

    private static final GroupLayout token_cls$LAYOUT =
        (GroupLayout)$LAYOUT.select(groupElement("token_cls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5VL_token_class_t token_cls
     * }
     */
    public static final GroupLayout token_cls$layout() { return token_cls$LAYOUT; }

    private static final long token_cls$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5VL_token_class_t token_cls
     * }
     */
    public static final long token_cls$offset() { return token_cls$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5VL_token_class_t token_cls
     * }
     */
    public static MemorySegment token_cls(MemorySegment struct)
    {
        return struct.asSlice(token_cls$OFFSET, token_cls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5VL_token_class_t token_cls
     * }
     */
    public static void token_cls(MemorySegment struct, MemorySegment fieldValue)
    {
        MemorySegment.copy(fieldValue, 0L, struct, token_cls$OFFSET, token_cls$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **)
     * }
     */
    public static class optional {

        optional()
        {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT, hdf5_h.C_POINTER, hdf5_h.C_POINTER, hdf5_h.C_LONG, hdf5_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() { return $DESC; }

        private static final MethodHandle UP$MH =
            hdf5_h.upcallHandle(optional.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(optional.Function fi, Arena arena)
        {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2,
                                 MemorySegment _x3)
        {
            try {
                return (int)DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            }
            catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout optional$LAYOUT =
        (AddressLayout)$LAYOUT.select(groupElement("optional"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **)
     * }
     */
    public static final AddressLayout optional$layout() { return optional$LAYOUT; }

    private static final long optional$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **)
     * }
     */
    public static final long optional$offset() { return optional$OFFSET; }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **)
     * }
     */
    public static MemorySegment optional(MemorySegment struct)
    {
        return struct.get(optional$LAYOUT, optional$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*optional)(void *, H5VL_optional_args_t *, hid_t, void **)
     * }
     */
    public static void optional(MemorySegment struct, MemorySegment fieldValue)
    {
        struct.set(optional$LAYOUT, optional$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index)
    {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate(layout()); }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator)
    {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup)
    {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
                                            Consumer<MemorySegment> cleanup)
    {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
