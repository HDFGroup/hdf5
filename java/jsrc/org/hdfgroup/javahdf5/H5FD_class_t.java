// Generated by jextract

package org.hdfgroup.javahdf5;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct H5FD_class_t {
 *     unsigned int version;
 *     H5FD_class_value_t value;
 *     const char *name;
 *     haddr_t maxaddr;
 *     H5F_close_degree_t fc_degree;
 *     herr_t (*terminate)(void);
 *     hsize_t (*sb_size)(H5FD_t *);
 *     herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *);
 *     herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *);
 *     size_t fapl_size;
 *     void *(*fapl_get)(H5FD_t *);
 *     void *(*fapl_copy)(const void *);
 *     herr_t (*fapl_free)(void *);
 *     size_t dxpl_size;
 *     void *(*dxpl_copy)(const void *);
 *     herr_t (*dxpl_free)(void *);
 *     H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t);
 *     herr_t (*close)(H5FD_t *);
 *     int (*cmp)(const H5FD_t *, const H5FD_t *);
 *     herr_t (*query)(const H5FD_t *, unsigned long *);
 *     herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *);
 *     haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t);
 *     herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t);
 *     haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t);
 *     herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t);
 *     haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t);
 *     herr_t (*get_handle)(H5FD_t *, hid_t, void **);
 *     herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *);
 *     herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *);
 *     herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **);
 *     herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **);
 *     herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **);
 *     herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **);
 *     herr_t (*flush)(H5FD_t *, hid_t, hbool_t);
 *     herr_t (*truncate)(H5FD_t *, hid_t, hbool_t);
 *     herr_t (*lock)(H5FD_t *, hbool_t);
 *     herr_t (*unlock)(H5FD_t *);
 *     herr_t (*del)(const char *, hid_t);
 *     herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **);
 *     H5FD_mem_t fl_map[7];
 * }
 * }
 */
public class H5FD_class_t {

    H5FD_class_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        hdf5_h.C_INT.withName("version"),
        hdf5_h.C_INT.withName("value"),
        hdf5_h.C_POINTER.withName("name"),
        hdf5_h.C_LONG.withName("maxaddr"),
        hdf5_h.C_INT.withName("fc_degree"),
        MemoryLayout.paddingLayout(4),
        hdf5_h.C_POINTER.withName("terminate"),
        hdf5_h.C_POINTER.withName("sb_size"),
        hdf5_h.C_POINTER.withName("sb_encode"),
        hdf5_h.C_POINTER.withName("sb_decode"),
        hdf5_h.C_LONG.withName("fapl_size"),
        hdf5_h.C_POINTER.withName("fapl_get"),
        hdf5_h.C_POINTER.withName("fapl_copy"),
        hdf5_h.C_POINTER.withName("fapl_free"),
        hdf5_h.C_LONG.withName("dxpl_size"),
        hdf5_h.C_POINTER.withName("dxpl_copy"),
        hdf5_h.C_POINTER.withName("dxpl_free"),
        hdf5_h.C_POINTER.withName("open"),
        hdf5_h.C_POINTER.withName("close"),
        hdf5_h.C_POINTER.withName("cmp"),
        hdf5_h.C_POINTER.withName("query"),
        hdf5_h.C_POINTER.withName("get_type_map"),
        hdf5_h.C_POINTER.withName("alloc"),
        hdf5_h.C_POINTER.withName("free"),
        hdf5_h.C_POINTER.withName("get_eoa"),
        hdf5_h.C_POINTER.withName("set_eoa"),
        hdf5_h.C_POINTER.withName("get_eof"),
        hdf5_h.C_POINTER.withName("get_handle"),
        hdf5_h.C_POINTER.withName("read"),
        hdf5_h.C_POINTER.withName("write"),
        hdf5_h.C_POINTER.withName("read_vector"),
        hdf5_h.C_POINTER.withName("write_vector"),
        hdf5_h.C_POINTER.withName("read_selection"),
        hdf5_h.C_POINTER.withName("write_selection"),
        hdf5_h.C_POINTER.withName("flush"),
        hdf5_h.C_POINTER.withName("truncate"),
        hdf5_h.C_POINTER.withName("lock"),
        hdf5_h.C_POINTER.withName("unlock"),
        hdf5_h.C_POINTER.withName("del"),
        hdf5_h.C_POINTER.withName("ctl"),
        MemoryLayout.sequenceLayout(7, hdf5_h.C_INT).withName("fl_map"),
        MemoryLayout.paddingLayout(4)
    ).withName("H5FD_class_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final OfInt version$layout() {
        return version$LAYOUT;
    }

    private static final long version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final long version$offset() {
        return version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static int version(MemorySegment struct) {
        return struct.get(version$LAYOUT, version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue) {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfInt value$LAYOUT = (OfInt)$LAYOUT.select(groupElement("value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5FD_class_value_t value
     * }
     */
    public static final OfInt value$layout() {
        return value$LAYOUT;
    }

    private static final long value$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5FD_class_value_t value
     * }
     */
    public static final long value$offset() {
        return value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5FD_class_value_t value
     * }
     */
    public static int value(MemorySegment struct) {
        return struct.get(value$LAYOUT, value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5FD_class_value_t value
     * }
     */
    public static void value(MemorySegment struct, int fieldValue) {
        struct.set(value$LAYOUT, value$OFFSET, fieldValue);
    }

    private static final AddressLayout name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final AddressLayout name$layout() {
        return name$LAYOUT;
    }

    private static final long name$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final long name$offset() {
        return name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static MemorySegment name(MemorySegment struct) {
        return struct.get(name$LAYOUT, name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static void name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(name$LAYOUT, name$OFFSET, fieldValue);
    }

    private static final OfLong maxaddr$LAYOUT = (OfLong)$LAYOUT.select(groupElement("maxaddr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * haddr_t maxaddr
     * }
     */
    public static final OfLong maxaddr$layout() {
        return maxaddr$LAYOUT;
    }

    private static final long maxaddr$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * haddr_t maxaddr
     * }
     */
    public static final long maxaddr$offset() {
        return maxaddr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * haddr_t maxaddr
     * }
     */
    public static long maxaddr(MemorySegment struct) {
        return struct.get(maxaddr$LAYOUT, maxaddr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * haddr_t maxaddr
     * }
     */
    public static void maxaddr(MemorySegment struct, long fieldValue) {
        struct.set(maxaddr$LAYOUT, maxaddr$OFFSET, fieldValue);
    }

    private static final OfInt fc_degree$LAYOUT = (OfInt)$LAYOUT.select(groupElement("fc_degree"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5F_close_degree_t fc_degree
     * }
     */
    public static final OfInt fc_degree$layout() {
        return fc_degree$LAYOUT;
    }

    private static final long fc_degree$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5F_close_degree_t fc_degree
     * }
     */
    public static final long fc_degree$offset() {
        return fc_degree$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5F_close_degree_t fc_degree
     * }
     */
    public static int fc_degree(MemorySegment struct) {
        return struct.get(fc_degree$LAYOUT, fc_degree$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5F_close_degree_t fc_degree
     * }
     */
    public static void fc_degree(MemorySegment struct, int fieldValue) {
        struct.set(fc_degree$LAYOUT, fc_degree$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static class terminate {

        terminate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(terminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(terminate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout terminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("terminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static final AddressLayout terminate$layout() {
        return terminate$LAYOUT;
    }

    private static final long terminate$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static final long terminate$offset() {
        return terminate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static MemorySegment terminate(MemorySegment struct) {
        return struct.get(terminate$LAYOUT, terminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*terminate)(void)
     * }
     */
    public static void terminate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(terminate$LAYOUT, terminate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * hsize_t (*sb_size)(H5FD_t *)
     * }
     */
    public static class sb_size {

        sb_size() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(sb_size.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sb_size.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sb_size$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sb_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * hsize_t (*sb_size)(H5FD_t *)
     * }
     */
    public static final AddressLayout sb_size$layout() {
        return sb_size$LAYOUT;
    }

    private static final long sb_size$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * hsize_t (*sb_size)(H5FD_t *)
     * }
     */
    public static final long sb_size$offset() {
        return sb_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * hsize_t (*sb_size)(H5FD_t *)
     * }
     */
    public static MemorySegment sb_size(MemorySegment struct) {
        return struct.get(sb_size$LAYOUT, sb_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * hsize_t (*sb_size)(H5FD_t *)
     * }
     */
    public static void sb_size(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sb_size$LAYOUT, sb_size$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *)
     * }
     */
    public static class sb_encode {

        sb_encode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(sb_encode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sb_encode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sb_encode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sb_encode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *)
     * }
     */
    public static final AddressLayout sb_encode$layout() {
        return sb_encode$LAYOUT;
    }

    private static final long sb_encode$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *)
     * }
     */
    public static final long sb_encode$offset() {
        return sb_encode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *)
     * }
     */
    public static MemorySegment sb_encode(MemorySegment struct) {
        return struct.get(sb_encode$LAYOUT, sb_encode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*sb_encode)(H5FD_t *, char *, unsigned char *)
     * }
     */
    public static void sb_encode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sb_encode$LAYOUT, sb_encode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *)
     * }
     */
    public static class sb_decode {

        sb_decode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(sb_decode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sb_decode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sb_decode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sb_decode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *)
     * }
     */
    public static final AddressLayout sb_decode$layout() {
        return sb_decode$LAYOUT;
    }

    private static final long sb_decode$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *)
     * }
     */
    public static final long sb_decode$offset() {
        return sb_decode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *)
     * }
     */
    public static MemorySegment sb_decode(MemorySegment struct) {
        return struct.get(sb_decode$LAYOUT, sb_decode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*sb_decode)(H5FD_t *, const char *, const unsigned char *)
     * }
     */
    public static void sb_decode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sb_decode$LAYOUT, sb_decode$OFFSET, fieldValue);
    }

    private static final OfLong fapl_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("fapl_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t fapl_size
     * }
     */
    public static final OfLong fapl_size$layout() {
        return fapl_size$LAYOUT;
    }

    private static final long fapl_size$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t fapl_size
     * }
     */
    public static final long fapl_size$offset() {
        return fapl_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t fapl_size
     * }
     */
    public static long fapl_size(MemorySegment struct) {
        return struct.get(fapl_size$LAYOUT, fapl_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t fapl_size
     * }
     */
    public static void fapl_size(MemorySegment struct, long fieldValue) {
        struct.set(fapl_size$LAYOUT, fapl_size$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*fapl_get)(H5FD_t *)
     * }
     */
    public static class fapl_get {

        fapl_get() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(fapl_get.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fapl_get.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fapl_get$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fapl_get"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*fapl_get)(H5FD_t *)
     * }
     */
    public static final AddressLayout fapl_get$layout() {
        return fapl_get$LAYOUT;
    }

    private static final long fapl_get$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*fapl_get)(H5FD_t *)
     * }
     */
    public static final long fapl_get$offset() {
        return fapl_get$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*fapl_get)(H5FD_t *)
     * }
     */
    public static MemorySegment fapl_get(MemorySegment struct) {
        return struct.get(fapl_get$LAYOUT, fapl_get$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*fapl_get)(H5FD_t *)
     * }
     */
    public static void fapl_get(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fapl_get$LAYOUT, fapl_get$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*fapl_copy)(const void *)
     * }
     */
    public static class fapl_copy {

        fapl_copy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(fapl_copy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fapl_copy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fapl_copy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fapl_copy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*fapl_copy)(const void *)
     * }
     */
    public static final AddressLayout fapl_copy$layout() {
        return fapl_copy$LAYOUT;
    }

    private static final long fapl_copy$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*fapl_copy)(const void *)
     * }
     */
    public static final long fapl_copy$offset() {
        return fapl_copy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*fapl_copy)(const void *)
     * }
     */
    public static MemorySegment fapl_copy(MemorySegment struct) {
        return struct.get(fapl_copy$LAYOUT, fapl_copy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*fapl_copy)(const void *)
     * }
     */
    public static void fapl_copy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fapl_copy$LAYOUT, fapl_copy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*fapl_free)(void *)
     * }
     */
    public static class fapl_free {

        fapl_free() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(fapl_free.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fapl_free.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fapl_free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fapl_free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*fapl_free)(void *)
     * }
     */
    public static final AddressLayout fapl_free$layout() {
        return fapl_free$LAYOUT;
    }

    private static final long fapl_free$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*fapl_free)(void *)
     * }
     */
    public static final long fapl_free$offset() {
        return fapl_free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*fapl_free)(void *)
     * }
     */
    public static MemorySegment fapl_free(MemorySegment struct) {
        return struct.get(fapl_free$LAYOUT, fapl_free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*fapl_free)(void *)
     * }
     */
    public static void fapl_free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fapl_free$LAYOUT, fapl_free$OFFSET, fieldValue);
    }

    private static final OfLong dxpl_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("dxpl_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t dxpl_size
     * }
     */
    public static final OfLong dxpl_size$layout() {
        return dxpl_size$LAYOUT;
    }

    private static final long dxpl_size$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t dxpl_size
     * }
     */
    public static final long dxpl_size$offset() {
        return dxpl_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t dxpl_size
     * }
     */
    public static long dxpl_size(MemorySegment struct) {
        return struct.get(dxpl_size$LAYOUT, dxpl_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t dxpl_size
     * }
     */
    public static void dxpl_size(MemorySegment struct, long fieldValue) {
        struct.set(dxpl_size$LAYOUT, dxpl_size$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*dxpl_copy)(const void *)
     * }
     */
    public static class dxpl_copy {

        dxpl_copy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(dxpl_copy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dxpl_copy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dxpl_copy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dxpl_copy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*dxpl_copy)(const void *)
     * }
     */
    public static final AddressLayout dxpl_copy$layout() {
        return dxpl_copy$LAYOUT;
    }

    private static final long dxpl_copy$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*dxpl_copy)(const void *)
     * }
     */
    public static final long dxpl_copy$offset() {
        return dxpl_copy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*dxpl_copy)(const void *)
     * }
     */
    public static MemorySegment dxpl_copy(MemorySegment struct) {
        return struct.get(dxpl_copy$LAYOUT, dxpl_copy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*dxpl_copy)(const void *)
     * }
     */
    public static void dxpl_copy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dxpl_copy$LAYOUT, dxpl_copy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*dxpl_free)(void *)
     * }
     */
    public static class dxpl_free {

        dxpl_free() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(dxpl_free.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dxpl_free.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dxpl_free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dxpl_free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*dxpl_free)(void *)
     * }
     */
    public static final AddressLayout dxpl_free$layout() {
        return dxpl_free$LAYOUT;
    }

    private static final long dxpl_free$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*dxpl_free)(void *)
     * }
     */
    public static final long dxpl_free$offset() {
        return dxpl_free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*dxpl_free)(void *)
     * }
     */
    public static MemorySegment dxpl_free(MemorySegment struct) {
        return struct.get(dxpl_free$LAYOUT, dxpl_free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*dxpl_free)(void *)
     * }
     */
    public static void dxpl_free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dxpl_free$LAYOUT, dxpl_free$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t)
     * }
     */
    public static class open {

        open() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, long _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(open.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t)
     * }
     */
    public static final AddressLayout open$layout() {
        return open$LAYOUT;
    }

    private static final long open$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t)
     * }
     */
    public static final long open$offset() {
        return open$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t)
     * }
     */
    public static MemorySegment open(MemorySegment struct) {
        return struct.get(open$LAYOUT, open$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5FD_t *(*open)(const char *, unsigned int, hid_t, haddr_t)
     * }
     */
    public static void open(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open$LAYOUT, open$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*close)(H5FD_t *)
     * }
     */
    public static class close {

        close() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(close.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(close.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout close$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*close)(H5FD_t *)
     * }
     */
    public static final AddressLayout close$layout() {
        return close$LAYOUT;
    }

    private static final long close$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*close)(H5FD_t *)
     * }
     */
    public static final long close$offset() {
        return close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*close)(H5FD_t *)
     * }
     */
    public static MemorySegment close(MemorySegment struct) {
        return struct.get(close$LAYOUT, close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*close)(H5FD_t *)
     * }
     */
    public static void close(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(close$LAYOUT, close$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*cmp)(const H5FD_t *, const H5FD_t *)
     * }
     */
    public static class cmp {

        cmp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(cmp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cmp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cmp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cmp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*cmp)(const H5FD_t *, const H5FD_t *)
     * }
     */
    public static final AddressLayout cmp$layout() {
        return cmp$LAYOUT;
    }

    private static final long cmp$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*cmp)(const H5FD_t *, const H5FD_t *)
     * }
     */
    public static final long cmp$offset() {
        return cmp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*cmp)(const H5FD_t *, const H5FD_t *)
     * }
     */
    public static MemorySegment cmp(MemorySegment struct) {
        return struct.get(cmp$LAYOUT, cmp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*cmp)(const H5FD_t *, const H5FD_t *)
     * }
     */
    public static void cmp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cmp$LAYOUT, cmp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*query)(const H5FD_t *, unsigned long *)
     * }
     */
    public static class query {

        query() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(query.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*query)(const H5FD_t *, unsigned long *)
     * }
     */
    public static final AddressLayout query$layout() {
        return query$LAYOUT;
    }

    private static final long query$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*query)(const H5FD_t *, unsigned long *)
     * }
     */
    public static final long query$offset() {
        return query$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*query)(const H5FD_t *, unsigned long *)
     * }
     */
    public static MemorySegment query(MemorySegment struct) {
        return struct.get(query$LAYOUT, query$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*query)(const H5FD_t *, unsigned long *)
     * }
     */
    public static void query(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query$LAYOUT, query$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *)
     * }
     */
    public static class get_type_map {

        get_type_map() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(get_type_map.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_type_map.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_type_map$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_type_map"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *)
     * }
     */
    public static final AddressLayout get_type_map$layout() {
        return get_type_map$LAYOUT;
    }

    private static final long get_type_map$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *)
     * }
     */
    public static final long get_type_map$offset() {
        return get_type_map$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *)
     * }
     */
    public static MemorySegment get_type_map(MemorySegment struct) {
        return struct.get(get_type_map$LAYOUT, get_type_map$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*get_type_map)(const H5FD_t *, H5FD_mem_t *)
     * }
     */
    public static void get_type_map(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_type_map$LAYOUT, get_type_map$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t)
     * }
     */
    public static class alloc {

        alloc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, int _x1, long _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(alloc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t)
     * }
     */
    public static final AddressLayout alloc$layout() {
        return alloc$LAYOUT;
    }

    private static final long alloc$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t)
     * }
     */
    public static final long alloc$offset() {
        return alloc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t)
     * }
     */
    public static MemorySegment alloc(MemorySegment struct) {
        return struct.get(alloc$LAYOUT, alloc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * haddr_t (*alloc)(H5FD_t *, H5FD_mem_t, hid_t, hsize_t)
     * }
     */
    public static void alloc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc$LAYOUT, alloc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t)
     * }
     */
    public static class free {

        free() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(free.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(free.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, long _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t)
     * }
     */
    public static final AddressLayout free$layout() {
        return free$LAYOUT;
    }

    private static final long free$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t)
     * }
     */
    public static final long free$offset() {
        return free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t)
     * }
     */
    public static MemorySegment free(MemorySegment struct) {
        return struct.get(free$LAYOUT, free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*free)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, hsize_t)
     * }
     */
    public static void free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(free$LAYOUT, free$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static class get_eoa {

        get_eoa() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(get_eoa.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_eoa.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_eoa$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_eoa"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static final AddressLayout get_eoa$layout() {
        return get_eoa$LAYOUT;
    }

    private static final long get_eoa$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static final long get_eoa$offset() {
        return get_eoa$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static MemorySegment get_eoa(MemorySegment struct) {
        return struct.get(get_eoa$LAYOUT, get_eoa$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * haddr_t (*get_eoa)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static void get_eoa(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_eoa$LAYOUT, get_eoa$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t)
     * }
     */
    public static class set_eoa {

        set_eoa() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(set_eoa.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_eoa.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_eoa$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_eoa"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t)
     * }
     */
    public static final AddressLayout set_eoa$layout() {
        return set_eoa$LAYOUT;
    }

    private static final long set_eoa$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t)
     * }
     */
    public static final long set_eoa$offset() {
        return set_eoa$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t)
     * }
     */
    public static MemorySegment set_eoa(MemorySegment struct) {
        return struct.get(set_eoa$LAYOUT, set_eoa$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*set_eoa)(H5FD_t *, H5FD_mem_t, haddr_t)
     * }
     */
    public static void set_eoa(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_eoa$LAYOUT, set_eoa$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static class get_eof {

        get_eof() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(get_eof.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_eof.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_eof$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_eof"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static final AddressLayout get_eof$layout() {
        return get_eof$LAYOUT;
    }

    private static final long get_eof$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static final long get_eof$offset() {
        return get_eof$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static MemorySegment get_eof(MemorySegment struct) {
        return struct.get(get_eof$LAYOUT, get_eof$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * haddr_t (*get_eof)(const H5FD_t *, H5FD_mem_t)
     * }
     */
    public static void get_eof(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_eof$LAYOUT, get_eof$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*get_handle)(H5FD_t *, hid_t, void **)
     * }
     */
    public static class get_handle {

        get_handle() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(get_handle.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_handle.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_handle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*get_handle)(H5FD_t *, hid_t, void **)
     * }
     */
    public static final AddressLayout get_handle$layout() {
        return get_handle$LAYOUT;
    }

    private static final long get_handle$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*get_handle)(H5FD_t *, hid_t, void **)
     * }
     */
    public static final long get_handle$offset() {
        return get_handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*get_handle)(H5FD_t *, hid_t, void **)
     * }
     */
    public static MemorySegment get_handle(MemorySegment struct) {
        return struct.get(get_handle$LAYOUT, get_handle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*get_handle)(H5FD_t *, hid_t, void **)
     * }
     */
    public static void get_handle(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_handle$LAYOUT, get_handle$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *)
     * }
     */
    public static class read {

        read() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, long _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(read.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, long _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *)
     * }
     */
    public static final AddressLayout read$layout() {
        return read$LAYOUT;
    }

    private static final long read$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *)
     * }
     */
    public static final long read$offset() {
        return read$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *)
     * }
     */
    public static MemorySegment read(MemorySegment struct) {
        return struct.get(read$LAYOUT, read$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*read)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, void *)
     * }
     */
    public static void read(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read$LAYOUT, read$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *)
     * }
     */
    public static class write {

        write() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, long _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(write.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(write.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, long _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout write$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("write"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *)
     * }
     */
    public static final AddressLayout write$layout() {
        return write$LAYOUT;
    }

    private static final long write$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *)
     * }
     */
    public static final long write$offset() {
        return write$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *)
     * }
     */
    public static MemorySegment write(MemorySegment struct) {
        return struct.get(write$LAYOUT, write$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*write)(H5FD_t *, H5FD_mem_t, hid_t, haddr_t, size_t, const void *)
     * }
     */
    public static void write(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(write$LAYOUT, write$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static class read_vector {

        read_vector() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(read_vector.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_vector.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_vector$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_vector"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static final AddressLayout read_vector$layout() {
        return read_vector$LAYOUT;
    }

    private static final long read_vector$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static final long read_vector$offset() {
        return read_vector$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static MemorySegment read_vector(MemorySegment struct) {
        return struct.get(read_vector$LAYOUT, read_vector$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*read_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static void read_vector(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_vector$LAYOUT, read_vector$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static class write_vector {

        write_vector() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(write_vector.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(write_vector.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout write_vector$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("write_vector"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static final AddressLayout write_vector$layout() {
        return write_vector$LAYOUT;
    }

    private static final long write_vector$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static final long write_vector$offset() {
        return write_vector$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static MemorySegment write_vector(MemorySegment struct) {
        return struct.get(write_vector$LAYOUT, write_vector$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*write_vector)(H5FD_t *, hid_t, uint32_t, H5FD_mem_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static void write_vector(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(write_vector$LAYOUT, write_vector$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static class read_selection {

        read_selection() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(read_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static final AddressLayout read_selection$layout() {
        return read_selection$LAYOUT;
    }

    private static final long read_selection$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static final long read_selection$offset() {
        return read_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static MemorySegment read_selection(MemorySegment struct) {
        return struct.get(read_selection$LAYOUT, read_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*read_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, void **)
     * }
     */
    public static void read_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_selection$LAYOUT, read_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static class write_selection {

        write_selection() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_INT,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(write_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(write_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout write_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("write_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static final AddressLayout write_selection$layout() {
        return write_selection$LAYOUT;
    }

    private static final long write_selection$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static final long write_selection$offset() {
        return write_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static MemorySegment write_selection(MemorySegment struct) {
        return struct.get(write_selection$LAYOUT, write_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*write_selection)(H5FD_t *, H5FD_mem_t, hid_t, size_t, hid_t *, hid_t *, haddr_t *, size_t *, const void **)
     * }
     */
    public static void write_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(write_selection$LAYOUT, write_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*flush)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static class flush {

        flush() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, boolean _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(flush.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(flush.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, boolean _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout flush$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flush"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*flush)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static final AddressLayout flush$layout() {
        return flush$LAYOUT;
    }

    private static final long flush$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*flush)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static final long flush$offset() {
        return flush$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*flush)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static MemorySegment flush(MemorySegment struct) {
        return struct.get(flush$LAYOUT, flush$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*flush)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static void flush(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(flush$LAYOUT, flush$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*truncate)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static class truncate {

        truncate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, boolean _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(truncate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(truncate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, boolean _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout truncate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("truncate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*truncate)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static final AddressLayout truncate$layout() {
        return truncate$LAYOUT;
    }

    private static final long truncate$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*truncate)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static final long truncate$offset() {
        return truncate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*truncate)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static MemorySegment truncate(MemorySegment struct) {
        return struct.get(truncate$LAYOUT, truncate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*truncate)(H5FD_t *, hid_t, hbool_t)
     * }
     */
    public static void truncate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(truncate$LAYOUT, truncate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*lock)(H5FD_t *, hbool_t)
     * }
     */
    public static class lock {

        lock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, boolean _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(lock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(lock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout lock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*lock)(H5FD_t *, hbool_t)
     * }
     */
    public static final AddressLayout lock$layout() {
        return lock$LAYOUT;
    }

    private static final long lock$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*lock)(H5FD_t *, hbool_t)
     * }
     */
    public static final long lock$offset() {
        return lock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*lock)(H5FD_t *, hbool_t)
     * }
     */
    public static MemorySegment lock(MemorySegment struct) {
        return struct.get(lock$LAYOUT, lock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*lock)(H5FD_t *, hbool_t)
     * }
     */
    public static void lock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lock$LAYOUT, lock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*unlock)(H5FD_t *)
     * }
     */
    public static class unlock {

        unlock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(unlock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unlock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unlock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unlock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*unlock)(H5FD_t *)
     * }
     */
    public static final AddressLayout unlock$layout() {
        return unlock$LAYOUT;
    }

    private static final long unlock$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*unlock)(H5FD_t *)
     * }
     */
    public static final long unlock$offset() {
        return unlock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*unlock)(H5FD_t *)
     * }
     */
    public static MemorySegment unlock(MemorySegment struct) {
        return struct.get(unlock$LAYOUT, unlock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*unlock)(H5FD_t *)
     * }
     */
    public static void unlock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unlock$LAYOUT, unlock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*del)(const char *, hid_t)
     * }
     */
    public static class del {

        del() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(del.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(del.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout del$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("del"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*del)(const char *, hid_t)
     * }
     */
    public static final AddressLayout del$layout() {
        return del$LAYOUT;
    }

    private static final long del$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*del)(const char *, hid_t)
     * }
     */
    public static final long del$offset() {
        return del$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*del)(const char *, hid_t)
     * }
     */
    public static MemorySegment del(MemorySegment struct) {
        return struct.get(del$LAYOUT, del$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*del)(const char *, hid_t)
     * }
     */
    public static void del(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(del$LAYOUT, del$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **)
     * }
     */
    public static class ctl {

        ctl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            hdf5_h.C_INT,
            hdf5_h.C_POINTER,
            hdf5_h.C_LONG,
            hdf5_h.C_LONG,
            hdf5_h.C_POINTER,
            hdf5_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = hdf5_h.upcallHandle(ctl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ctl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ctl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ctl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **)
     * }
     */
    public static final AddressLayout ctl$layout() {
        return ctl$LAYOUT;
    }

    private static final long ctl$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **)
     * }
     */
    public static final long ctl$offset() {
        return ctl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **)
     * }
     */
    public static MemorySegment ctl(MemorySegment struct) {
        return struct.get(ctl$LAYOUT, ctl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * herr_t (*ctl)(H5FD_t *, uint64_t, uint64_t, const void *, void **)
     * }
     */
    public static void ctl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ctl$LAYOUT, ctl$OFFSET, fieldValue);
    }

    private static final SequenceLayout fl_map$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("fl_map"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static final SequenceLayout fl_map$layout() {
        return fl_map$LAYOUT;
    }

    private static final long fl_map$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static final long fl_map$offset() {
        return fl_map$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static MemorySegment fl_map(MemorySegment struct) {
        return struct.asSlice(fl_map$OFFSET, fl_map$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static void fl_map(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, fl_map$OFFSET, fl_map$LAYOUT.byteSize());
    }

    private static long[] fl_map$DIMS = { 7 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static long[] fl_map$dimensions() {
        return fl_map$DIMS;
    }
    private static final VarHandle fl_map$ELEM_HANDLE = fl_map$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static int fl_map(MemorySegment struct, long index0) {
        return (int)fl_map$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * H5FD_mem_t fl_map[7]
     * }
     */
    public static void fl_map(MemorySegment struct, long index0, int fieldValue) {
        fl_map$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

