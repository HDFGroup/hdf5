<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<head>

<title>HDF5 User's Guide: Datatypes</title>

<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->


<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head>

<body>

<!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Datatypes" -->

<!--( TOC )=========================================================-->
<SCRIPT language="JavaScript">
<!--
document.writeln ('\
<table x-use-null-cells\
                 align=right\
		width=240\
		cellspacing=0\
		class="tocTable">\
   <tr valign=top> \
     <td class="tocTableHeaderCell" colspan="2"> \
         <span class=TableHead>Chapter Contents</span></td>\
   </tr>\
<!-- Table Version 3 -->\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#Intro">1.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#DtypesUsed">2.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#DtypesUsed">How Datatypes Are Used</a></td>\
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#FileFunctSums">3.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#FileFunctSums">Datatype (H5T) Function Summaries</a></td> \
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#Pmodel">4.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#Pmodel">The Programming Model</a></td>\
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#NonNumDtypes">5.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#NonNumDtypes">Other Non-numeric Datatypes</a></td> \
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#Fvalues">6.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#Fvalues">Fill Values</a></td>\
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#CCDtypes">7.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#CCDtypes">Complex Combinations of Datatypes</a>\
	  </td>\
   </tr>\
   <tr valign=top> \
     <td class="tocTableContentCell2"> \
       <a href="#LCDtypeObj">8.</a></td>\
     <td class="tocTableContentCell3">\
	  <a href="#LCDtypeObj">Life Cycle of the Datatype Object</a>\
	  </td>\
   </tr>\
\
   <tr valign=top> \
     <td class="tocTableContentCell"> \
<!-- editingComment -- "tocTableContentCell" and "tocTableContentCell4" \
-->\
<!-- are the table-closing cell class.\
     <td class="tocTableContentCell2"> \
-->\
       <a href="#Dtransfer">9.</a></td>\
     <td class="tocTableContentCell4">\
	  <a href="#Dtransfer">Data Transfer: Datatype Conversion and 
Selection</a>\
   </td></tr>\
</table>\
')
-->
</SCRIPT>
<!--(End TOC)=======================================================-->

<dir>
<!-- editingComment
   <span class="editingComment">[ [ [
   ] ] ]</span>
-->
</dir>


<div align="center">
<a name="TOP">
<h2>Chapter 6<br><font size="7">HDF5 Datatypes</font></h2>
</a>
</div>


<a name="Intro">
<h3>1. Introduction</h3>
</a>


<h4>1.1 Introduction and Definitions</h4>

   <p>An HDF5 dataset is an array of data elements, arranged according to the
   specifications of the dataspace.  In general, a data element is the smallest
   addressable unit of storage in the HDF5 file. (Compound datatypes are the
   exception to this rule.) The HDF5 datatype defines the storage format for a
   single data element (Figure 1).

   <p>The model for HDF5 attributes is extremely similar to datasets:
   an attribute has a dataspace and a datatype, as shown in Figure 1.
   The information in this chapter applies to both datasets and attributes.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell" align="center">
<img src="Images/Dtypes_fig1.JPG">
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 1</span>
</td></tr>
</table>

   <p>Abstractly, each data element within the dataset is a sequence of bits,
   interpreted as a single value from a set of values (e.g., a number 
   or a character).
   For a given data type, there is a standard or convention for representing 
   the values as bits, and when the bits are represented in a particular 
   storage the bits are laid out in a specific storage scheme, 
   e.g., as 8-bit bytes, with a specific ordering and alignment of bytes 
   within the storage array.

   <p>HDF5 datatypes implement a flexible, extensible, and portable mechanism
   for specifying and discovering the storage layout of the data elements,
   determining how to interpret the elements (e.g., as floating point numbers),
   and for transferring data from different compatible layouts.

<!-- NEW PAGE -->
   <p>An HDF5 datatype describes one specific layout of bits, a dataset 
   has a single datatype which applies to every data element. 
   When a dataset is created, the storage datatype is defined, 
   the datatype cannot be changed.</p>

<ul>
     <li>The datatype describes the storage layout of a single data element.
     <li>All elements of the dataset must have the same type.
     <li>The datatype of a dataset is immutable.
</ul>

   <p>When data is transferred (e.g., a read or write), each end point 
   of the transfer has a datatype, which describes the correct storage 
   for the elements.
   The source and destination may have different (but compatible) 
   layouts, in which case the data elements are automatically 
   transformed during the transfer.

   <p>HDF5 datatypes describe commonly used binary formats for numbers 
   (integers and floating point) and characters (ASCII). A given computing 
   architecture and programming language supports certain number and 
   character representations.
   For example, a computer may support 8-, 16-, 32-, and 64-bit signed 
   integers, stored in memory in little-endian byte order. These would 
   presumably correspond to the C programming language types 'char', 
   'short', 'int', and 'long'.

   <p>When reading and writing from memory, the HDF5 library must know the
   appropriate datatype that describes the architecture specific layout.
   The HDF5 library provides the platform independent 'NATIVE' types, which
   are mapped to an appropriate datatype for each platform. So the type
   'H5T_NATIVE_INT' is an alias for the appropriate descriptor for each
   platform.

   <p>Data in memory has a datatype

<ul>
     <li>The storage layout in memory is architecture-specific.
     <li>The HDF5 'NATIVE' types are predefined aliases for the
         architecture-specific memory layout.
     <li>The memory datatype need not be the same as the stored datatype 
         of the dataset.
</ul>

   <p>In addition to numbers and characters, an HDF5 datatype can describe 
   more abstract classes of types, including date-times, enumerations, 
   strings, bit strings, and references (pointers to objects in the 
   HDF5 file).
   HDF5 supports several classes of composite datatypes, which are compose
   one or more other datatypes. In addition to the standard predefined 
   datatypes, users can define new datatypes within the datatype classes.

   <p>The HDF5 datatype model is very general and flexible

<ul>
     <li>For common simple purposes, only predefined types will be needed
     <li>Datatypes can be composed to create complex structured datatypes.
     <li>If needed, users can define custom atomic datatypes.
</ul>

<!-- NEW PAGE -->
<h4>1.2 HDF5 Datatype Model</h4>

   <p>The HDF5 Library implements an object-oriented model of datatypes.
   HDF5 datatypes are organized as a logical set of base types, or 
datatype classes.
   Each datatype class defines a format for representing logical values as a
   sequence of bits. For example the H5T_CLASS_INT is a format for representing
   twos complement integers of various sizes.

   <p>A datatype class is defined as a set of one or more datatype properties.
   A datatype property is a property of the bit string. The datatype properties
   are defined by the logical model of the datatype class.  For example, the
   integer class (twos complement integers) has properties such as "signed or
   unsigned", "length", and "byte-order". The float class (IEEE floating point
   numbers) has these properties, plus "exponent bits", "exponent sign", etc.

   <p>A datatype is derived from one datatype class: a given datatype 
has a specific
   value for the datatype properties defined by the class.  For 
example, for 32-bit
   signed integers, stored big-endian, the HDF5 datatype is a sub-type 
of integer,
   with the properties set to: signed=1, size=4 (bytes), byte-order=BE.

   <p>The HDF5 datatype API provides methods to create datatypes of different
   datatype classes, to set the datatype properties of a new datatype, and to
   discover the datatype properties of an existing datatype.

   <p>The datatype for a dataset is stored in the HDF5 file as part of 
the metadata
   for the dataset.  A datatype can be shared by more than one dataset
<!-- editingComment
   <span class="editingComment">[ [ [
   (Attribute?)
   ] ] ]</span>
-->
   in the file. A datatype can optionally be stored as a named object 
in the file.

   <p>When transferring data (e.g., a read or write), the data elements of the
   source and destination storage must have compatible types.  As a 
general rule,
   data elements with the same datatype class are compatible, while 
elements from
   different datatype classes are not compatible. When transferring data of one
   datatype to another compatible datatype, the HDF5 Library uses the datatype
   properties of the source and destination to automatically transform each data
   element.  For example, when reading from data stored as 32-bit, 
signed integers,
   big-endian, into 32-bit signed integers, little-endian, the HDF5 Library will
   automatically swap the bytes.

   <p>Thus, data transfer operations (H5Dread, H5Dwrite, H5Aread, 
H5Awrite) require
   a datatype for both the source and the destination.</p>

<table x-use-null-cells
		width=616
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td width="612" align="center" class="fullImgTableImgCell">
<img src="Images/Dtypes_fig2.JPG">
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 2</span>
</td></tr>
</table>

<!-- NEW PAGE -->
   <p>The HDF5 Library defines a set of predefined datatypes, corresponding to
   commonly used storage formats, such as twos complement integers, 
IEEE Floating
   point numbers, etc., 4- and 8-byte sizes, big endian and little 
endian byte orders.
   In addition, a user can derive types with custom values for the properties.
   For example, a user program may create a datatype to describe a 
6-bit integer,
   or a 600-bit floating point number.

   <p>In addition to atomic datatypes, the HDF5 Library supports
   composite datatypes.
   A composite datatype is an aggregation of one or more datatypes.
   Each class of composite datatypes has properties that describe the
   organization of the composite datatype (Figure 3).
   Composite datatypes include:

<ul>
     <li>Compound datatypes: structured records
     <li>Array: a multidimensional array of a datatype
     <li>Variable length: a one-dimensional array of a datatype
</ul>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell" align="center">
<img src="Images/Dtypes_fig3.JPG">
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 3</span>
</td></tr>
</table>

<!-- NEW PAGE -->
<h4><em>1.2.1 Datatype Classes and Properties</em></h4>

   <p>Figure 4 shows the HDF5 datatype classes. Each class is defined to have a
   set of properties which describe layout of the data element and the
   interpretation of the bits. Table 1 lists the properties for the
   datatype classes.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell" align="center">
<img src="Images/Dtypes_fig4.JPG">
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 4</span>
</td></tr>
</table>

<br>
<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		width=640
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="4" align="center"><h4>Table 1. Datatype Classes and their
         properties.</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="24%">
         <p><span class=TableHead>Class</span></td>
     <td class="ColumnHdr" width="24%">
         <p><span class=TableHead>Description</span></td>
     <td class="ColumnHdr" width="27%">
         <p><span class=TableHead>Properties</span></td>
     <td class="ColumnRightHdr" width="25%">
         <p><span class=TableHead>Notes</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Integer</td>
     <td class="ColumnCell"> <p>Twos complement integers</td>
     <td class="ColumnCell"> <p>Size (bytes), precision (bits), offset (bits),
         pad, byte order, signed/unsigned</td>
     <td class="ColumnRightCell"> <p>&nbsp;</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Float</td>
     <td class="ColumnCell"> <p>Floating Point numbers</td>
     <td class="ColumnCell">
         <p>Size (bytes), precision (bits), offset (bits),
         pad, byte order, sign position, exponent position, exponent 
size (bits),
         exponent sign, exponent bias, mantissa position, mantissa (size) bits,
         mantissa sign, mantissa normalization, internal padding</td>
     <td class="ColumnRightCell">
         <p>See IEEE 754 for a definition of these properties.
         These properties describe non-IEEE 754 floating point formats as well.
     </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Character</td>
     <td class="ColumnCell"> <p>Array of 1-byte character encoding
<!-- editingComment
   <span class="editingComment">[ [ [
     (Verify?)
   ] ] ]</span>
-->
     </td>
     <td class="ColumnCell"> <p>Size (characters), Character set, byte 
order, pad/no
         pad, pad character</td>
     <td class="ColumnRightCell"> <p>Currently, only ASCII is supported.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Date and Time</td>
     <td class="ColumnCell"> <p>Date/time string</td>
     <td class="ColumnCell"> <p>Size (bytes), precision (bits), offset (bits),
         pad, byte order, </td>
     <td class="ColumnRightCell"> <p>ISO-8601 Date/time string</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Bitfield</td>
     <td class="ColumnCell"> <p>String of bits</td>
     <td class="ColumnCell"> <p>Size (bytes), precision (bits), offset (bits),
         pad, byte order
<!-- editingComment
   <span class="editingComment">[ [ [
	Complete?  Verify?
   ] ] ]</span>
-->
	</td>
     <td class="ColumnRightCell"> <p>When stored, are packed into bytes
<!-- editingComment
   <span class="editingComment">[ [ [
     Verify??
   ] ] ]</span>
-->
     </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Opaque</td>
     <td class="ColumnCell"> <p>Uninterpreted data</td>
     <td class="ColumnCell"> <p>Size (bytes), precision (bits), offset (bits),
         pad, byte order, tag</td>
     <td class="ColumnRightCell"> <p>A sequence of bytes, stored and retrieved
         as a block. The &lsquo;tag&rsquo; is a string that can be used to label
         the value.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Enumeration</td>
     <td class="ColumnCell"> <p>A list of discrete values, with symbolic names
         in the form of strings.
     </td>
     <td class="ColumnCell"> <p>Number of elements, element names, 
element values
<!-- editingComment
   <span class="editingComment">[ [ [
     Verify?
   ] ] ]</span>
-->
     </td>
     <td class="ColumnRightCell"> <p>Enumeration is a list of pairs, 
(name, value).
         The name is a string, the value is an unsigned integer.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Reference</td>
     <td class="ColumnCell">
         <p>Reference to object or region within the HDF5 file</td>
     <td class="ColumnCell">
     &nbsp;
<!-- editingComment
   <span class="editingComment">[ [ [
     <p>Size (bytes)?, byte order?
   ] ] ]</span>
-->
     </td>
     <td class="ColumnRightCell"> <p>See the Reference API, H5R</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Array</td>
     <td class="ColumnCell"> <p>Array (1-4 dimensions) of data elements</td>
     <td class="ColumnCell">
         <p>Number of dimensions, dimension sizes, base datatype</td>
     <td class="ColumnRightCell"> <p>The array is accessed atomically: 
no selection
         or subsetting.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Variable length</td>
     <td class="ColumnCell"> <p>A variable length 1-dimensional array 
of data data
         elements
     </td>
     <td class="ColumnCell"> <p>Current size, base type</td>
     <td class="ColumnRightCell"> <p>&nbsp;</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>Compound</td>
     <td class="ColumnBottom">
         <p>A Datatype composed of a sequence of Datatypes</td>
     <td class="ColumnBottom"> <p>Number of members, member names, member types,
         member offset, member class, member size, byte order </td>
     <td class="ColumnRightBottom"> <p>&nbsp;</td>
   </tr>
</table>

<!-- editingComment
   <span class="editingComment">[ [ [
   <p><em>{Need summary of Composite DT and props.]</em>

   <p><em>{Need table/index of all properties, classes, definitions 
and API}</em>
   ] ] ]</span>
-->

<h4><em>1.2.2 Predefined Datatypes</em></h4>

   <p>The HDF5 library predefines a modest number of commonly used datatypes.
   These types have standard symbolic names of the form
   <code>H5T_<em>arch_base</em></code> where <em>arch</em> is an architecture
   name and <em>base</em> is a programming type name (Table 2). New types can
   be derived from the predefined types by copying the predefined type (see
   <code>H5Tcopy()</code>) and then modifying the result.

   <p>The base name of most types consists of a letter to indicate the class
   (Table 3), a precision in bits, and an indication of the byte order 
(Table 4).

   <p>Table 5 shows examples of predefined datatypes.
   The full list can be found  in the "HDF5 Predefined Datatypes" section
   of the <cite>HDF5 Reference Manual</cite>.
<!-- editingComment
   <span class="editingComment">[ [ [
   Link to ../PredefDTypes.html
   ] ] ]</span>
-->

<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 2</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="25%">
         <p><span class=TableHead>Architecture Name</span></td>
     <td class="ColumnRightHdr" width="75%">
         <p><span class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>IEEE</code> </td>
     <td class="ColumnRightCell"> <p>IEEE-754 standard floating point types in
         various byte orders.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>STD</code> </td>
     <td class="ColumnRightCell">
         <p>This is an architecture that contains semi-standard
         datatypes like signed two's complement integers, unsigned integers, and
         bitfields in various byte orders.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>UNIX</code> </td>
     <td class="ColumnRightCell">
         <p>Types which are specific to Unix operating systems
         are defined in this architecture. The only type currently 
defined is the
	Unix date and time types (<code>time_t</code>).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>C <br> FORTRAN</code> </td>
     <td class="ColumnRightCell"> <p>Types which are specific to the C 
or Fortran
         programming languages are defined in these architectures. For instance,
	<code>H5T_C_STRING</code> defines a base string type with 
null termination
	which can be used to derive string types of other lengths.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>NATIVE</code> </td>
     <td class="ColumnRightCell"> <p>This architecture contains C-like 
datatypes for
         the machine on which the library was compiled. The types were actually
	defined by running the <code>H5detect</code> program when the 
library was
	compiled. In order to be portable, applications should almost 
always use
	this architecture to describe things in memory.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>CRAY</code> </td>
     <td class="ColumnRightCell"> <p>Cray architectures. These are 
word-addressable,
         big-endian systems with non-IEEE floating point.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>INTEL</code> </td>
     <td class="ColumnRightCell"> <p>All Intel and compatible CPU's 
including 80286,
         80386, 80486, Pentium, Pentium-Pro, and Pentium-II. These are 
little-endian
	systems with IEEE floating-point.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>MIPS</code> </td>
     <td class="ColumnRightCell"> <p>All MIPS CPU's commonly used in 
SGI systems.
         These are big-endian systems with IEEE floating-point.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>ALPHA</code> </td>
     <td class="ColumnRightBottom"> <p>All DEC Alpha CPU's, 
little-endian systems with
         IEEE floating-point.</td>
   </tr>
</table>

<br><br>

<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		cellspacing=0
		align="center"
	        width=200>
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 3</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"
         width="50"
         style="border-left-width: 1px;
		      border-top-style: Solid;
		      border-top-color: #008000;
		      border-top-width: 3px;
		      border-left-width: 1px;
		      border-left-color: #008000;
		      border-left-style: Solid;
		      border-bottom-style: Solid;
		      border-bottom-width: 1px;
		      border-bottom-color: #008000;
		      padding-right: 10px;
		      padding-left: 10px;">
         <p>&nbsp;</td>
     <td class="ColumnRightCell"
         width="150"
         style="border-top-style: Solid;
		      border-top-color: #008000;
		      border-top-width: 3px;
		      border-left-width: 1px;
		      border-left-color: #008000;
		      border-left-style: Solid;
		      border-right-width: 1px;
		      border-right-color: #008000;
		      border-right-style: Solid;
		      border-bottom-style: Solid;
		      border-bottom-width: 1px;
		      border-bottom-color: #008000;
		      padding-right: 10px;
		      padding-left: 10px;">
         <p>Bitfield</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>D</td>
     <td class="ColumnRightCell"> <p>Date and time</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>F</td>
     <td class="ColumnRightCell"> <p>Floating point</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>I</td>
     <td class="ColumnRightCell"> <p>Signed integer</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>R</td>
     <td class="ColumnRightCell"> <p>References</td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>S</td>
     <td class="ColumnRightCell"> <p>Character string</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>U</td>
     <td class="ColumnRightBottom"> <p>Unsigned integer</td>
   </tr>
</table>

<br><br>

<table x-use-null-cells
		class="ColumnTable"
		cellspacing=0
		align="center"
	        width=200>
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 4</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"
         width="50"
         style="border-left-width: 1px;
		      border-top-style: Solid;
		      border-top-color: #008000;
		      border-top-width: 3px;
		      border-left-width: 1px;
		      border-left-color: #008000;
		      border-left-style: Solid;
		      border-bottom-style: Solid;
		      border-bottom-width: 1px;
		      border-bottom-color: #008000;
		      padding-right: 10px;
		      padding-left: 10px;">
         <p>BE</td>
     <td class="ColumnRightCell"
         width="150"
         style="border-top-style: Solid;
		      border-top-color: #008000;
		      border-top-width: 3px;
		      border-left-width: 1px;
		      border-left-color: #008000;
		      border-left-style: Solid;
		      border-right-width: 1px;
		      border-right-color: #008000;
		      border-right-style: Solid;
		      border-bottom-style: Solid;
		      border-bottom-width: 1px;
		      border-bottom-color: #008000;
		      padding-right: 10px;
		      padding-left: 10px;">
         <p>Big endian</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>LE</td>
     <td class="ColumnRightCell"> <p>Little endian</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>VX</td>
     <td class="ColumnRightBottom"> <p>Vax order</td>
   </tr>
</table>

<br><br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 5</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="25%">
         <p><span class=TableHead>Example</span></td>
     <td class="ColumnRightHdr" width="75%">
         <p><span class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_IEEE_F64LE</code> </td>
     <td class="ColumnRightCell">
         <p>Eight-byte, little-endian, IEEE floating-point</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_IEEE_F32BE</code> </td>
     <td class="ColumnRightCell">
         <p>Four-byte, big-endian, IEEE floating point</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_STD_I32LE</code> </td>
     <td class="ColumnRightCell">
         <p>Four-byte, little-endian, signed two's complement
         integer</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_STD_U16BE</code> </td>
     <td class="ColumnRightCell">
         <p>Two-byte, big-endian, unsigned integer</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_UNIX_D32LE</code> </td>
     <td class="ColumnRightCell"> <p>Four-byte, little-endian, time_t</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_C_S1</code> </td>
     <td class="ColumnRightCell">
         <p>One-byte, null-terminated string of eight-bit
         characters</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_INTEL_B64</code> </td>
     <td class="ColumnRightCell"> <p>Eight-byte bit field on an Intel CPU</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_CRAY_F64</code> </td>
     <td class="ColumnRightCell"> <p>Eight-byte Cray floating point</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5T_STD_ROBJ</code> </td>
     <td class="ColumnRightBottom">
         <p>Reference to an entire object in a file</td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
   <p>The HDF5 Library predefines a set of <code>NATIVE</code> datatypes which
   are similar to C type names. The native types are set to be an alias for the
   appropriate HDF5 datatype for each platform. For example, 
<code>H5T_NATIVE_INT
   corresponds to a C int type. On an Intel based PC, this type is the same as
   H5T_STD_32LE, while on a MIPS system this would be equivalent to
   H5T_STD_32BE</code>. Table 6 shows examples of NATIVE types and corresponding
   C types for a common 32-bit workstation.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 6</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr">
         <p><span class=TableHead>Example</span></td>
     <td class="ColumnRightHdr">
         <p><span class=TableHead>Corresponding C Type</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_CHAR</code> </td>
     <td class="ColumnRightCell">
         <p>char</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_SCHAR</code> </td>
     <td class="ColumnRightCell">
         <p>signed char</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_UCHAR</code> </td>
     <td class="ColumnRightCell">
         <p>unsigned char</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_SHORT</code> </td>
     <td class="ColumnRightCell">
         <p>short</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_USHORT</code> </td>
     <td class="ColumnRightCell"> <p>unsigned short</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_INT</code> </td>
     <td class="ColumnRightCell">
         <p>int</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_UINT</code> </td>
     <td class="ColumnRightCell">
         <p>unsigned</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_LONG</code> </td>
     <td class="ColumnRightCell">
         <p>long</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_ULONG</code> </td>
     <td class="ColumnRightCell">
         <p>unsigned long</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_LLONG</code> </td>
     <td class="ColumnRightCell">
         <p>long long</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_ULLONG</code> </td>
     <td class="ColumnRightCell">
         <p>unsigned long long</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_FLOAT</code> </td>
     <td class="ColumnRightCell">
         <p>float</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_DOUBLE</code> </td>
     <td class="ColumnRightCell">
         <p>double</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_LDOUBLE</code> </td>
     <td class="ColumnRightCell">
         <p>long double</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_HSIZE</code> </td>
     <td class="ColumnRightCell">
         <p>hsize_t</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_HSSIZE</code> </td>
     <td class="ColumnRightCell"> <p>hssize_t</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_NATIVE_HERR</code> </td>
     <td class="ColumnRightCell"> <p>herr_t</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5T_NATIVE_HBOOL</code> </td>
     <td class="ColumnRightBottom">
         <p>hbool_t</td>
   </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="DtypesUsed">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="DtypesUsed">
<h3 class=pagebefore>2. How Datatypes Are Used</h3>
</a>

<h4>2.1 The Datatype object and the HDF5 Datatype API</h4>

   <p>The HDF5 Library manages datatypes as objects. The HDF5 datatype API
   manipulates the datatype objects through C function calls.  New datatypes
   can be created from scratch or copied from existing datatypes. When a
   datatype is no longer needed its resources should be released by calling
   <code>H5Tclose()</code>.

   <p>The datatype object is used in several roles in the HDF5 model 
and library.
   Essentially, a datatype is used whenever the format of data 
elements is needed.
   There are four major uses of datatypes in the HDF5 library: at 
dataset creation,
   during data transfers, when discovering the contents of a file, and for
   specifying user defined data types (Table 7).</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 7</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr">
         <p><span class=TableHead>Use</span></td>
     <td class="ColumnRightHdr">
         <p><span class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Dataset creation</td>
     <td class="ColumnRightCell"> <p>The datatype of the data elements must be
         declared when the dataset is created.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Data transfer</td>
     <td class="ColumnRightCell"> <p>The datatype (format) of the data elements
         must be defined for both the source and destination.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Discovery</td>
     <td class="ColumnRightCell"> <p>The datatype of a dataset can be 
interrogated
         to retrieve a complete description of the storage layout.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>Creating User defined Datatypes</td>
     <td class="ColumnRightBottom"> <p>Users can define their own datatypes by
         creating datatype objects and setting its properties.</td>
   </tr>
</table>

<h4>2.2 Dataset creation</h4>

   <p>All the data elements of a dataset have the same datatype. When a dataset
   is created (<code>H5Tcreate</code>), the datatype for the data elements must
   be specified. The datatype of a dataset can never be changed. Figure 5 shows
   the use of a datatype to create a dataset called "/dset".  In this example,
   the dataset will be stored as 32-bit signed integers, in big endian 
order.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell">
<pre><code>
   hid_t dt;
   dt = H5Tcopy(H5T_STD_I32BE);
   dataset_id = H5Dcreate(file_id, "/dset", dt, dataspace_id,
       H5P_DEFAULT);
</code></pre>
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 5</span>
</td></tr>
</table>

<h4>2.3 Data transfer (Read and Write)</h4>

   <p>Probably the most common use of datatypes is to write or read data from a
   dataset or attribute. In these operations, each data element is transferred
   from the source to the destination (possibly rearranging the order of the
   elements). Since the source and destination do not need to be identical
   (i.e., one is disk and the other is memory) the transfer requires both the
   format of the source element and the destination element. Therefore, data
   transfers use two datatype objects, for the source and destination.

   <p>When data is written, the source is memory and the destination is disk
   (file). The memory datatype describes the format of the data element in the
   machine memory, and the file datatype describes the desired format 
of the data
   element on disk. Similarly, when reading, the source datatype describes the
   format of the data element on disk, and the destination datatype 
describes the
   format in memory.

<!-- NEW PAGE -->
   <p>In the most common cases, the file datatype is the datatype specified
   when the dataset was created, and the memory datatype should be the
   appropriate NATIVE type.

   <p>Figures 5 and 6, respectively, show examples of writing data to and
   reading data from a dataset.
   The data in memory is declared C type 'int', the datatype H5T_NATIVE_INT
   corresponds to this type. The datatype of the dataset should be of datatype
   class INTEGER.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell">
<pre><code>
    int  dset_data[DATA_SIZE];

    status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
          H5P_DEFAULT, dset_data);
</code></pre>
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 6</span>
</td></tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell">
<pre><code>
  int dset_data[DATA_SIZE];

   status = H5Dread(dataset_id, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
       H5P_DEFAULT,  dset_data);
</code></pre>
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 7</span>
</td></tr>
</table>

<h4>2.4 Discovery of data format</h4>

   <p>The HDF5 Library enables a program to determine the datatype class and
   properties for any data type. In order to discover the storage format of data
   in a dataset, the datatype is obtained, and the properties 
determined by queries
   to the datatype object. Figure 8 shows an example of code that analyzes the
   datatype for an integer, and prints out a description of its 
storage properties
   (byte Order, signed, size.)</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
		<tr valign=top>
<td class="fullImgTableImgCell">
<pre><code>
     switch (H5Tget_class(type)) {
     case H5T_INTEGER:
	ord = H5Tget_order(type);
	sgn = H5Tget_sign(type);
	printf("Integer ByteOrder= ");
	switch (ord) {
	case H5T_ORDER_LE:
	    printf("LE");
	    break;
	case H5T_ORDER_BE:
	    printf("BE");
	    break;
	}
	printf(" Sign= ");
	switch (sgn) {
	case H5T_SGN_NONE:
	    printf("false");
	    break;
	case H5T_SGN_2:
	    printf("true");
	    break;
	}
	printf(" Size= ");
	sz = H5Tget_size(type);
	printf("%d", sz);
	printf("\n");
	break;
</code></pre>
</td></tr>
<tr>
<td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 8</span>
</td></tr>
</table>

<h4>2.5 Creating and using user defined datatypes</h4>

   <p>Most programs will primarily use the predefined datatypes described above,
   possibly in composite datatypes such as compound or array datatypes.
   However, the HDF5 datatype model is extremely general; a user program can
   define a great variety of atomic datatypes (storage layouts). In particular,
   the datatype properties can define signed and unsigned integers of any size
   and byte order, and floating point numbers with different formats, size, and
   byte order. The HDF5 datatype API provides methods to set these properties.

   <p>User defined types can be used to define the layout of data in 
memory, e.g.,
   to match some platform specific number format or application 
defined bit-field.
   The user defined type can also describe data in the file, e.g., some
   application-defined format.  The user defined types can be translated to and
   from standard types of the same class, as described above.

<!-- editingComment
   <span class="editingComment">[ [ [
   <p><em>{Simple programming example…}</em>
   ] ] ]</span>
-->


<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="FileFunctSums">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="FileFunctSums">
<h3 class=pagebefore>3. Datatype (H5T) Function Summaries</h3>
</a>

<h4>3.1 General Datatype Operations</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tcreate<br>h5tcreate_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a new datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Topen<br>h5topen_f</code>
     </td>
     <td class="functTableCell">
	Opens a named datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tcommit<br>h5tcommit_f</code>
     </td>
     <td class="functTableCell">
	Commits a transient datatype to a file, creating a new named datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tcommitted<br>h5tcommitted_f</code>
     </td>
     <td class="functTableCell">
	Determines whether a datatype is a named type or a transient type.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tcopy<br>h5tcopy_f</code>
     </td>
     <td class="functTableCell">
	Copies an existing datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tequal<br>h5tequal_f</code>
     </td>
     <td class="functTableCell">
	Determines whether two datatype identifiers refer to the same datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tlock<br>(none)</code>
     </td>
     <td class="functTableCell">
	Locks a datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_class<br>h5tget_class_f</code>
     </td>
     <td class="functTableCell">
	Returns the datatype class identifier.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_size<br>h5tget_size_f</code>
     </td>
     <td class="functTableCell">
	Returns the size of a datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_super<br>h5tget_super_f</code>
     </td>
     <td class="functTableCell">
	Returns the base datatype from which a datatype is derived.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_native_type<br>(none)</code>
     </td>
     <td class="functTableCell">
	Returns the native datatype of a specified datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tdetect_class<br>(none)</code>
     </td>
     <td class="functTableCell">
	Determines whether a datatype is of the given datatype class.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tclose<br>h5tclose_f</code>
     </td>
     <td class="functTableBottom">
	Releases a datatype.
     </td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>3.2 Conversion Functions</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tconvert<br>(none)</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Converts data from between specified datatypes.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tfind<br>(none)</code>
     </td>
     <td class="functTableCell">
	Finds a conversion function.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_overflow<br>(none)</code>
     </td>
     <td class="functTableCell">
	Sets the overflow handler to a specified function.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_overflow<br>(none)</code>
     </td>
     <td class="functTableCell">
	Returns a pointer to the current global overflow function.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tregister<br>(none)</code>
     </td>
     <td class="functTableCell">
	Registers a conversion function.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tunregister<br>(none)</code>
     </td>
     <td class="functTableBottom">
	Removes a conversion function from all conversion paths.
     </td>
   </tr>
</table>

<br>
<h4>3.3 Atomic Datatype Properties</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tset_size<br>h5tset_size_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets the total size for an atomic datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_order<br>h5tget_order_f</code>
     </td>
     <td class="functTableCell">
	Returns the byte order of an atomic datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_order<br>h5tset_order_f</code>
     </td>
     <td class="functTableCell">
	Sets the byte ordering of an atomic datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_precision<br>h5tget_precision_f</code>
     </td>
     <td class="functTableCell">
	Returns the precision of an atomic datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_precision<br>h5tset_precision_f</code>
     </td>
     <td class="functTableCell">
	Sets the precision of an atomic datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_offset<br>h5tget_offset_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the bit offset of the first significant bit.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_offset<br>h5tset_offset_f</code>
     </td>
     <td class="functTableCell">
	Sets the bit offset of the first significant bit.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_pad<br>h5tget_pad_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the padding type of the least and most-significant 
bit padding.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_pad<br>h5tset_pad_f</code>
     </td>
     <td class="functTableCell">
	Sets the least and most-significant bits padding types.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_sign<br>h5tget_sign_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the sign type for an integer type.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_sign<br>h5tset_sign_f</code>
     </td>
     <td class="functTableCell">
	Sets the sign property for an integer type.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_fields<br>h5tget_fields_f</code>
     </td>
     <td class="functTableCell">
	Retrieves floating point datatype bit field information.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_fields<br>h5tset_fields_f</code>
     </td>
     <td class="functTableCell">
	Sets locations and sizes of floating point bit fields.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_ebias<br>h5tget_ebias_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the exponent bias of a floating-point type.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_ebias<br>h5tset_ebias_f</code>
     </td>
     <td class="functTableCell">
	Sets the exponent bias of a floating-point type.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_norm<br>h5tget_norm_f</code>
     </td>
     <td class="functTableCell">
	Retrieves mantissa normalization of a floating-point datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_norm<br>h5tset_norm_f</code>
     </td>
     <td class="functTableCell">
	Sets the mantissa normalization of a floating-point datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_inpad<br>h5tget_inpad_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the internal padding type for unused bits in 
floating-point datatypes.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_inpad<br>h5tset_inpad_f</code>
     </td>
     <td class="functTableCell">
	Fills unused internal floating point bits.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_cset<br>h5tget_cset_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the character set type of a string datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tset_cset<br>h5tset_cset_f</code>
     </td>
     <td class="functTableCell">
	Sets character set to be used.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_strpad<br>h5tget_strpad_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the storage mechanism for a string datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tset_strpad<br>h5tset_strpad_f</code>
     </td>
     <td class="functTableBottom">
	Defines the storage mechanism for character strings.
     </td>
   </tr>
</table>

<br>
<h4>3.4 Enumeration Datatypes</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tenum_create<br>h5tenum_create_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a new enumeration datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tenum_insert<br>h5tenum_insert_f</code>
     </td>
     <td class="functTableCell">
	Inserts a new enumeration datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tenum_nameof<br>h5tenum_nameof_f</code>
     </td>
     <td class="functTableCell">
	Returns the symbol name corresponding to a specified member 
of an enumeration datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tenum_valueof<br>h5tenum_valueof_f</code>
     </td>
     <td class="functTableCell">
	Returns the value corresponding to a specified member of an 
enumeration datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_value<br>h5tget_member_value_f</code>
     </td>
     <td class="functTableCell">
	Returns the value of an enumeration datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_nmembers<br>h5tget_nmembers_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the number of elements in a compound or enumeration datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_name<br>h5tget_member_name_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the name of a compound or enumeration datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tget_member_index<br>(none)</code>
     </td>
     <td class="functTableBottom">
	Retrieves the index of a compound or enumeration datatype member.
     </td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>3.5 Compound Datatype Properties</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tget_nmembers<br>h5tget_nmembers_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Retrieves the number of elements in a compound or enumeration datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_class<br>(none)</code>
     </td>
     <td class="functTableCell">
	Returns datatype class of compound datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_name<br>h5tget_member_name_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the name of a compound or enumeration datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_index<br>(none)</code>
     </td>
     <td class="functTableCell">
	Retrieves the index of a compound or enumeration datatype member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_offset<br>h5tget_member_offset_f</code>
     </td>
     <td class="functTableCell">
	Retrieves the offset of a field of a compound datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_member_type<br>h5tget_member_type_f</code>
     </td>
     <td class="functTableCell">
	Returns the datatype of the specified member.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tinsert<br>h5tinsert_f</code>
     </td>
     <td class="functTableCell">
	Adds a new member to a compound datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tpack<br>h5tpack_f</code>
     </td>
     <td class="functTableBottom">
	Recursively removes padding from within a compound datatype.
     </td>
   </tr>
</table>

<br>
<h4>3.6 Array Datatypes</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tarray_create<br>(none)</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates an array datatype object.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableCell">
	<code>H5Tget_array_ndims<br>(none)</code>
     </td>
     <td class="functTableCell">
	Returns the rank of an array datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tget_array_dims<br>(none)</code>
     </td>
     <td class="functTableBottom">
	Returns sizes of array dimensions and dimension permutations.
     </td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>3.7 Variable-length Datatypes</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tvlen_create<br>h5tvlen_create_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a new variable-length datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tis_variable_str<br>h5tis_variable_str_f</code>
     </td>
     <td class="functTableBottom">
	Determines whether datatype is a variable-length string.
     </td>
   </tr>
</table>

<br>
<h4>3.8 Opaque Datatypes</h4>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
   <tr valign=top>
     <td class="functTableLeftHdr">
         <span class=TableHead>C Function<br>F90 Function</span>
     </td>
     <td class="functTableRightHdr">
         <span class=TableHead>Purpose</span>
     </td>
   </tr>
   <tr valign=top>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Tset_tag<br>h5tset_tag_f</code>
     </td>
     <td colspan=1
	rowspan=1
	class="functTableCell">
	Tags an opaque datatype.
     </td>
   </tr>
   <tr valign=top>
     <td class="functTableBottom">
	<code>H5Tget_tag<br>h5tget_tag_f</code>
     </td>
     <td class="functTableBottom">
	Gets the tag associated with an opaque datatype.
     </td>
   </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Pmodel">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="Pmodel">
<h3 class=pagebefore>4. The Programming Model</h3>
</a>

<h4>4.1 Introduction</h4>

   <p>The HDF5 Library implements an object-oriented model of 
datatypes. HDF5 datatypes
   are organized as a logical set of base types, or datatype classes. The HDF5
   Library manages datatypes as objects. The HDF5 datatype API manipulates the
   datatype objects through C function calls. Figure 9 shows the abstract view
   of the datatype object. Table 8 shows the methods (C functions) that operate
   on datatype object as a whole. New datatypes can be created from scratch or
   copied from existing datatypes.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center"><br>

	  <table align="center" border="1">
	    <tr>
		  <td valign="middle" align="center"><code>Datatype</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="left">
		    <code>&nbsp;size:int?<br>
			&nbsp;byteOrder:BOtype</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="left">
		    <code>&nbsp;open(hid_t loc, char *, name):return hid_t<br>
			&nbsp;copy(hid_t tid) return hid_t<br>
 
	&nbsp;create(hid_class_t&nbsp;clss,&nbsp;size_t&nbsp;size)&nbsp;return&nbsp;hid_t&nbsp;</code>
		  </td>
		</tr>
       </table>&nbsp;
	  </td></tr>
		<tr>
           <td align=center class="fullImgTableCapCell">
           <span class=figurenumber>Figure 9. The datatype object</span></td>
		</tr>
	</table>
<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 8. 
General operations
         on datatype objects</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span 
class=TableHead>API function</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t H5Tcreate (H5T_class_t 
<em>class</em>,
         size_t <em>size</em>)</code></td>
     <td class="ColumnRightCell"> <p>Create a new datatype object of 
datatype class
         <em>class</em>. The following datatype classes are supported with this
         function:
       <ul>
         <li>H5T_COMPOUND
         <li>H5T_OPAQUE
         <li>H5T_ENUM
       </ul>
       Other datatypes are created with <code>H5Tcopy()</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t H5Tcopy (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>Obtain a modifiable transient 
datatype which
         is a copy of <em>type</em>. If <em>type</em> is a dataset 
identifier then
         the type returned is a modifiable transient copy of the datatype of the
         specified dataset. </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t H5Topen (hid_t 
<em>location</em>,
         const char *<em>name</em>)</code></td>
     <td class="ColumnRightCell"> <p>Open a named datatype. The named datatype
         returned by this function is read-only.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>htri_t H5Tequal (hid_t <em>type1</em>,
         hid_t <em>type2</em>)</code></td>
     <td class="ColumnRightCell"> <p>Determines if two types are equal. </td>
   </tr>
<!-- NEW PAGE -->
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tclose (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>Releases resources associated 
with a datatype
         obtained from H5Tcopy, H5Topen, or H5Tcreate. It is illegal to close an
         immutable transient datatype (e.g., predefined types).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tcommit (hid_t 
<em>location</em>,
         const char *<em>name</em>, hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>Commit a transient datatype (not immutable)
         a file to become a named datatype. Named datatypes can be shared.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>htri_t H5Tcommitted (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>Test whether the datatype is transient or
         commited (named).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>herr_t H5Tlock (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightBottom"> <p>Make a transient datatype 
immutable (read-only
         and not closable). Predefined types are locked.</td>
   </tr>
</table>
<br>

   <p>In order to use a datatype, the object must be created 
(<code>H5Tcreate</code>),
   or a reference obtained by cloning from an existing type 
(<code>H5Tcopy</code>),
   or opened (<code>H5Topen</code>). In addition, a reference to the datatype of
   a dataset or attribute can be obtained with 
<code>H5Dget_type</code> or <code>H5Aget_type</code>.
   For composite datatypes a reference to the datatype for members or base types
   can be obtained (<code>H5Tget_membertype</code>, <code>H5Tget_super</code>).
   When the datatype object is no longer needed, the reference is discarded with
   <code>H5Tclose</code>.

   <p>Two datatype objects can be tested to see if they are the same 
with <code>H5Tequal</code>.
   This function returns true if the two datatype references refer to the same
   datatype object. However, if two datatype objects define equivalent datatypes
   (the same datatype class and datatype properties), they will not be 
considered
   'equal'.

   <p>A datatype can be written to the file as a first class object 
(<code>H5Tcommit</code>).
   Named datatypes can be used in the same way as any other dataype. 
Named datatypes
   are explained below.
<!-- editingComment
   <span class="editingComment">[ [ [
   in section ??
   ] ] ]</span>
-->

<!-- NEW PAGE -->
<h4>4.2 Discovery of Datatype Properties</h4>

   <p>Any HDF5 datatype object can be queried to discover all of its 
datatype properties.
   For each datatype class, there are a set of API functions to 
retrieve the datatype
   properties for this class.

<h4>4.2.1 Properties of Atomic Datatypes</h4>

   <p>Table 9 lists the functions to discover the properties of atomic 
datatypes.
   Table 10 lists the queries relevant to specific numeric types. Table 11 gives
   the properties for atomic string datatype, and Table 12 gives the property of
   the opaque datatype.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 9</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Functions
         to Discover Properties of Atomic DataTypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_class_t H5Tget_class 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The datatype class: 
<code>H5T_INTEGER, H5T_FLOAT,
         H5T_TIME, H5T_STRING, or H5T_BITFIELD, H5T_OPAQUE, 
H5T_COMPOUND, H5T_REFERENCE,
         H5T_ENUM, H5T_VLEN, H5T_ARRAY</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>size_t H5Tget_size (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The total size of the element in 
bytes, including
         padding which may appear on either side of the actual value.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_order_t H5Tget_order 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The byte order describes how the bytes of
         the datatype are laid out in memory. If the lowest memory 
address contains
         the least significant byte of the datum then it is said to be 
<em>little-endian</em>
         or <code>H5T_ORDER_LE</code>. If the bytes are in the 
opposite order then
         they are said to be <em>big-endian</em> or 
<code>H5T_ORDER_BE.</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>size_t H5Tget_precision 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The <code>precision</code> 
property identifies
         the number of significant bits of a datatype and the 
<code>offset</code>
         property (defined below) identifies its location. Some datatypes occupy
         more bytes than what is needed to store the value. For 
instance, a <code>short</code>
         on a Cray is 32 significant bits in an eight-byte field.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>size_t H5Tget_offset (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The <code>offset</code> property 
defines the
         bit location of the least significant bit of a bit field whose length
         is <code>precision</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>herr_t H5Tget_pad (hid_t 
<em>type</em>,
         H5T_pad_t <em>*lsb</em>, H5T_pad_t <em>*msb</em>)</code></td>
     <td class="ColumnRightBottom"> <p>Padding is the bits of a data 
element which
         are not significant as defined by the <code>precision</code> 
and <code>offset</code>
         properties. Padding in the low-numbered bits is <em>lsb</em> 
padding and
         padding in the high-numbered bits is <em>msb</em> padding. Padding bits
         can be set to zero (<code>H5T_PAD_ZERO</code>) or one 
(<code>H5T_PAD_ONE</code>).</td>
   </tr>
</table>

<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 10</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Atomic Numeric Types</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_sign_t H5Tget_sign 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(INTEGER)</strong> Integer data can
         be signed two's complement (<code>H5T_SGN_2</code>) or 
unsigned (<code>H5T_SGN_NONE</code>).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tget_fields (hid_t 
<em>type</em>,
         size_t *<em>spos</em>, size_t *<em>epos</em>, size_t *<em>esize</em>,
         size_t *<em>mpos</em>, size_t *<em>msize</em>)</code> </td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> A floating-point
         data element has bit fields which are the exponent and mantissa as well
         as a mantissa sign bit. These properties define the location 
(bit position
         of least significant bit of the field) and size (in bits) of 
each field.
         The sign bit is always of length one and none of the fields are allowed
         to overlap.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>size_t H5Tget_ebias (hid_t 
<em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> The 
exponent is stored
         as a non-negative value which is <code>ebias</code> larger 
than the true
         exponent. </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_norm_t H5Tget_norm 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> This 
property describes
         the normalization method of the mantissa.
       <ul>
         <li><code>H5T_NORM_MSBSET</code>: the mantissa is shifted left (if non-zero) 

           until the first bit after the radix point is set and the exponent is
           adjusted accordingly. All bits of the mantissa after the radix point
           are stored.
         <li><code>H5T_NORM_IMPLIED</code>: the mantissa is shifted left \ (if
           non-zero) until the first bit after the radix point is set 
and the exponent
           is adjusted accordingly. The first bit after the radix point is not
           stored since it's always set.
         <li><code>H5T_NORM_NONE</code>: the fractional part of the mantissa is
           stored without normalizing it. </ul></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5T_pad_t H5Tget_inpad 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightBottom"> <p><strong>(FLOAT)</strong> If any internal
         bits (that is, bits between the sign bit, the mantissa field, and the
         exponent field but within the precision field) are unused, 
then they will
         be filled according to the value of this property. The padding can be:
         H5T_PAD_NONE, <code>H5T_PAD_ZERO</code> or 
<code>H5T_PAD_ONE</code>.</td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 11</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Atomic String Datatypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_cset_t H5Tget_cset 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightCell"> <p>The only character set currently supported
         is <code>H5T_CSET_ASCII</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5T_str_t H5Tget_strpad 
(hid_t <em>type</em>)</code></td>
     <td class="ColumnRightBottom"> <p>The string datatype has a fixed length,
         but the String may be shorter than the length. This property 
defines the
         storage mechanism for the left over bytes. The options are: 
<code>H5T_STR_NULLTERM</code>,
         <code>H5T_STR_NULLPAD</code>, or <code>H5T_STR_SPACEPAD</code>.</td>
   </tr>
</table>

<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 12</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Opaque Atomic Datatypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>char *H5Tget_tag(hid_t type_id)</td>
     <td class="ColumnRightBottom"> <p>A user defined string.</td>
   </tr>
</table>
<br>

<!-- NEW PAGE -->
<h4><em>4.2.2 Properties of Composite Datatypes</em></h4>

   <p>The composite datatype classes can also be analyzed to discover 
their datatype
   properties and the datatypes that are members or base types of the composite
   datatype. The member or base type can, in turn, be analyzed. Table 13 lists
   the functions that can access the datatype properties of the 
different composite
   datatypes.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 13</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Composite Datatype</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>int H5Tget_nmembers(hid_t 
type_id )</code></td>
     <td class="ColumnRightCell"> <p><strong>(COMPOUND)</strong> The number of
         fields in the compound datatype.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5T_class_t H5Tget_member_class( hid_t
         cdtype_id, int member_no )</code></td>
     <td class="ColumnRightCell"> <p><strong>(COMPOUND)</strong> The 
datatype class
         of compound datatype member <code>member_no</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>char * 
H5Tget_member_name(hid_t type_id,
         int field_idx )</code></td>
     <td class="ColumnRightCell"> <p><strong>(COMPOUND)</strong> The 
name of field
         <code>field_idx</code> of a compound datatype.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>size_t 
H5Tget_member_offset(hid_t type_id,
         int memb_no )</code></td>
     <td class="ColumnRightCell"> <p><strong>(COMPOUND)</strong> The byte offset
         of the beginning of a field within a compound datatype.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t 
H5Tget_member_type(hid_t type_id,
         int field_idx )</code></td>
     <td class="ColumnRightCell"> <p><strong>(COMPOUND)</strong> The datatype of
         the specified member.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>int H5Tget_array_ndims( 
hid_t adtype_id
         )</code></td>
     <td class="ColumnRightCell"> <p><strong>(ARRAY)</strong> The 
number of dimensions
         (rank) of the array datatype object.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tget_array_dims( 
hid_t adtype_id,
         hsize_t *dims[], int *perm[] )</code></td>
     <td class="ColumnRightCell"> <p><strong>(ARRAY)</strong> The sizes of the
         dimensions and the dimension permutations of the array 
datatype object.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t H5Tget_super(hid_t 
type )</code></td>
     <td class="ColumnRightCell"> <p><strong>(ARRAY, VL, ENUM)</strong> The base
         datatype from which the datatype type is derived.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tenum_nameof(hid_t type void
         *value, char *name, size_t size )</code></td>
     <td class="ColumnRightCell"> <p><strong>(ENUM)</strong> The 
symbol name that
         corresponds to the specified value of the enumeration datatype</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tenum_valueof(hid_t type char
         *name, void *value )</code></td>
     <td class="ColumnRightCell"> <p><strong>(ENUM)</strong> The value 
that corresponds
         to the specified name of the enumeration datatype</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>hid_t H5Tget_member_value(hid_t type
         int memb_no, void *value )</code></td>
     <td class="ColumnRightBottom"> <p><strong>(ENUM)</strong> The value of the
         enumeration datatype member <code>memb_no</code></td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>4.3 Definition of Datatypes</h4>

   <p>The HDF5 Library enables user programs to create and modify datatypes. The
   essential steps are:

   <ol>
     <li>a) Create a new datatype object of a specific composite datatype class,
       or <br>
       b) Copy an existing atomic datatype object.
     <li>Set properties of the datatype object.
     <li>Use the datatype object.
     <li>Close the datatype object.
   </ol>

   <p>To create a user defined atomic datatype, the procedure is to 
clone a predefined
   datatype of the appropriate datatype class (<code>H5Tcopy</code>). Then set
   the datatype properties appropriate to the datatype class. For example, Table
   14 shows how to create a datatype to describe a 1024-bit unsigned 
integer.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 14</h4></td>
   </tr>
   <tr valign=top>
     <td>
	<pre>
     hid_t new_type = H5Tcopy (H5T_NATIVE_INT);
     H5Tset_precision(new_type, 1024);
     H5Tset_sign(new_type, H5T_SGN_NONE);</pre>
	</td>
   </tr>
</table>

   <p>Composite datatypes are created with a specific API call for each datatype
   class. Table 15 shows the creation method for each datatype class. 
A newly created
   datatype cannot be used until the datatype properties are set. For example,
   a newly created compound datatype has no members and cannot be used.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 15</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span 
class=TableHead>Datatype Class</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span class=TableHead>Function
         to Create</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>COMPOUND</td>
     <td class="ColumnRightCell"> <p><code>H5Tcreate</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>OPAQUE</td>
     <td class="ColumnRightCell"> <p><code>H5Tcreate</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>COMPOUND</td>
     <td class="ColumnRightCell"> <p><code>H5Tcreate</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>ENUM</td>
     <td class="ColumnRightCell"> <p><code>H5Tenum_create</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>ARRAY</td>
     <td class="ColumnRightCell"> <p><code>H5Tarray_create</code></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>VL</td>
     <td class="ColumnRightBottom"> <p><code>H5Tvlen_create</code></td>
   </tr>
</table>

   <p>Once the datatype is created and the datatype properties set, the datatype
   object can be used.

   <p>Predefined datatypes are defined by the library during 
initialization using
   the same mechanisms as described here. Each predefined datatype is 
locked (<code>H5Tlock</code>),
   so that it cannot be changed or destroyed. User defined datatypes may also be
   locked using <code>H5Tlock</code>.

<!-- NEW PAGE -->
<h4><em>4.3.1 User Defined Atomic Datatypes</em></h4>

   <p>Table 16 summarizes the API methods that set properties of 
atomic types. Table
   17 shows properties specific to numeric types, Table 18 shows 
properties specific
   to the string datatype class. Note that offset, pad, etc. don't 
apply to strings.
   Table 19 shows the specific property of the OPAQUE datatype class.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 16</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Functions
         to set Properties of Atomic DataTypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_size (hid_t 
<em>type</em>,
         size_t <em>size</em>)</code></td>
     <td class="ColumnRightCell"> <p>Set the total size of the element in bytes,
         including padding which may appear on either side of the actual value.
         If this property is reset to a smaller value which would 
cause the significant
         part of the data to extend beyond the edge of the datatype 
then the offset
         property is decremented a bit at a time. If the offset reaches zero and
         the significant part of the data still extends beyond the edge of the
         datatype then the precision property is decremented a bit at 
a time. Decreasing
         the size of a datatype may fail if the H5T_FLOAT bit fields 
would extend
         beyond the significant part of the type. </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_order (hid_t 
<em>type</em>,
         H5T_order_t <em>order</em>)</code></td>
     <td class="ColumnRightCell"> <p>Set the byte order to 
little-endian (<code>H5T_ORDER_LE</code>)or
         big endian (<code>H5T_ORDER_BE</code>).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_precision 
(hid_t <em>type</em>,
         size_t <em>precision</em>)</code></td>
     <td class="ColumnRightCell"> <p>Set the number of significant 
bits of a datatype.
         The <code>offset</code> property (defined below) identifies 
its location.
         The size property defined above represents the entire size (in bytes)
         of the datatype. If the precision is decreased then padding 
bits are inserted
         on the MSB side of the significant bits (this will fail for H5T_FLOAT
         types if it results in the sign, mantissa, or exponent bit 
field extending
         beyond the edge of the significant bit field). On the other 
hand, if the
         precision is increased so that it "hangs over" the edge of 
the total size
         then the offset property is decremented a bit at a time. If the offset
         reaches zero and the significant bits still hang over the 
edge, then the
         total size is increased a byte at a time. </td>
   </tr>
<!-- NEW PAGE -->
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_offset (hid_t 
<em>type</em>,
         size_t <em>offset</em>)</code></td>
     <td class="ColumnRightCell"> <p>Set the bit location of the least 
significant
         bit of a bit field whose length is <code>precision</code>. The bits of
         the entire data are numbered beginning at zero at the least significant
         bit of the least significant byte (the byte at the lowest 
memory address
         for a little-endian type or the byte at the highest address 
for a big-endian
         type). The offset property defines the bit location of the 
least significant
         bit of a bit field whose length is precision. If the offset 
is increased
         so the significant bits "hang over" the edge of the datum, 
then the size
         property is automatically incremented.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>herr_t H5Tset_pad (hid_t 
<em>type</em>,
         H5T_pad_t <em>lsb</em>, H5T_pad_t <em>msb</em>)</code></td>
     <td class="ColumnRightBottom"> <p>Set the padding to zeros 
(<code>H5T_PAD_ZERO</code>)
         or ones (<code>H5T_PAD_ONE</code>). Padding is the bits of a 
data element
         which are not significant as defined by the <code>precision</code> and
         <code>offset</code> properties. Padding in the low-numbered 
bits is <code><em>lsb</em></code>
         padding and padding in the high-numbered bits is 
<code><em>msb</em></code>
         padding. </td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 17</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Numeric Types</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_sign (hid_t 
<em>type</em>,
         H5T_sign_t <em>sign</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(INTEGER)</strong> Integer data can
         be signed two's complement (<code>H5T_SGN_2</code>) or 
unsigned (<code>H5T_SGN_NONE</code>).</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_fields (hid_t 
<em>type</em>,
         size_t <em>spos</em>, size_t <em>epos</em>, size_t 
<em>esize</em>, size_t
         <em>mpos</em>, size_t <em>msize</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> Set the properties
         define the location (bit position of least significant bit of 
the field)
         and size (in bits) of each field. The sign bit is always of length one
         and none of the fields are allowed to overlap. </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>Herr_t H5Tset_ebias (hid_t 
<em>type</em>,
         size_t <em>ebias</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> The 
exponent is stored
         as a non-negative value which is <code>ebias</code> larger 
than the true
         exponent.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tset_norm (hid_t 
<em>type</em>,
         H5T_norm_t <em>norm</em>)</code></td>
     <td class="ColumnRightCell"> <p><strong>(FLOAT)</strong> This 
property describes
         the normalization method of the mantissa.
       <ul>
         <li><code>H5T_NORM_MSBSET</code>: the mantissa is shifted 
left (if non-zero)
           until the first bit after the radix point is set and the exponent is
           adjusted accordingly. All bits of the mantissa after the radix point
           are stored.
         <li><code>H5T_NORM_IMPLIED</code>: the mantissa is shifted 
left (if non-zero)
           until the first bit after the radix point is set and the exponent is
           adjusted accordingly. The first bit after the radix point 
is not stored
           since it's always set.
         <li><code>H5T_NORM_NONE</code>: the fractional part of the mantissa is
           stored without normalizing it. </ul></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>herr_t H5Tset_inpad (hid_t 
<em>type</em>,
         H5T_pad_t <em>inpad</em>)</code></td>
     <td class="ColumnRightBottom"> <p><strong>(FLOAT)</strong> If any internal
         bits (that is, bits between the sign bit, the mantissa field, and the
         exponent field but within the precision field) are unused, 
then they will
         be filled according to the value of this property. The padding can be:
         H5T_PAD_NONE, <code>H5T_PAD_ZERO</code> or 
<code>H5T_PAD_ONE</code>.</td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 18</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Atomic String Datatypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5Tset_size (hid_t 
<em>type</em>, size_t
         <em>size</em>)</code></td>
     <td class="ColumnRightCell"> <p>Set the length of the string, in bytes. The
         precision is automatically set to 8*<code>size</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5Tset_precision (hid_t <em>type</em>,
         size_t <em>precision</em>)</code></td>
     <td class="ColumnRightCell"> <p>The precision must be a multiple of 8.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>H5Tset_cset(hid_t type_id, H5T_cset_t
         cset )</code></td>
     <td class="ColumnRightCell"> <p>The only character set currently supported
         is <code>H5T_CSET_ASCII</code>.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5Tset_strpad(hid_t 
type_id, H5T_str_t
         strpad )</code></td>
     <td class="ColumnRightBottom"> <p>The string datatype has a fixed length,
         but the string may be shorter than the length. This property 
defines the
         storage mechanism for the left over bytes. The method used to 
store character
         strings differs with the programming language:
       <ul>
         <li>C usually null terminates strings while <br>
         <li>Fortran left-justifies and space-pads strings.
       </ul>
       <p>Valid string padding values, as passed in the parameter strpad, are as
         follows:
       <dl>
         <dt><code>H5T_STR_NULLTERM</code> (0)
         <dd>Null terminate (as C does)
         <dt><code>H5T_STR_NULLPAD</code> (1)
         <dd>Pad with zeros
         <dt><code>H5T_STR_SPACEPAD</code> (2)
         <dd>Pad with spaces (as FORTRAN does). </dl></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 19</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span class=TableHead>Properties
         of Opaque Atomic Datatypes</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>H5Tset_tag(hid_t type_id const char
         *tag )</code></td>
     <td class="ColumnRightBottom"> <p>Tags the opaque datatype type_id with an
         ASCII identifier tag.</td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>Examples</h4>

   <p>Figure 10 shows an example of how to create a 128-bit, 
little-endian signed
   integer type one could use the following (increasing the precision of a type
   automatically increases the total size). Note that the proper procedure is to
   begin from a type of the intended datatype class, in this case, a 
NATIVE INT.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hid_t new_type = H5Tcopy (H5T_NATIVE_INT);
     H5Tset_precision (new_type, 128);
     H5Tset_order (new_type, H5T_ORDER_LE);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       10</span></td>
   </tr>
</table>

   <p>Figure 11 shows the storage layout as the type is defined. The 
H5Tcopy creates
   a datatype that is the same as H5T_NATIVE_INT. In this example, suppose this
   is a 32-bit big endian number (Figure 11a). The precision is set to 128 bits,
   which automatically extends the size to 8 bytes (Figure 11b). 
Finally, the byte
   order is set to little-endian (Figure 11c).</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center"><br>

	  <table align="center" border="0" width="100%">
	    <tr><td>

	  <table border="1" align="left">
	    <tr>
	      <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678901</code></td>
		</tr>
	  </table>

	  </td></tr>
	  <tr><td>

	  <table border="0" align="left">
	    <tr><td>a) The H5T_NATIVE_INT<br>&nbsp;</td></tr>
	  </table>

	  </td></tr>
	  <tr><td>

	  <table border="1" align="left">
	    <tr>
		  <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678901</code></td>
		  <td valign="middle" align="center"><code>23456789</code></td>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		</tr>
       </table>

	  </td></tr>
	  <tr><td>

	  <table border="0" align="left">
	    <tr><td>b) Precision extended to 128-bits, the size is 
automatically adjusted.<br>&nbsp;</td></tr>
	  </table>

	  </td></tr>
	  <tr><td>

	  <table border="1" align="left">
	    <tr>
		  <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678901</code></td>
		  <td valign="middle" align="center"><code>23456789</code></td>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		</tr>
	  </table>

	  </td></tr>
	  <tr><td>

	  <table border="0" align="left">
	    <tr><td>c) The Byte Order is switched.</td></tr>
	  </table>
	  </td></tr>
	  </table>
	  </td></tr>
		<tr>
           <td align=center class="fullImgTableCapCell">
           <span class=figurenumber>Figure 11</span></td>
		</tr>
	</table>

   <p>The significant bits of a data element can be offset from the beginning of
   the memory for that element by an amount of padding. The <code>offset</code>
   property specifies the number of bits of padding that appear to the 
"right of"
   the value. Table 20 and Figure 12 shows how a 32-bit unsigned 
integer with 16-bits
   of precision having the value <code>0x1122</code> will be laid out 
in memory.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="5" align="center"><h4>Table 20</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr"> <p><span class=TableHead>Byte 
Position</span></td>
     <td class="ColumnHdr"> <p><span class=TableHead>Big-Endian <br>
         Offset=0</span></td>
     <td class="ColumnHdr"> <p><span class=TableHead>Big-Endian <br>
         Offset=16</span></td>
     <td class="ColumnHdr"> <p><span class=TableHead>Little-Endian <br>
         Offset=0</span></td>
     <td class="ColumnRightHdr"> <p><span class=TableHead>Little-Endian <br>
         Offset=16</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>0:</td>
     <td class="ColumnCell"> <p>[pad]</td>
     <td class="ColumnCell"> <p>[0x11]</td>
     <td class="ColumnCell"> <p>[0x22]</td>
     <td class="ColumnRightCell"> <p>[pad]</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>1:</td>
     <td class="ColumnCell"> <p>[pad]</td>
     <td class="ColumnCell"> <p>[0x22]</td>
     <td class="ColumnCell"> <p>[0x11]</td>
     <td class="ColumnRightCell"> <p>[pad]</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>2:</td>
     <td class="ColumnCell"> <p>[0x11]</td>
     <td class="ColumnCell"> <p>[pad]</td>
     <td class="ColumnCell"> <p>[pad]</td>
     <td class="ColumnRightCell"> <p>[0x22]</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>3:</td>
     <td class="ColumnBottom"> <p>[0x22]</td>
     <td class="ColumnBottom"> <p>[pad]</td>
     <td class="ColumnBottom"> <p>[pad]</td>
     <td class="ColumnRightBottom"> <p>[0x11]</td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center"><br>

	  <table align="center" border="0" width="100%">
	    <tr>
		  <td valign="middle" align="center">Big-Endian: 
Offset = 0</td>
		</tr>
		<tr><td>

	  <table border="1" align="center">
		<tr>
	      <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" align="center"><code>00010001</code></td>
		  <td valign="middle" align="center"><code>00100010</code></td>
		</tr>
	  </table>

	  </td></tr>
	  <tr>
	    <td valign="middle" align="center">&nbsp;<br>Big-Endian: 
Offset = 16</td>
	  </tr>

	  <tr><td>

	  <table border="1" align="center">
	    <tr>
		  <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00010001</code></td>
		  <td valign="middle" align="center"><code>00100010</code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		</tr>
       </table>

	  </td></tr>
       <tr>
	    <td valign="middle" 
align="center">&nbsp;<br>Little-Endian: Offset = 0</td>
	  </tr>

	  <tr><td>

	  <table border="1" align="center">
	    <tr>
		  <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00010001</code></td>
		  <td valign="middle" align="center"><code>00100010</code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		</tr>
       </table>

	  </td></tr>
       <tr>
	    <td valign="middle" 
align="center">&nbsp;<br>Little-Endian: Offset = 16</td>
	  </tr>
	  <tr><td>
	  <table border="1" align="center">
		<tr>
	      <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" 
align="center"><code><em>PPPPPPPP</em></code></td>
		  <td valign="middle" align="center"><code>00010001</code></td>
		  <td valign="middle" align="center"><code>00100010</code></td>
		</tr>
	  </table>

	  </td></tr>
	  </table>&nbsp;

	  </td></tr>
		<tr>
           <td align=center class="fullImgTableCapCell">
           <span class=figurenumber>Figure 12</span></td>
		</tr>
	</table>
   <br>
   <p>If the offset is incremented then the total size is incremented 
also if necessary
   to prevent significant bits of the value from hanging over the edge 
of the datatype.

   <p>The bits of the entire data are numbered beginning at zero at 
the least significant
   bit of the least significant byte (the byte at the lowest memory address for
   a little-endian type or the byte at the highest address for a 
big-endian type).
   The <code>offset</code> property defines the bit location of the 
least signficant
   bit of a bit field whose length is <code>precision</code>. If the offset is
   increased so the significant bits "hang over" the edge of the datum, then the
   <code>size</code> property is automatically incremented.

<!-- NEW PAGE -->
   <p>To illustrate the properties of the integer datatype class, 
Figure 13 shows
   how to create a user defined datatype that describes a 24-bit signed integer
   that starts on the third bit of a 32-bit word. The datatype is 
specialized from
   a 32-bit integer, the <em>precision</em> is set to 24 bits, and the 
<em>offset</em>
   is set to 3.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hid_t dt;

     dt = H5Tcopy(H5T_SDT_32LE);

     H5Tset_precision(dt, 24);
     H5Tset_offset(dt,3);
     H5Tset_pad(dt, H5T_PAD_ZERO,H5T_PAD_ONE);
     </code></pre></td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       13</span></td>
   </tr>
</table>

   <p>Figure 14 shows the storage layout for a data element. Note that 
the unused
   bits in the offset will be set to zero and the unused bits at the end will be
   set to one, as specified in the <code>H5Tset_pad</code> call.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">

       <table border="1" align="center" width="400">
	    <tr>
	      <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong><em>ooo</em></strong>00000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" 
align="center"><code>00s<strong><em>ppppp</em></strong></code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center" colspan="4">
		    <img src="Images/Dtypes_fig14.JPG">
		  </td>
		</tr>
	  </table>

     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       14. A User defined integer Datatype: range -1,048,583 to 
1,048,584</span></td>
   </tr>
</table>

   <p>To illustrate a user defined floating point number, Figure 13 
shows how to create
   a 24-bit floating point number, that starts 5 bits into a 4 byte 
word. The floating
   point number is defined to have a mantissa of 19 bits (bits 5-23), 
and exponent
   of 3 bits (25-27) and the sign bit is bit 28.
   (Note that this is an illustration of what can be done,
   not necessarily a floating point format that a user would require.)</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hid_t dt;

     dt = H5Tcopy(H5T_IEEE_32LE);

     H5Tset_precision(dt, 24);
     H5Tset_fields (dt, 28, 25, 3, 5, 19);
     H5Tset_pad(dt, H5T_PAD_ZERO,H5T_PAD_ONE);
     H5Tset_inpad(dt, H5T_PAD_ZERO);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       15</span></td>
   </tr>
</table>
<br>
<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">

       <table border="1" align="center" width="400">
	    <tr>
	      <td valign="middle" align="center"><code>Byte 0</code></td>
		  <td valign="middle" align="center"><code>Byte 1</code></td>
		  <td valign="middle" align="center"><code>Byte 2</code></td>
		  <td valign="middle" align="center"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>01234567</code></td>
		  <td valign="middle" align="center"><code>89012345</code></td>
		  <td valign="middle" align="center"><code>67890123</code></td>
		  <td valign="middle" align="center"><code>45678967</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong><em>ooooo</em></strong>mmm</code></td>
		  <td valign="middle" align="center"><code>mmmmmmmm</code></td>
		  <td valign="middle" align="center"><code>mmmmmmmm</code></td>
		  <td valign="middle" 
align="center"><code><strong>i</strong>eees<strong><em>ppp</em></strong></code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center" colspan="4">
             <img src="Images/Dtypes_fig16.JPG">
		  </td>
		</tr>
	  </table>

     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       16. A User defined Floating Point Datatype.</span></td>
   </tr>
</table>
<br>

   <p>Figure 16 shows the storage layout of a data element for this 
datatype. Note
   that there is an unused bit (24) between the mantissa and the exponent. This
   bit is filled with the <em>inpad</em> value, in this case 0.

   <p>The sign bit is always of length one and none of the fields are allowed to
   overlap. When expanding a floating-point type one should set the 
precision first;
   when decreasing the size one should set the field positions and sizes first.

<h4>4.3.2 Composite Datatypes</h4>

   <p>All composite datatypes must be user defined,
   there are no predefined composite datatypes.

<h4>4.3.2.1 Compound Datatypes</h4>

<p>The subsections below describe how compound datatypes are created and how to
write and read data of compound datatype.

<h4>4.3.2.1.1 Defining Compound Datatypes</h4>

   <p>Compound datatypes are conceptually similar to a C struct or 
Fortran 95 derived
   types. The compound datatype
   defines a contiguous sequence of bytes, which are formatted using one up to
   2^16 datatypes (members). A compound datatype may have any number of members,
   in any order, and the members
   may have any datatype, including compound. Thus, complex nested 
compound datatypes
   can be created. The total size
   of the compound datatype is greater than or equal to the sum of the size of
   its members, up to a maximum of 2^32 bytes. HDF5 does not support datatypes
   with distinguished records or the equivalent of C unions or Fortran 
95 EQUIVALENCE
   statement.


     <p>Usually a C struct or Fortran derived type will be defined to 
hold a data
       point in memory, and the offsets of the members in memory will be the
       offsets of the struct members from the beginning of an instance
       of the struct. The HDF5 C libary provides a macro 
<code>HOFFSET(s,m)</code>
       to calculate the member's ofset. The HDF5 Fortran applications 
have to calculate offsets
       by using sizes of members datatypes and by taking in 
consideration the order of
       members in the Fortran derived type.



     <dl>
       <dt><code>HOFFSET(s,m)</code>
       <dd>This macro computes the offset of member <em>m</em> within
	a struct <em>s</em>.
       <dt><code>offsetof(s,m)</code>
       <dd>This macro defined in <code>stddef.h</code> does
	exactly the same thing as the <code>HOFFSET()</code> macro.
     </dl>

     <p> <em> Note for Fortran users</em>: Offsets of Fortran structure members
       correspond to the offsets within a packed datatype (see 
explanation below)
       stored in an HDF5 file.</em>


     <p>Each member of a compound datatype must have a descriptive 
name which is the
       key used to uniquely identify the member within the compound
       datatype.  A member name in an HDF5 datatype does not
       necessarily have to be the same as the name of the member in the
       C struct of Fortran derived type, although this is often the 
case.  Nor does one need to
       define all members of the C struct of Fortran derived type in 
the HDF5 compound
       datatype (or vice versa).




   <p>Unlike atomic datatypes which are derived from other atomic datatypes,
   compound datatypes are created from scratch. First, one creates an
   empty compound datatype and specifies its total size. Then members are added
   to the compound datatype in any order. Each member type is inserted 
at a designated
   offset. Each member has a name which is the key used to uniquely identify the
   member within the compound datatype.



<!-- NEW PAGE -->
   <p>Figure 17a shows an example of creating an HDF5 C compound 
datatype to describe
   a complex number, which is a structure with two components, "real" 
and "imagenery",
   each double. An equivalent C <code>struct</code> is whose type is defined by
   the <code>complex_t</code> <code>struct</code>, is shown.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
typedef struct {
     double re;   /*real part*/
     double im;   /*imaginary part*/
  } complex_t;

  hid_t complex_id = H5Tcreate (H5T_COMPOUND, sizeof(complex_t));
  H5Tinsert (complex_id, "real", HOFFSET(complex_t,re),
             H5T_NATIVE_DOUBLE);
  H5Tinsert (complex_id, "imaginary", HOFFSET(complex_t,im),
             H5T_NATIVE_DOUBLE);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       17a</span></td>
   </tr>
</table>

   <p>Figure 17b shows an example of creating an HDF5 Fortran compound 
datatype to describe
   a complex number, which is a Fortran derived type with two 
components, "real" and "imagenary",
   each DOUBLE PRECISION. An equivalent Fortran <code>TYPE</code> is 
whose type is defined by
   the <code>TYPE</code> <code>complex_t</code>, is shown.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
  TYPE complex_t
     DOUBLE PRECISION re   ! real part
     DOUBLE PRECISION im;  ! imaginary part
  END TYPE complex_t

  CALL h5tget_size_f(H5T_NATIVE_DOUBLE, re_size, error)
  CALL h5tget_size_f(H5T_NATIVE_DOUBLE, im_size, error)
  complex_t_size = re_size + im_size
  CALL h5tcreaet_f(H5T_COMPOUND_F, complex_t_size, type_id)
  offset = 0
  CALL h5tinsert_f(type_id, "real", offset, H5T_NATIVE_DOUBLE, error)
  offset = offset + re_size
  CALL h5tinsert_f(type_id, "imaginary", offset, H5T_NATIVE_DOUBLE, error)

     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       17b</span></td>
   </tr>
</table>

   <p><em> Important Note: </em>The compound datatype is created with 
a size sufficient to hold
   all its members. In the C example above, the size of the C 
<code>struct</code> and
   the HOFFSET macro are used as a convenient
   mechanism to determine the appropriate size and offset. 
Alternatively, the size and offset could
   be manually determined, e.g., the size can be set to 16 with "real" 
at offset 0 and "imaginary" at offset
   8. However, different platforms and compilers have different sizes 
for "double",
   and may have alignment restrictions which require additional padding within
   the structure. It is much more portable to use the HOFFSET macro, 
which assures
   that the values will be correct for any platform.

   <p>Figure 18 shows how the compound datatype would be laid out, assuming that
   NATIVE_DOUBLE are 64-bit numbers, and there are no alignment 
requirements. The
   total size of the compound datatype will be 16 bytes, the "real" 
component will
   start at byte 0, and "imaginary" will start at byte 8.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">

       <table border="1" align="center" width="550">
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		    <img src="Images/Dtypes_fig18_a.jpg">
		  </td>
	      <td valign="middle" align="center" 
width="100"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		    <img src="Images/Dtypes_fig18_b.jpg">
	      </td>
	      <td valign="middle" align="center"><code>Byte 8</code></td>
		  <td valign="middle" align="center"><code>Byte 9</code></td>
		  <td valign="middle" align="center"><code>Byte 10</code></td>
		  <td valign="middle" align="center"><code>Byte 11</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	  </table>

	  <table align="center" border="0" width="550">
         <tr>
		  <td valign="top" align="right" width="150">&nbsp;</td>
		  <td valign="top" align="center" colspan="4">Total 
size of Compound Datatype is 16 bytes</td>
		</tr>
	  </table>

     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       18</span></td>
   </tr>
</table>

   <p>The members of a compound datatype may be any HDF5 datatype, 
including compound,
   array, and VL. Figures 19 and 20 show an example which creates a 
compound datatype
   composed of two complex values, each of which is a compound 
datatype as in Figure
   18 above.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">

	  <table border="1" align="center" width="550">
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		  <img src="Images/Dtypes_fig19_a.jpg">
		  </td>
	      <td valign="middle" align="center" 
width="100"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_b.jpg" align="middle">
		  </td>
	      <td valign="middle" align="center"><code>Byte 8</code></td>
		  <td valign="middle" align="center"><code>Byte 9</code></td>
		  <td valign="middle" align="center"><code>Byte 10</code></td>
		  <td valign="middle" align="center"><code>Byte 11</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_c.jpg"></td>
	      <td valign="middle" align="center" 
width="100"><code>Byte 16</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 17</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 18</code></td>
		  <td valign="middle" align="center" 
width="100"><code>Byte 19</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 20</code></td>
		  <td valign="middle" align="center"><code>Byte 21</code></td>
		  <td valign="middle" align="center"><code>Byte 22</code></td>
		  <td valign="middle" align="center"><code>Byte 23</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_d.jpg"></td>
	      <td valign="middle" align="center"><code>Byte 24</code></td>
		  <td valign="middle" align="center"><code>Byte 25</code></td>
		  <td valign="middle" align="center"><code>Byte 26</code></td>
		  <td valign="middle" align="center"><code>Byte 27</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 28</code></td>
		  <td valign="middle" align="center"><code>Byte 29</code></td>
		  <td valign="middle" align="center"><code>Byte 30</code></td>
		  <td valign="middle" align="center"><code>Byte 31</code></td>
		</tr>
		<tr>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" 
align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	  </table>

	  <table align="center" width="550">
	    <tr>
		  <td width="150">&nbsp;</td>
		  <td>Total size of Compound Datatype is 32 bytes.</td>
		</tr>
	  </table>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       19</span></td>
   </tr>
</table>


<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
      typedef struct {
         complex_t x;
         complex_t y;
      } surf_t;

     hid_t complex_id, surf_id; /*hdf5 datatypes*/

      complex_id = H5Tcreate (H5T_COMPOUND, sizeof(complex_t));
      H5Tinsert (complex_id, "re", HOFFSET(complex_t,re),
                 H5T_NATIVE_DOUBLE);
      H5Tinsert (complex_id, "im", HOFFSET(complex_t,im),
                 H5T_NATIVE_DOUBLE);

      surf_id = H5Tcreate (H5T_COMPOUND, sizeof(surf_t));
      H5Tinsert (surf_id, "x", HOFFSET(surf_t,x), complex_id);
      H5Tinsert (surf_id, "y", HOFFSET(surf_t,y), complex_id);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       20</span></td>
   </tr>
</table>

<p>Note that a similar result could be accomplished by creating a 
compound datatype
   and inserting four fields (Figure 21). This results in the same 
layout as above
   (Figure 19). The difference would be how the fields are addressed. 
In the first
   case, the real part of 'y' is called 'y.re'; in the second case it 
is 'y-re'.</p>

<br>
<!-- NEW PAGE -->

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     typedef struct {
         complex_t x;
         complex_t y;
      } surf_t;

      hid_t surf_id = H5Tcreate (H5T_COMPOUND, sizeof(surf_t));
      H5Tinsert (surf_id, "x-re", HOFFSET(surf_t,x.re),
                 H5T_NATIVE_DOUBLE);
      H5Tinsert (surf_id, "x-im", HOFFSET(surf_t,x.im),
                 H5T_NATIVE_DOUBLE);
      H5Tinsert (surf_id, "y-re", HOFFSET(surf_t,y.re),
                 H5T_NATIVE_DOUBLE);
      H5Tinsert (surf_id, "y-im", HOFFSET(surf_t,y.im),
                 H5T_NATIVE_DOUBLE);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       21</span></td>
   </tr>
</table>
<br>

   <p>The members of a compound datatype do not always fill all the 
bytes. The HOFFSET
   macro assures that the members will be laid out according to the requirements
   of the platform and language. Figure 22 shows an example of a C struct which
   requires extra bytes of padding on many platforms. The second element, 'b',
   is a 1-byte character, followed by an 8 byte double, 'c'. On many 
systems, the
   8-byte value must be stored on a 4- or 8-byte boundary, requiring the struct
   to be larger than the sum of the size of its elements.

   <p>In Figure 22 , the <code>sizeof</code> and <code>HOFFSET</code> 
macro is used
   to assure that the members are inserted at the correct offset to 
match the memory
   conventions of the platform. Figure 23 shows how this data element would be
   stored in memory, assuming the double must start on a 4-byte boundary. Notice
   the extra bytes between 'b' and 'c'.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     typedef struct s1_t {
        int    a;
        char  b;
        double c;
     } s1_t;

     s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       22</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig23.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       23</span></td>
   </tr>
</table>
<br>

   <p>However, data stored on disk does not require alignment, so 
unaligned versions
   of compound data structures can be created to improve space 
efficiency on disk.
   These unaligned compound datatypes can be created by computing 
offsets by hand
   to eliminate inter-member padding, or the members can be packed by 
calling <code>H5Tpack</code>
   (which modifies a datatype directly, so it is usually preceded by a call to
   <code>H5Tcopy</code>):


<p>Figure 24a shows how to create a disk version of the compound datatype from
   Figure 22 above in order to store data on disk in as compact a form 
as possible.
   Figure 25 shows the layout of the bytes in the packed data structure. Packed
   compound datatypes should generally not be used to describe memory 
as they may
   violate alignment constraints for the architecture being used. Note also that
   using a packed datatype for disk storage may involve a higher data conversion
   cost. </p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hid_t s2_tid = H5Tcopy (s1_tid);
                    H5Tpack (s2_tid);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       24a</span></td>
   </tr>
</table>

<p>Figure 24b shows the sequence of Fortran calls to create a packed 
compound datatype.
    An HDF5 Fortran compound datatype never describes a compound datatype
    in memory and compound data is <em>ALWAYS</em> written by fields 
as described in the next section. Therefore
   packing is not needed unless the the offset of each consecutive 
member is not equal to the sum of the sizes
   of the previous members.
   </p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     CALL h5tcopy_f(s1_id, s2_id, error)
     CALL h5tpack_f(s2_id, error)
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       24b</span></td>
   </tr>
</table>

<br>

<h4>4.3.2.1.2 Creating, writing and reading datasets with compound 
datatypes</h4>

<p> Creating datasets with compound datatypes is similar to creating 
datasets with any
other HDF5 datatypes. But writing and reading may be different since 
datsets that have
compound datatypes can be written or read by a field (member) or 
subsets of fields (members).
The compound datatype is the only compoiste datatype that supports 
"sub-setting" by the elements
the datatype is built from.

<p>Figure 25a shows C example of creating and writing a dataset with 
a compound datatype.

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     typedef struct s1_t {
        int    a;
        float  b;
        double c;
     } s1_t;

     s1_t data[LENGTH];

     /* Initialize data */
     for (i = 0; i < LENGTH; i++) {
          data[i].a = i;
          data[i].b = i*i;
          data[i].c = 1./(i+1);
     ...
     s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_FLOAT);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);
     ...
     dataset_id = H5Dcreate(file_id, "SDScompound.h5", s1_t, space_id, 
H5PDEFAULT);
     H5Dwrite (dataset_id,s1_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);

     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       25a</span></td>
   </tr>
</table>

<br>
<p>Figure 25b shows the content of the file written on the 
liitle-endian machine.

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>


HDF5 "SDScompound.h5" {
GROUP "/" {
    DATASET "ArrayOfStructures" {
       DATATYPE  H5T_COMPOUND {
          H5T_STD_I32LE "a_name";
          H5T_IEEE_F32LE "b_name";
          H5T_IEEE_F64LE "c_name";
       }
       DATASPACE  SIMPLE { ( 3 ) / ( 3 ) }
       DATA {
       (0): {
             0,
             0,
             1
          },
       (1): {
             1,
             1,
             0.5
          },
       (2): {
             2,
             4,
             0.333333
          }
       }
    }
}
}



     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       25b</span></td>
   </tr>
</table>

<br>

<p>It is not necessary to write the whole data at once. Datasets with 
compound datatypes
can be written by field. In order to do this one has to remember to 
set transfer property of the
dataset using <code> H5Pset_preserve</code> call and to define memory 
datatype that corresponds
to a field. Figure 25c shows how field b is written to the dataset.

  <table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     typedef struct sb_t {
        float  b;
        double c;
     } sb_t;

     typedef struct sc_t {
        float  b;
        double c;
     } sc_t;
     sb_t data1[LENGTH];
     sc_t data2[LENGTH];

     /* Initialize data */
     for (i = 0; i < LENGTH; i++) {
          data1.b = i*i;
          data2.c = 1./(i+1);
     }
     ...
     /* Create dataset as in example 25a */
     ...
     /* Create memory datatypes corresponding to float and double 
datatype fileds */

     sb_tid = H5Tcreate (H5T_COMPOUND, sizeof(sb_t));
     H5Tinsert(sb_tid, "b_name", HOFFSET(sb_t, b), H5T_NATIVE_FLOAT);
     sc_tid = H5Tcreate (H5T_COMPOUND, sizeof(sc_t));
     H5Tinsert(sc_tid, "c_name", HOFFSET(sc_t, c), H5T_NATIVE_DOUBLE);
     ...
     /* Set transfer property */
     xfer_id = H5Pcreate(H5P_DATASET_XFER);
     H5Pset_preserve(xfer_id, 1);
     H5Dwrite (dataset_id,sb_tid, H5S_ALL, H5S_ALL, xfer_id, data1);
     H5Dwrite (dataset_id,sc_tid, H5S_ALL, H5S_ALL, xfer_id, data2);

     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       25c</span></td>
   </tr>
</table>

<br>

<p>Figure 25d shows the content of the file written on the 
little-endian machine. Only
float and double fileds are written. Default fill value is used to 
initialize unwritten
integer filed.

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>

HDF5 "SDScompound.h5" {
GROUP "/" {
    DATASET "ArrayOfStructures" {
       DATATYPE  H5T_COMPOUND {
          H5T_STD_I32LE "a_name";
          H5T_IEEE_F32LE "b_name";
          H5T_IEEE_F64LE "c_name";
       }
       DATASPACE  SIMPLE { ( 3 ) / ( 3 ) }
       DATA {
       (0): {
             0,
             0,
             1
          },
       (1): {
             0,
             1,
             0.5
          },
       (2): {
             0,
             4,
             0.333333
          }
       }
    }
}
}




     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       25d</span></td>
   </tr>
</table>

<br>

  <p>Figure 25e contains a Fortran example that creates and writes 
    a dataset with a compound datatype. 
    As this example illustrates, writing and reading compound datatypes 
    in Fortran is <em>always</em> done by fields.
    The content of the written file is the same as shown in the Figure 25b.

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>

     ! One cannot write an array of a derived datatype in Fortran.
     TYPE s1_t
        INTEGER          a
        REAL             b
        DOUBLE PRECISION c
     END TYPE s1_t
     TYPE(s1_t) d(LENGTH)

     ! Therefore, the following code initializes an array corresponding 
     ! to each field in the derived datatype and writes those arrays 
     ! to the dataset

     INTEGER, DIMENSION(LENGTH)          :: a
     REAL, DIMENSION(LENGTH)             :: b
     DOUBLE PRECISION, DIMENSION(LENGTH) :: c

     ! Initialize data
      do i = 1, LENGTH
         a(i) = i-1
         b(i) = (i-1) * (i-1)
         c(i) = 1./i
      enddo

     ...

      ! Set dataset transfer property to preserve partially initialized fields
      ! during write/read to/from dataset with compound datatype.
      !
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, error)
      CALL h5pset_preserve_f(plist_id, .TRUE., error)
     ...
      !
      ! Create compound datatype.
      !
      ! First calculate total size by calculating sizes of each member
      !
      CALL h5tget_size_f(H5T_NATIVE_INTEGER, type_sizei, error)
      CALL h5tget_size_f(H5T_NATIVE_REAL, type_sizer, error)
      CALL h5tget_size_f(H5T_NATIVE_DOUBLE, type_sized, error)
      type_size = type_sizei + type_sizer + type_sized
      CALL h5tcreate_f(H5T_COMPOUND_F, type_size, dtype_id, error)
      !
      ! Insert memebers
      !
      !
      ! INTEGER member
      !
      offset = 0
      CALL h5tinsert_f(dtype_id, "a_name", offset, H5T_NATIVE_INTEGER, error)
      !
      ! REAL member
      !
      offset = offset + type_sizei
      CALL h5tinsert_f(dtype_id, "b_name", offset, H5T_NATIVE_REAL, error)
      !
      ! DOUBLE PRECISION member
      !
      offset = offset + type_sizer
      CALL h5tinsert_f(dtype_id, "c_name", offset, H5T_NATIVE_DOUBLE, error)

      !
      ! Create the dataset with compound datatype.
      !
      CALL h5dcreate_f(file_id, dsetname, dtype_id, dspace_id, &
                       dset_id, error)
      !
     ...
      ! Create memory types. We have to create a compound datatype
      ! for each member we want to write.
      !
      !
      CALL h5tcreate_f(H5T_COMPOUND_F, type_sizei, dt1_id, error)
      offset = 0
      CALL h5tinsert_f(dt1_id, "a_name", offset, H5T_NATIVE_INTEGER, error)
      !
      CALL h5tcreate_f(H5T_COMPOUND_F, type_sizer, dt2_id, error)
      offset = 0
      CALL h5tinsert_f(dt2_id, "b_name", offset, H5T_NATIVE_REAL, error)
      !
      CALL h5tcreate_f(H5T_COMPOUND_F, type_sized, dt3_id, error)
      offset = 0
      CALL h5tinsert_f(dt3_id, "c_name", offset, H5T_NATIVE_DOUBLE, error)
      !
      ! Write data by fields in the datatype. Fields order is not important.
      !
      CALL h5dwrite_f(dset_id, dt3_id, c, data_dims, error, xfer_prp = plist_id)
      CALL h5dwrite_f(dset_id, dt2_id, b, data_dims, error, xfer_prp = plist_id)
      CALL h5dwrite_f(dset_id, dt1_id, a, data_dims, error, xfer_prp = plist_id)



     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       25e</span></td>
   </tr>
</table>

<br>
<h4>4.3.2.2 Array</h4>

   <p>Many scientific datasets have multiple measurements for each 
point in a space.
   There are several natural ways to represent this data, depending on 
the variables
   and how they are used in computation (Table 21).</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="3" align="center"><h4>Table 21</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr"> <p><span class=TableHead>Storage 
Strategy</span></td>
     <td class="ColumnHdr"> <p><span class=TableHead>Stored as</span></td>
     <td class="ColumnRightHdr"> <p><span class=TableHead>Remarks</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Mulitple planes</td>
     <td class="ColumnCell"> <p>Several datasets with identical dataspaces</td>
     <td class="ColumnRightCell"> <p>This is optimal when variables are accessed
         individually, or when often uses only selected variables.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Additional dimension</td>
     <td class="ColumnCell"> <p>One dataset, the last "dimension" is a vector of
         variables</td>
     <td class="ColumnRightCell"> <p>This can give good performance, 
although selecting
         only a few variables may be slow. This may not reflect the 
science.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Record with multiple values</td>
     <td class="ColumnCell"> <p>One dataset with compound datatype</td>
     <td class="ColumnRightCell"> <p>This enables the variables to be read all
         together or selected. Also handles "vectors" of heterogenous data.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>Vector or Tensor value</td>
     <td class="ColumnBottom"> <p>One dataset, each data element is a 
small array
         of values.</td>
     <td class="ColumnRightBottom"> <p>This uses the same amount of space as the
         previous two, and may represent the science model better.</td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
       <img src="Images/Dtypes_fig26_pic1of4.JPG"><br><hr>
       <img src="Images/Dtypes_fig26_pic3of4.JPG"></td>
     <td class="fullImgTableImgCell" align="center">
       <img src="Images/Dtypes_fig26_pic2of4.JPG"><br><hr>
       <img src="Images/Dtypes_fig26_pic4of4.JPG"></td>
   </tr>
   <tr>
     <td colspan="2" align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       26</span></td>
   </tr>
</table>
<br>

   <p>The HDF5 H5T_ARRAY datatype defines the data element to be a 
homogeneous, multi-dimensional
   array, as in Figure 26d, above. The elements of the array can be 
any HDF5 datatype
   (including compound and array), the size of the datatype is the total size of
   the array. A dataset of array datatype cannot be subdivided for I/O 
within the
   data element, the entire array of the data element must be 
transferred. If the
   data elements need to be accessed separated, e.g., by plane, then the array
   datatype should not be used. Table 22 gives advantages and disadvantages of
   the storage methods.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="3" align="center"><h4>Table 22</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr"> <p><span class=TableHead>Method</span></td>
     <td class="ColumnHdr"> <p><span class=TableHead>Advantages</span></td>
     <td class="ColumnRightHdr"> <p><span 
class=TableHead>Disadvantages</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>a) Multiple Datasets</td>
     <td class="ColumnCell"> <p>
       <ul>
         <li>Easy to access each plane, can select any plane(s).</ul></td>
     <td class="ColumnRightCell"> <p>
       <ul>
         <li>Less efficient to access a 'column' through the planes</ul></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>b) N+1 Dimension</td>
     <td class="ColumnCell"> <p>
       <ul>
         <li>All access patterns supported.</ul></td>
     <td class="ColumnRightCell"> <p>
       <ul>
         <li>Must be homogeneous datatype.
         <li>The added dimension may not make sense in the scientific 
model. </ul></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>c) Compound Datatype</td>
     <td class="ColumnCell"> <p>
       <ul>
         <li>Can be heterogenous datatype.</ul></td>
     <td class="ColumnRightCell"> <p>
       <ul>
         <li>Planes must be named, selection is by plane.
         <li>Not a natural representation for a matrix.</ul></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>d) Array</td>
     <td class="ColumnBottom"> <p>
       <ul>
         <li>Cannot access elements separately (no access by plane)</ul></td>
     <td class="ColumnRightBottom"> <p>
       <ul>
         <li>A natural representation for vector or tensor data.</ul></td>
   </tr>
</table>

   <p>An array datatype may be multi-dimensional, with 1 to 
H5S_MAX_RANK (the maximum
   rank of a dataset is currently 32). The dimensions can be any size 
greater than
   0, but unlimited dimensions are not supported (although the datatype can be
   a variable length datatype).</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <ul>
         <li>An array datatype may be multi-dimensional, with 1 to H5S_MAX_RANK
           (the maximum rank of a dataset is currently 32).
         <li>The elements of the array can be any HDF5 datatype 
(including compound
           and array),
         <li>An array datatype element cannot be subdivided for I/O, the entire
           array of the data element must be transferred. </ul></td>
   </tr>
</table>

   <p>An array datatype is create with the 
<code>H5Tarray_create</code> call, which
   specifies the number of dimensions, the size of each dimension, and the base
   type of the array. The array datatype can then be used in any way 
that any datatype
   object is used. Figure 27 shows the creation of a datatype that is 
a two-dimensional
   array of native integers, which is then used to create a dataset. Note that
   the dataset can a dataspace that is any number and size of dimensions. Figure
   28 shows the layout in memory, assuming that the native integers are 4 bytes.
   Each data element has 6 elements, for a total of 24 bytes.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
      hid_t       file, dataset;
      hid_t       datatype, dataspace;
      hsize_t     adims[] = {3, 2};

      datatype = H5Tarray_create(H5T_NATIVE_INT, 2, adims, NULL);

      dataset = H5Dcreate(file, DATASETNAME, datatype, dataspace,
            <strong>H5P_DEFAULT);</strong>
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       27</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig28.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       28</span></td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>4.3.2.3 Variable-length (VL) Datatypes</h4>

   <p>A variable-length (VL) datatype is a one-dimensional sequence of 
a datatype
   which are not fixed in length from one dataset location to another, 
i.e., each
   data element may have a different number of members. 
Variable-length datatypes
   cannot be divided, the entire data element must be transferred.</p>

   <p>VL datatypes are useful to the scientific community in many 
different ways,
   possibly including:
   <ul>
     <li><em>Ragged arrays</em>: Multi-dimensional ragged arrays can 
be implemented
       with the last (fastest changing) dimension being ragged by 
using a VL datatype
       as the type of the element stored.
     <li><em>Fractal arrays</em>: A nested VL datatype can be used to 
implement ragged
       arrays of ragged arrays, to whatever nesting depth is required 
for the user.
     <li><em>Polygon lists</em>: A common storage requirement is to 
efficiently store
       arrays of polygons with different numbers of vertices. A VL datatypes can
       be used to efficiently and succinctly describe an array of 
polygons with different
       numbers of vertices.
     <li><em>Character strings</em>: Perhaps the most common use of VL datatypes
       will be to store C-like VL character strings in dataset 
elements or as attributes
       of objects.
     <li><em>Indices, e.g. of objects within the file</em>: An array 
of VL object
       references could be used as an index to all the objects in a 
file which contain
       a particular sequence of dataset values.
     <li><em>Object Tracking</em>: An array of VL dataset region 
references can be
       used as a method of tracking objects or features appearing in a 
sequence of
       datasets.
   </ul>

   <p>A VL datatype is created by calling <code>H5Tvlen_create</code>, 
which specifies
   the base datatype. Figure 29 shows an example of code that creates 
a VL datatype
   of unsigned integers. Each data element is a one-dimensional array of zero or
   more members, which must be stored in a structure, <code>hvl_t</code> (Figure
   30).</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     tid1 = H5Tvlen_create (H5T_NATIVE_UINT);

     dataset=H5Dcreate(fid1,"Dataset1",tid1,sid1,H5P_DEFAULT);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       29</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
	<pre><code>
  typedef struct  {
      size_t len; /* Length of VL data (in base type units) */
      void *p;    /* Pointer to VL data */
  <strong>} hvl_t;</strong>
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       30</span></td>
   </tr>
</table>

<!-- NEW PAGE -->
   <p>Figure 31 shows how the VL data is written. For each of the 10 
data elements,
   a length and data buffer must be allocated. Figure 33 shows how the data is
   laid out in memory.

   <p>An analogous procedure must be used to read the data (Figure 32).
   An appropriate array of <code>vl_t</code> must be allocated,
   and the data read. It is then traversed one data element at a time.
   The <code>H5Dvlen_free</code> call frees the data buffer for the buffer.
   With each element possibly being of different sequence lengths for a
   dataset with a VL datatype, the memory for the VL datatype
   must be dynamically allocated. Currently there are two methods of 
managing the
   memory for VL datatypes: the standard C malloc/free memory 
allocation routines
   or a method of calling user-defined memory management routines to allocate or
   free memory (set with <code>H5Pset_vlen_mem_manager</code>). Since the memory
   allocated when reading (or writing) may be complicated to release, 
the <code>H5Dvlen_reclaim</code>)
   is provided to traverse a memory buffer and free the VL datatype information
   without leaking memory.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hvl_t wdata[10];   /* Information to write */

     /* Allocate and initialize VL data to write */
     for(i=0; i < 10; i++) {
         wdata[i].p = malloc((i+1)*sizeof(unsigned int));
         wdata[i].len = i+1;
         for(j=0; j<(i+1); j++)
             ((unsigned int *)wdata[i].p)[j]=i*10+j;
     }

     ret=H5Dwrite(dataset,tid1,H5S_ALL,H5S_ALL,H5P_DEFAULT,wdata);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       31</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
     hvl_t rdata[SPACE1_DIM1];
     ret=H5Dread(dataset,tid1,H5S_ALL,H5S_ALL,xfer_pid,rdata);

     for(i=0; i&lt;SPACE1_DIM1; i++) {
       printf("%d: len %d ",rdata[i].len);
       for(j=0; j&lt;rdata[i].len; j++) {
          printf(" value: %u\n",((unsigned int *)rdata[i].p)[j]);
       }
     }
     ret=H5Dvlen_reclaim(tid1,sid1,xfer_pid,rdata);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       32</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig33.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       33</span></td>
   </tr>
</table>

   <p>The user program must carefully manage these relatively complex 
data structures,
   such as suggested by Figure 33. The <code>H5Dvlen_reclaim</code> 
function performs
   a standard traversal, freeing all the data. This function analyzes 
the datatype
   and dataspace objects, and visits each VL data element, recursing 
through nested
   types. By default, the system <code>free</code> is called for the pointer in
   each <code>vl_t</code>. Obviously, this call assumes that all of this memory
   was allocated with the system <code>malloc</code>.

   <p>The user program may specify custom memory manager routines, one 
for allocating
   and one for freeing. These may be set with the 
<code>H5Pvlen_mem_manager</code>,
   and must have the following prototypes:

   <ul>
     <li><code>typedef void *(*H5MM_allocate_t)(size_t size, void 
*info)</code> ;
     <li><code>typedef void (*H5MM_free_t)(void *mem, void *free_info)</code> ;
   </ul>

   <p>The utility function <code>H5Dget_vlen_buf_size</code> checks 
the number of
   bytes required to store the VL data from the dataset. This function analyzes
   the datatype and dataspace object to visit all the VL data 
elements, to determine
   the number of bytes required to store the data for the in the 
destination storage
   (memory). The <code>size</code> value is adjusted for data 
conversion and alignment
   in the destination.</p>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="NonNumDtypes">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="NonNumDtypes">
<h3 class=pagebefore>5. Other Non-numeric Datatypes</h3>
</a>

   <p>Several datatype classes define special types of objects.

<h4>5.1 Strings</h4>

   <p>Text data is represented by arrays of characters, called strings.
   Many programming languages support different conventions for storing strings,
   which may be fixed or variable length, and may have different rules 
for padding
   unused storage.  HDF5 can represent strings in several ways.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">

	<table align="center" width="600">
	  <tr align="left">
	    <td width="5%">&nbsp;</td>
	    <td width="25%" align="left" valign="top">The&nbsp;Strings&nbsp;to&nbsp;store&nbsp;are:&nbsp;</td>
		<td width="70%" align="left">"Four score",<br> "lazy 
programmers."</td>
	  </tr>
	  <tr>
	    <td colspan="3">&nbsp;</td>
	  </tr>

	 </table>
   <table width="100%">
     <tr align="left">
       <td width="5%">&nbsp;</td>
       <td valign="top" align="right">
         <strong>a)</strong>
       </td>
       <td>H5T_NATIVE_CHAR
        <br>
        The dataset is a one-dimensional
         array with 29 elements, each element is a single character.
       </td>
     </tr>
   </table>

   <table align="center" width="600">
	  <tr>
	    <td width="5%">&nbsp;</td>
		<td colspan="2">
		  <table border="1" width="100%">
		    <tr>
			  <td align="center">0</td>
			  <td align="center">1</td>
			  <td align="center">2</td>
			  <td align="center">3</td>
			  <td align="center">4</td>
			  <td align="center">...</td>
			  <td align="center">25</td>
			  <td align="center">26</td>
			  <td align="center">27</td>
			  <td align="center">28</td>
			</tr>
		    <tr>
			  <td align="center">'F'</td>
			  <td align="center">'o'</td>
			  <td align="center">'u'</td>
			  <td align="center">'r'</td>
			  <td align="center">'&nbsp;'</td>
			  <td align="center">...</td>
			  <td align="center">'r'</td>
			  <td align="center">'s'</td>
			  <td align="center">'.'</td>
			  <td align="center">'\0'</td>
			</tr>
		  </table>
		</td>
	  </tr>
	  <tr><td colspan="3">&nbsp;</td></tr>
	</table>

	<table width="100%">
	  <tr align="left">
	    <td width="5%">&nbsp;</td>
		<td align="right" valign="top"><strong>b)</strong></td>
		<td> Fixed-length string
                  <br>
		  The dataset is a one-dimensional array with 2 
elements, each element
		  is 20 characters.
		</td>
	  </tr>
	</table>

	<table align="center" width="600">
	  <tr>
	    <td width="15%">&nbsp;</td>
		<td colspan="2">
		  <table border="1" width="50%">
		    <tr align="center">
			  <td>&nbsp;&nbsp;0&nbsp;&nbsp;</td>
 
<td><code>"Four&nbsp;score\0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</code></td>
			</tr>
			<tr align="center">
			  <td>&nbsp;&nbsp;1&nbsp;&nbsp;</td>
			  <td><code>"lazy&nbsp;programmers.\0"</code></td>
			</tr>
		  </table>
		</td>
	  </tr>
       <tr><td colspan="3">&nbsp;</td></tr>
	</table>

	<table width="100%">
	  <tr align="left">
	    <td width="5%">&nbsp;</td>
		<td align="right" valign="top"><strong>c)</strong></td>
		<td>Variable Length string
                  <br>
                   The dataset is a
		  one-dimensional array with 2 elements, each element 
is a variable-length string.
		  <br>This is the same result when stored as
		  fixed-length string, except that first element of
                   the array will need only 11 bytes for storage instead of 20.
		</td>
	  </tr>
	</table>

<table align="center" width="600">
	  <tr>
	    <td width="15%">&nbsp;</td>
		<td colspan="2">
		  <table border="1" width="50%">
		    <tr align="center">
			  <td>&nbsp;&nbsp;0&nbsp;&nbsp;</td>
			  <td><code>"Four&nbsp;score\0"</code></td>
			</tr>
			<tr align="center">
			  <td>&nbsp;&nbsp;1&nbsp;&nbsp;</td>
			  <td><code>"lazy&nbsp;programmers.\0"</code></td>
			</tr>
		  </table>
		</td>
	  </tr>
       <tr><td colspan="3">&nbsp;</td></tr>
	</table>

	<table align="center" width="600">
	  <tr>
	    <td width="15%">&nbsp;</td>
		<td colspan="2">
           <img src="Images/Dtypes_fig34.JPG">
		</td>
	  </tr>
	</table>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 34</span></td>
   </tr>
   </table>
   </td></tr></table>

   <p>First, a dataset may have a dataset with datatype H5T_NATIVE_CHAR, with
   each character of the string as an element of the dataset. This will store
   an unstructured block of text data, but gives little indication of any
   structure in the text (Figure 34a).

   <p>A second alternative is to store the data using the datatype 
class H5T_STRING,
   with each element a fixed length (Figure 34b). In this approach, each element
   might be a word or a sentence, addressed by the dataspace. The 
dataset reserves
   space for the specified number of characters, although some strings 
may be shorter.
   This approach is simple and usually is fast to access, but can waste storage
   space if the length of the Strings varies.

   <p>A third alternative is to use a variable-length datatype (Figure 34c).
   This can be done using the standard mechanisms described above (e.g., using
   <code>H5T_NATIVE_CHAR</code> instead of <code>H5T_NATIVE_INT</code> in Figure
   29 above).  The program would use <code>vl_t</code> structures to write and
   read the data.

   <p>A fourth alternative is to use a special feature of the string 
datatype class,
   to set the size of the datatype to <code>H5T_VARIABLE</code> (Figure 34c).
   Figure 35 shows a declaration of a datatype of type <code>H5T_C_S1</code>,
   which is set to <code>H5T_VARIABLE</code>.  The HDF5 Library automatically
   translates between this and the <code>vl_t</code> structure. (Note: the
   <code>H5T_VARIABLE</code> size can only be used with string datatypes.)</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
  tid1 = H5Tcopy (H5T_C_S1);

ret = H5Tset_size (tid1,H5T_VARIABLE);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 35</span></td>
   </tr>
</table>

   <p>Variable-length strings can be read into C strings (i.e., pointers to zero
   terminated arrays of <code>char</code>) (Figure 36).

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
    char *rdata[SPACE1_DIM1];

    ret=H5Dread(dataset,tid1,H5S_ALL,H5S_ALL,xfer_pid,rdata);

    for(i=0; i&lt;SPACE1_DIM1; i++) {
             printf("%d: len: %d, str is: %s\n", strlen(rdata[i]),rdata[I]);
    }

    ret=H5Dvlen_reclaim(tid1,sid1,xfer_pid,rdata);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 36</span></td>
   </tr>
</table>

<h4>5.2 Reference</h4>

   <p>In HDF5, objects (i.e. groups, datasets, and named datatypes) are usually
   accessed by name. There is another way to access stored objects -- 
by reference.
   There are two reference datatypes, object reference and region reference.
   Object reference objects are created with the <code>H5Rcreate</code> and
   other calls (cross reference). These objects can be stored and retrieved
   in a dataset as elements with reference datatype. Figure 37 shows an example
   of code that creates references to four objects, and then writes the array
   of object references to a dataset. Figure 38 shows a dataset of datatype
   reference being read, and one of the object reference objects being
   dereferenced to obtain an object pointer.

   <p>In order to store references to regions of a dataset, the 
datatype should be
   H5T_REGION_OBJ. Note that a data element must be either an object 
reference or
   a region reference: these are different types and cannot be mixed within a
   single array.

<!-- NEW PAGE -->
   <p>A reference datatype cannot be divided for I/O, an element is read or
   written completely.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
   dataset=H5Dcreate(fid1,"Dataset3",H5T_STD_REF_OBJ,sid1,H5P_DEFAULT);

     /* Create reference to dataset */
     ret = H5Rcreate(&wbuf[0],fid1,"/Group1/Dataset1",H5R_OBJECT,-1);

     /* Create reference to dataset */
     ret = H5Rcreate(&wbuf[1],fid1,"/Group1/Dataset2",H5R_OBJECT,-1);

     /* Create reference to group */
     ret = H5Rcreate(&wbuf[2],fid1,"/Group1",H5R_OBJECT,-1);

     /* Create reference to named datatype */
     ret = H5Rcreate(&wbuf[3],fid1,"/Group1/Datatype1",H5R_OBJECT,-1);

     /* Write selection to disk */

   ret=H5Dwrite(dataset,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,wbuf);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 37</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
    rbuf = malloc(sizeof(hobj_ref_t)*SPACE1_DIM1);

   /* Read selection from disk */
  ret=H5Dread(dataset,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,rbuf);

     /* Open dataset object */
     dset2 = H5Rdereference(dataset,H5R_OBJECT,&rbuf[0]);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 38</span></td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>5.3 ENUM</h4>

   <p>The enum datatype implements a set of (name, value) pairs, similar
   to C/C++ enum.  The values are currently limited to integer dataype class.
   Each name can be the name of only one value, and each value can have only
   one name.  There can be up to 2^16 different names for a given enumeration.

   <p>The data elements of the ENUMERATION are stored according to the datatype,
   e.g., as an array of integers. Figure 39 shows an example of how to create
   an enumeration with five elements. The elements map symbolic names to
   2-byte integers (Table 23).</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
hid_t hdf_en_colors = H5Tcreate(H5T_ENUM, sizeof(short));
short val;
      H5Tenum_insert(hdf_en_colors, "RED",   (val=0,&val));
      H5Tenum_insert(hdf_en_colors, "GREEN", (val=1,&val));
      H5Tenum_insert(hdf_en_colors, "BLUE",  (val=2,&val));
      H5Tenum_insert(hdf_en_colors, "WHITE", (val=3,&val));
      H5Tenum_insert(hdf_en_colors, "BLACK", (val=4,&val));

     H5Dcreate(fileid,spaceid,hdf_en_colors,H5P_DEFAULT);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 39</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 23</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%">
         <p><span class=TableHead>Name</span></td>
     <td class="ColumnRightHdr" width="50%">
         <p><span class=TableHead>Value</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell">
         <p>RED</td>
     <td class="ColumnRightCell">
         <p>0</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell">
         <p>GREEN</td>
     <td class="ColumnRightCell">
     <p>1</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell">
         <p>BLUE</td>
     <td class="ColumnRightCell">
         <p>2</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell">
         <p>WHITE</td>
     <td class="ColumnRightCell">
         <p>3</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom">
         <p>BLACK</td>
     <td class="ColumnRightBottom"> <p>4</td>
   </tr>
</table>

<!-- NEW PAGE -->
   <p>Figure 40 shows how an array of eight values might be stored. 
Conceptually,
   the array is an array of symbolic names [BLACK, RED, WHITE, BLUE, 
…] (Figure 40a).
   These are stored as the values, i.e., as short integers. So, the 
first 2 bytes
   are the value associated with "BLACK", which is the number 4, and so on
   (Figure 40b).</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
       <table align="center" width="100%">
	    <tr>
		  <td align="center">a) Logical Data to be written 8 
(elements)</td>
		</tr>
		<tr>
		  <td align="center">
		    <table>
			  <tr>
			    <td width="50" align="center">Index</td>
				<td width="135" align="center">Name</td>
			  </tr>
			</table>
		    <table border="1">
			  <tr>
			    <td width="30" align="center">0</td>
				<td width="130" align="left">:BLACK</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">1</td>
				<td width="130" align="left">RED</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">2</td>
				<td width="130" align="left">WHITE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">3</td>
				<td width="130" align="left">BLUE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">4</td>
				<td width="130" align="left">RED</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">5</td>
				<td width="130" align="left">WHITE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">6</td>
				<td width="130" align="left">BLUE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">7</td>
				<td width="130" align="left">GREEN</td>
			  </tr>
			</table>
		  </td>
		</tr>
		<tr><td>&nbsp;</td></tr>
		<tr>
		  <td align="center"><img src="Images/Dtypes_fig40.JPG"></td>
		</tr>
		<tr>
		  <td align="center">b) The storage layout. Total 
size of the array
		    is 16 bytes, 2 bytes per element.
		  </td>
		</tr>
		<tr><td>&nbsp;</td></tr>

	  </table>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 40</span></td>
   </tr>
</table>

   <p>The order that members are inserted into an enumeration type is 
unimportant;
   the important part is the associations between the symbol names and 
the values.
   Thus, two enumeration datatypes will be considered equal if and only if both
   types have the same symbol/value associations and both have equal underlying
   integer datatypes. Type equality is tested with the H5Tequal() function.

<h4>5.4 Opaque</h4>

   <p>In some cases, a user may have data objects that should be stored and
   retrieved as blobs, with no attempt to interpret them.  For example,
   an application might wish to store an array of  encrypted certificates,
   which are 100 bytes long

   <p>While an arbitrary block of data may always be stored as bytes, 
characters,
   integers, or whatever, this might mislead programs about the 
meaning of the data.
   The opaque datatype defines data elements which are uninterpreted by HDF5.
   The opaque data may be labeled with H5Tset_tag, with a string that might be
   used by an application. For example, the encrypted certificates might have
   a tag to indicate the encryption and the certificate standard.

<!-- NEW PAGE -->
<h4>5.5 Bitfield</h4>

   <p>Some data is represented as bits, where the number of bits is not an
   integral byte and the bits are not necessarily interpreted as a 
standard type.
   Some examples might include readings from machine registers (e.g.,
   switch positions), a cloud mask, or data structures with several small
   integers that should be store in a single byte.

   <p>This data could be stored as integers, strings, or enumerations.
   However, these storage methods would likely have considerable wasted space.
   For example, storing a cloud mask with one byte per value would use 8
   times the space of a packed array of bits. Similarly, the status of an inst

   <p>The HDF5 bitfield dataype class defines a data element that is a
   contiguous sequence of bits, which are stored on disk in a packed array.
   The programming model is the same as for unsigned integers:  the dataype
   object is created by copying a predefined datatype, and then the
   precision, offset, and padding are set.

<h4>5.6 Time</h4>

   <p>The HDF5 time datatype defines storage layout for various date and
   time standards. Currently, only Unix "time" and "timeval" structs are
   supported. The H5T_UNIX_D32BE (LE) defines storage for 4 bytes
   (sufficient for the time struct), H5T_UNIX_D64BE (LE) is sufficient
   for timeval.  The data is treated as a single opaque value.</p>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Fvalues">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="Fvalues">
<h3 class=pagebefore>6. Fill Values</h3>
</a>

   <p>The "fill value" for a dataset is the specification of the default value
   assigned to data elements that have not yet been written. In the case of a
   dataset with an atomic datatype, the fill value is a single value of the
   appropriate datatype, such as '0' or '-1.0'. In the case of a dataset with
   a composite datatype, the "fill value" is a single data element of the
   appropriate type. For example, for an array or compound datatype,
   the "fill value" is a single data element with values for all the
   component elements of the array or compound datatype.

   <p>The fill value is set (permanently) when the dataset is created.
   The fill value is set in the dataset creation properties
<!-- editingComment
   <span class="editingComment">[ [ [
   (see chapter ??)
   ] ] ]</span>
-->
   in the <code>H5Dcreate</code> call. Note that the <code>H5Dcreate</code>
   call must also include the datatype of the dataset, and the value provided
   for the fill value will be interpreted as a single element of this datatype.
   Figure 41 shows example code which creates a dataset of integers with fill
   value -1. Any unwritten data elements will be set to -1.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
    hid_t       plist_id;
    int filler;

    filler = -1;
    plist_id = H5Pcreate(H5P_DATASET_CREATE);
    H5Pset_fill_value(plist,H5T_NATIVE_INT,&filler);

    /* Create the dataset with filel value '-1'. */
    dataset_id = H5Dcreate(file_id, "/dset", H5T_STD_I32BE, 
dataspace_id, plist);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 41</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
     typedef struct s1_t {
	int    a;
	char  b;
	double c;
     } s1_t;
     s1_t       filler;

     s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

     filler.a = -1;
     filler.b = '*';
     filler.c = -2.0;

     plist_id = H5Pcreate(H5P_DATASET_CREATE);
     H5Pset_fill_value(plist_id, s1_tid, &filler);

     /* Create the dataset with fill value (-1, '*', -2.0). */
     dataset = H5Dcreate(file, DATASETNAME, s1_tid, space, plist_id);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 42</span></td>
   </tr>
</table>
<br>

   <p>Figure 42 shows how to create a "fill value" for a compound datatype.
   The procedure is the same as the previous example, except the filler
   must be a structure with the correct fields. Each field is initialized
   to the desired fill value.

<!-- NEW PAGE -->
   <p>The fill value for a dataset can be retrieved by reading the dataset
   creation properties of the dataset, and then reading the fill value with
   <code>H5Pget_fill_value</code>. The data will be read into memory using
   the storage layout specified by the datatype. This transfer will convert
   data in the same way as <code>H5Dread</code>.
<!-- editingComment
   <span class="editingComment">[ [ [
   (See section ? below).
   ] ] ]</span>
-->
   Figure 43 shows how to get the fill value from the dataset created in
   Figure 41 above.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
    hid_t plist2;
    int filler;

    dataset_id = H5Dopen(file_id, "/dset" );
    plist2 = H5Dget_create_plist(dataset_id);

    H5Pget_fill_value(plist, H5T_NATIVE_INT, &filler);

    /* filler has the fill value, '-1' */
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 43</span></td>
   </tr>
</table>

   <p>A similar procedure is followed for any datatype. Figure 45 shows how to
   read the fill value created in Figure 42. Note that the program must pass an
   element large enough to hold a fill value of the datatype indicated by the
   argument to <code>H5Pget_fill_value</code>.  Also, the program must 
understand
   the datatype in order to interpret its components. This may be difficult to
   determine without knowledge of the application that created the dataset.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
     char *       fillbuf;
     int sz;
     dataset = H5Dopen( file, DATASETNAME);

     s1_tid = H5Dget_type(dataset);

     sz = H5Tget_size(s1_tid);

     fillbuf = (char *)malloc(sz);

     plist_id = H5Dget_create_plist(dataset);

     H5Pget_fill_value(plist_id, s1_tid, fillbuf);

     printf("filler.a: %d\n",((s1_t *) fillbuf)->a);
     printf("filler.b: %c\n",((s1_t *) fillbuf)->b);
     printf("filler.c: %f\n",((s1_t *) fillbuf)->c);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 44</span></td>
   </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="CCDtypes">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="CCDtypes">
<h3 class=pagebefore>7. Complex Combinations of Datatypes</h3>
</a>

<h4>7.1</h4>

   <p>Several composite datatype classes define collections of other datatypes,
   including other composite datatypes.  In general, a datatype can be nested
   to any depth, with any combination of datatypes.

   <p>For example, a compound datatype can have members that are other compound
   datatypes, arrays, VL datatypes.  An array can be an array of array,
   an array of compound, or an array of VL.  And a VL datatype can be a
   variable length array of compound, array, or VL datatypes.

   <p>These complicated combinations of datatypes form a logical tree,
   with a single root datatype, and leaves which must be atomic datatypes
   (predefined or user-defined). Figure 45 shows an example of a logical
   tree describing a compound datatype constructed from different datatypes.

   <p>Recall that the datatype is a description of the layout of storage.
   The complicated compound datatype is constructed from component datatypes,
   each of which describe the layout of part of the storage. Any datatype can
   be used as a component of a compound datatype, with the following
   restrictions:

   <ol>
       <li>No byte can be part of more than one component datatype (i.e., the
           fields cannot overlap within the compound datatype).<br>
       <li>The total size of the components must be less than or equal to the
           total size of the compound datatype.
   </ol>

   <p>These restrictions are essentially the rules for C structures and similar
   record types familiar from programming languages.  Multiple typing, such as a
   C union, is not allowed in HDF5 datatypes.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center" valign="middle">
     <img src="Images/Dtypes_fig45.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 45</span></td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>7.2 Creating a complicated compound datatype</h4>

   <p>To construct a complicated compound datatype, each component is 
constructed,
   and then added to the enclosing datatype description.  Figure 46 shows some
   example code to create a compound datatype with four members:

   <ul>
       <li>"T1", a compound datatype with three members
       <li>"T2", a compound datatype with two members
       <li>"T3", a one-dimensional array of integers
       <li>"T4", a string
   </ul>

   <p>This datatype is shown as a logical tree in Figure 47, the output of the
   <em>h5dump</em> utility is shown in Figure 48.

   <p>Each datatype is created as a separate datatype object. Figure 49 shows
   the storage layout for the four individual datatypes. Then the dataypes are
   inserted into the outer datatype at an appropriate offset. Figure 50 shows
   the resulting storage layout. The combined record is 89 bytes long.

   <p>The Dataset is created using the combined compound datatype. The dataset
   is declared to be a 4 by 3 array of compound data.  Each data element is an
   instance of the 89-byte compound datatype. Figure 51 shows the layout of
   the dataset, and expands one of the elements to show the relative position
   of the component data elements.

   <p>Each data element is a compound datatype, which can be written or read
   as a record, or each field may be read or written individually. The first
   field ("T1") is itself a compound datatype with three fields ("T1.a",
   "T1.b", and "T1.c"). "T1" can be read or written as a record, or individual
   fields can be accessed. Similarly, the second filed is a compound datatype
   with two fields ("T2.f1", "T2.f2").

   <p>The third field ("T3") is an array datatype.  Thus, "T3" should be
   accessed as an array of 40 integers. Array data can only be read or
   written as a single element, so all 40 integers must be read or
   written to the third field. The fourth field ("T4") is a single
   string of length 25.</p>

<!-- editingComment
   <span class="editingComment">[ [ [
   Does the bolding in the following code make any sense?
   Is it referred to anywhere?
   (Lines 12 and 14)
   ] ] ]</span>
-->
<!-- NEW PAGE -->
<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
     typedef struct s1_t {
	int    a;
	char  b;
	double c;
     } s1_t;

     typedef struct s2_t {
	float f1;
	float f2;
     } s2_t;
     <strong>hid_t      s1_tid, s2_tid, s3_tid, s4_tid, s5_tid;</strong>

     <strong>/* Create a datatype for s1 */</strong>
     s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

     /* Create a data type for s2. *.
     s2_tid = H5Tcreate (H5T_COMPOUND, sizeof(s2_t));
     H5Tinsert(s2_tid, "f1", HOFFSET(s2_t, f1), H5T_NATIVE_FLOAT);
     H5Tinsert(s2_tid, "f2", HOFFSET(s2_t, f2), H5T_NATIVE_FLOAT);

     /* Create a datatype for an Array of integers */
     s3_tid = H5Tarray_create(H5T_NATIVE_INT, RANK, dim, NULL);

     /* Create a data type for a String of 25 characters */
     s4_tid = H5Tcopy(H5T_C_S1);
     H5Tset_size(s4_tid, 25);

     /*
      * Create a compound datatype composed of one of each of these
      *  types.
      * The total size is the sum of the size of each.
      */

     sz = H5Tget_size(s1_tid) + H5Tget_size(s2_tid) + H5Tget_size(s3_tid)
          + H5Tget_size(s4_tid);

     s5_tid = H5Tcreate (H5T_COMPOUND, sz);

     /* insert the component types at the appropriate offsets */

     H5Tinsert(s5_tid, "T1", 0, s1_tid);
     H5Tinsert(s5_tid, "T2", sizeof(s1_t), s2_tid);
     H5Tinsert(s5_tid, "T3", sizeof(s1_t)+sizeof(s2_t), s3_tid);
     H5Tinsert(s5_tid, "T4", (sizeof(s1_t) +sizeof(s2_t)+
             H5Tget_size(s3_tid)), s4_tid);

     /*
      * Create the dataset with this datatype.
      */
     dataset = H5Dcreate(file, DATASETNAME, s5_tid, space, H5P_DEFAULT);
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       46</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center" valign="middle">
     <img src="Images/Dtypes_fig47.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 47</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
         DATATYPE  H5T_COMPOUND {
          H5T_COMPOUND {
             H5T_STD_I32LE "a_name";
             H5T_STD_I8LE "b_name";
             H5T_IEEE_F64LE "c_name";
          } "T1";
          H5T_COMPOUND {
             H5T_IEEE_F32LE "f1";
             H5T_IEEE_F32LE "f2";
          } "T2";
          H5T_ARRAY { [10] H5T_STD_I32LE } "T3";
          H5T_STRING {
             STRSIZE 25;
             STRPAD H5T_STR_NULLTERM;
             CSET H5T_CSET_ASCII;
             CTYPE H5T_C_S1;
          } "T4";
       }
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 48</span></td>
   </tr>
</table>

<br>
<!-- NEW PAGE -->

<table x-use-null-cells
		width=75%
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center"><br>

	  <table align="center" border="0" width="100%">
	    <tr>
		  <td valign="middle" align="left">a) Compound type 
's1_t', size 16 bytes.</td>
		</tr>
		<tr><td>

	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		</tr>
	  </table>

	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" 
width="25%"><code>Byte 8</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 9</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 10</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 11</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
	  </table>

	  </td></tr>
	  <tr>
	    <td valign="middle" align="left">&nbsp;<br>b) Compound 
type 's2_t', size 8 bytes.</td>
	  </tr>

	  <tr><td>

	  <table border="1" align="center" width="100%">
	    <tr>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		</tr>
       </table>

	  </td></tr>
       <tr>
	    <td valign="middle" align="left">&nbsp;<br>c) Array type 
's3_tid', 40 integers, total size 40 bytes.</td>
	  </tr>

	  <tr><td>

	  <table border="1" align="center" width="100%">
	    <tr>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000001</code></td>
		</tr>
       </table>

	  <table align="center" width="100%">
		<tr>
		  <td align="center" colspan="4">&nbsp;...&nbsp;<br>&nbsp;</td>
		</tr>
	  </table>

	  <table border="1" align="center" width="100%">
         <tr>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 36</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 37</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 38</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 39</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00001010</code></td>
		</tr>
	  </table>

	  </td></tr>
       <tr>
	    <td valign="middle" align="left">&nbsp;<br>d) String type 
's4_tid', size 25 bytes.</td>
	  </tr>
	  <tr><td>

	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>'a'</code></td>
		  <td valign="middle" align="center"><code>'b'</code></td>
		  <td valign="middle" align="center"><code>'c'</code></td>
		  <td valign="middle" align="center"><code>'d'</code></td>
		</tr>
	  </table>

	  <table align="center" width="100%">
		<tr>
		  <td align="center" colspan="4">&nbsp;...&nbsp;<br>&nbsp;</td>
		</tr>
	  </table>

	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" 
width="25%"><code>Byte 24</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 25</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 26</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 27</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		</tr>
	  </table>

	  </td></tr>
	  </table>

	  </td></tr>
		<tr>
           <td align=center class="fullImgTableCapCell">
           <span class=figurenumber>Figure 49</span></td>
		</tr>
	</table>
<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig50.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 50</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
       <table align="center" width="100%">
         <tr>
           <td align="center" colspan="2">
	     <img src="Images/Dtypes_fig51.jpg"></td>
         </tr>
       </table>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 51</span></td>
   </tr>
</table>

<!-- NEW PAGE -->
<h4>7.3 Analyzing and Navigating a Compound Datatype</h4>

   <p>A complicated compound datatype can be analyzed piece by piece, 
to discover
   the exact storage layout. In the example above, the outer datatype 
is analyzed
   to discover that it is a compound datatype with 4 members. Each member is
   analyzed in turn to construct a complete map of the storage layout.

   <p>Figure 52 shows an example of code that partially analyses a nested
   compound datatype. The name and overall offset and size of the component
   datatype is discovered, and then it's type is analyzed, depending on the
   datatype class. Through this method, the complete storage layout can be
   discovered.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
     <pre><code>
     s1_tid = H5Dget_type(dataset);

     if (H5Tget_class(s1_tid) == H5T_COMPOUND) {
         printf("COMPOUND DATATYPE {\n");
         sz = H5Tget_size(s1_tid);
         nmemb = H5Tget_nmembers(s1_tid);
         printf("  %d bytes\n",sz);
         printf("  %d members\n",nmemb);
         for (i =0; i &lt; nmemb; i++) {
         	s2_tid = H5Tget_member_type(s1_tid,i);
         	if (H5Tget_class(s2_tid) == H5T_COMPOUND) {
         		/* recursively analyze the nested type. */

         	} else if (H5Tget_class(s2_tid) == H5T_ARRAY) {
         		sz2 = H5Tget_size(s2_tid);
         		printf("  %s: NESTED ARRAY DATATYPE offset %d 
size %d  {\n",
                   H5Tget_member_name(s1_tid,i),
                   H5Tget_member_offset(s1_tid,i),
                    sz2);
                   H5Tget_array_dims(s2_tid,dim,NULL);
                    s3_tid = H5Tget_super(s2_tid);
                   /* Etc., analyze the base type of the array */
         	} else {
                   /* analyze a simple type */
                   printf("    %s: type code %d offset %d size %d\n",
                                 H5Tget_member_name(s1_tid,i),
                                 H5Tget_class(s2_tid),
                                 H5Tget_member_offset(s1_tid,i),
                                 H5Tget_size(s2_tid));
         	}
           <strong>/* and so on…. */</strong>
     </code></pre>
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 52</span></td>
   </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="LCDtypeObj">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="LCDtypeObj">
<h3 class=pagebefore>8. Life Cycle of the Datatype Object</h3>
</a>

   <p>Applications programs access HDF5 datatypes through handles, 
which are obtained
   by creating a new datatype, or copying or opening an existing datatype. The
   handle can be used until it is closed, or the program exits (Figure 53a,b).
   By default, a datatype object is <em>transient</em>, and disappears when it
   is closed.

   <p>When a dataset or attribute is created (<code>H5Dcreate</code> 
or <code>H5Acreate</code>),
   its datatype object is stored in the HDF5 file as part of the HDF5 
object (the
   dataset or attribute) (Figure 53c). Once an object created, its 
datatype cannot
   be changed or deleted. The datatype can be accessed by calling 
<code>H5Dget_type</code>,
   <code>H5Aget_type</code>, <code>H5Tget_super</code>, or 
<code>H5Tget_member_type</code>
   (Figure 53d). These calls return a handle to a <em>transient</em> copy of the
   datatype of the dataset or attribute unless the datatype is a named datatype
   as explained below.

   <p>Note that when an object is created, the stored datatype is a 
copy of the transient
   datatype. If two objects are created with the same datatype, the information
   is stored in each object, with the same effect as if two different datatypes
   were created and used.

   <p>A transient datatype can be stored (<code>H5Tcommit</code>) in 
the HDF5 file
   as an independent, named object, called a named datatype (Figure 
53e). Subsequently,
   when a named datatype is opened with <code>H5Topen</code> (Figure 53f), or is
   obtained with <code>H5Tget_type</code> or similar call (Figure 
53k), the return
   is a handle to a transient copy of the stored datatype. The handle 
can be used
   in the same way as other datatype handles, except the named datatype cannot
   be modified. When a named datatype is copied with <code>H5Tcopy</code>, the
   return is a new, modifiable, transient datatype object (Figure 53f).

   <p>When an object is created using a named datatype 
(<code>H5Dcreate</code>, <code>H5Acreate</code>),
   the stored datatype is used without copying it to the object (Figure 53j). In
   this case, if multiple objects are created using the same named 
datatype, they
   all share the exact same datatype object. This saves space and 
makes clear that
   the datatype is shared. Note that a named datatype can be shared by objects
   within the same HDF5 file, but not by objects in other files.

   <p>A named datatype can be deleted from the file by calling 
<code>H5Gunlink</code>
   (Figure 53i).  If one or more objects are still using the datatype, the named
   datatype cannot be accessed with H5Topen, but will not be removed 
from the file
   until it is no longer used. The <code>H5Tget_type</code> and 
similar calls will
   return a transient copy of the datatype.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig53.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       53</span></td>
   </tr>
</table>

   <p>Transient datatypes are initially <em>modifiable</em>, its 
properties can be
   changed. Note that when a datatype is copied or when it is written 
to the file
   (when an object is created) or the datatype is used to create a 
composite datatype,
   a copy of the current state of the datatype is used. If the datatype is then
   modified, the changes have no effect on datasets, attributes, or 
datatypes that
   have already been created.

   <p>A transient datatype can be made <em>read-only</em> 
(<code>H5Tlock</code>),
   after which it can no longer be changed. Note that the datatype is 
still transient,
   and otherwise does not change. A datatype that is 
<em>immutable</em> is <em>read-only</em>
   but cannot be closed except when the entire library is closed.
   The predefined types such as <code>H5T_NATIVE_INT</code> are 
<em>immutable transient</em>
   types.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig54.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       54</span></td>
   </tr>
</table>

   <p>To create two or more datasets that share a common datatype,
   one first commits the datatype, giving it a name,
   then uses that datatype to create the datasets. </p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
  hid_t t1 = ...some transient type...;
  H5Tcommit (file, "shared_type", t1);
  hid_t dset1 = H5Dcreate (file, "dset1", t1, space, H5P_DEFAULT);
  hid_t dset2 = H5Dcreate (file, "dset2", t1, space, H5P_DEFAULT);


  hid_t dset1 = H5Dopen (file, "dset1");
  hid_t t2 = H5Dget_type (dset1);
  hid_t dset3 = H5Dcreate (file, "dset3", t2, space, H5P_DEFAULT);
  hid_t dset4 = H5Dcreate (file, "dset4", t2, space, H5P_DEFAULT);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell"> <span 
class=figurenumber>Figure
       55</span></td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
     <td colspan="2" align="center" valign="bottom"><h4>Table 24</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr" width="50%"> <p><span 
class=TableHead>Function</span></td>
     <td class="ColumnRightHdr" width="50%"> <p><span 
class=TableHead>Description</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>hid_t H5Topen (hid_t location, const
         char *name)</code></td>
     <td class="ColumnRightCell"> <p>A named datatype can be opened by calling
         this function, which returns a datatype identifier. The 
identifier should
         eventually be released by calling H5Tclose() to release resources. The
         named datatype returned by this function is read-only or a 
negative value
         is returned for failure. The location is either a file or 
group identifier.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p><code>herr_t H5Tcommit (hid_t 
location, const
         char *name, hid_t type)</code></td>
     <td class="ColumnRightCell"> <p>A transient datatype (not immutable) can be
         committed to a file and turned into a named datatype by 
calling this function.
         The location is either a file or group identifier and when 
combined with
         name refers to a new named datatype.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p><code>htri_t H5Tcommitted (hid_t 
type)</code></td>
     <td class="ColumnRightBottom"> <p>A type can be queried to determine if it
         is a named type or a transient type. If this function returns 
a positive
         value then the type is named (that is, it has been committed perhaps by
         some other application). Datasets which return committed datatypes with
         H5Dget_type() are able to share the datatype with other datasets in the
         same file.</td>
   </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Dtransfer">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="Dtransfer">
<h3 class=pagebefore>9. Data Transfer: Datatype Conversion and Selection</h3>
</a>

   <p>When data is transferred (write or read) the storage layout of the data
   elements may be different. For example, an integer might be stored on disk
   in big endian byte order, and read into memory with little endian byte order.
   In this case, each data element will be transformed by the HDF5 library
   during the data transfer.

   <p>The conversion of data elements is controlled by specifying datatype of
   the source and specifying the intended datatype of the destination.
   The storage format on disk is the datatype specified when the dataset
   is create. The datatype of memory must be specified in the library call.

   <p>In order to be convertible, the datatype of the source and destination
   must have the same datatype class. Thus, integers can be converted to other
   integers, and floats to other floats, but integers cannot (yet) be converted
   to floats. For each atomic datatype class, the possible conversions 
are defined.

   <p>Basically, any datatype can be converted to another datatype of the same
   datatype class. The HDF5 library automatically converts all properties.
   If the destination is too small to hold the source value then an overflow
   or underflow exception occurs. If a handler is defined, with
   <code>H5Tset_overflow()</code>,
<!-- editingComment
   <span class="editingComment">[ [ [
   (see Chapter??)
   ] ] ]</span>
-->
   it will be called. Otherwise,
   a default action will be performed. Table 25 summarizes the default 
action.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
   <tr valign="bottom">
   <td colspan="3" align="center"><h4>Table 25</h4></td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftHdr">
         <p><span class=TableHead>Datatype Class</span></td>
     <td class="ColumnHdr">
         <p><span class=TableHead>Possible Exceptions</span></td>
     <td class="ColumnRightHdr">
         <p><span class=TableHead>Default Action</span></td>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Integer</td>
     <td class="ColumnCell"> <p>size, offset, pad</td>
     <td class="ColumnRightCell">
     &nbsp;
<!-- editingComment
   <span class="editingComment">[ [ [
      <p>?
   ] ] ]</span>
-->
     </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>Float</td>
     <td class="ColumnCell"> <p>size, offset, pad, ebits, etc.</td>
     <td class="ColumnRightCell">
     &nbsp;
<!-- editingComment
   <span class="editingComment">[ [ [
      <p>?
   ] ] ]</span>
-->
     </td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftCell"> <p>String</td>
     <td class="ColumnCell"> <p>size</td>
     <td class="ColumnRightCell"> <p>Truncates, zero terminate if required.</td>
   </tr>
   <tr valign=top>
     <td class="ColumnLeftBottom"> <p>Enumeration</td>
     <td class="ColumnBottom"> <p>No field</td>
     <td class="ColumnRightBottom"> <p>All Bits set</td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
         <p>When data is transferred (write or read) the format of the 
data elements
	may be transformed between the source and the destination, according to
	the datatypes of the source and destination.</td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell">
         <p>In order to be convertible, the datatype of the source and
	destination must have the same datatype class.</td>
   </tr>
</table>
<br>

   <p>For example, when reading data from a dataset, the source datatype is the
   datatype set when the dataset was created, and the destination datatype is
   the description of the storage layout in memory, which must be specified in
   the <em>H5Dread</em> call. Figure 56 shows an example of reading a dataset
   of 32-bit integers. Figure 57 shows the data transformation
   that is performed.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
   /* Stored as H5T_STD_BE32 */
   /* Use the native memory order in the destination */
   mem_space = H5Tcopy(H5T_NATIVE_INT);
   status = H5Dread(dataset_id, mem_type_id, mem_space_id,
                   file_space_id,  xfer_plist_id,  buf );
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 56</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width="500"
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td align="center" class="fullImgTableImgCell">

	<table align="center" width="500px">
	  <tr><td>

	  <table align="left">
	    <tr>
		  <td align="left">Source Datatype: H5T_STD_BE32</td>
		</tr>
	  </table>

	  </td></tr>
	  <tr><td>

	  <table align="left" border="1" width="100%">
	    <tr>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>dddddddd</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>wwwwwwww</code></td>
		  <td valign="middle" align="center"><code>xxxxxxxx</code></td>
		  <td valign="middle" align="center"><code>yyyyyyyy</code></td>
		  <td valign="middle" align="center"><code>zzzzzzzz</code></td>
		</tr>
	  </table>

	  </td></tr>
	  <tr>
	    <td>.&nbsp;.&nbsp;.&nbsp;.</td>
	  </tr>
	  <tr><td>

	  <table align="center" width="100%">
	    <tr>
		  <td width="45%">&nbsp;</td>
		  <td width="10%" align="center"><img 
src="Images/Dtypes_fig57_arrow.jpg"></td>
		  <td width="45%" align="left">Automatically byte 
swapped<br> during the H5Dread</td>
		</tr>
	  </table>

	  </td></tr>
	  <tr><td>

       <table align="left">
	    <tr>
		  <td align="left">Destination Datatype: H5T_STD_LE32</td>
		</tr>
	  </table>

       </td></tr>
	  <tr><td>

	  <table align="left" border="1" width="100%">
	    <tr>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" 
width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>dddddddd</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>xxxxxxxx</code></td>
		  <td valign="middle" align="center"><code>wwwwwwww</code></td>
		  <td valign="middle" align="center"><code>zzzzzzzz</code></td>
		  <td valign="middle" align="center"><code>yyyyyyyy</code></td>
		</tr>
	  </table>

       </td></tr>
	  <tr>
	    <td>.&nbsp;.&nbsp;.&nbsp;.</td>
	  </tr>
	  <tr><td>
	</table>

       </td></tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
       <span class=figurenumber>Figure 57</span>
     </td>
   </tr>
</table>
<br>

   <p>One thing to note in Figure 56 is the use of the predefined 
native datatype,
   H5T_NATIVE_INT. Recall that in this example, the data was stored as a 4-bytes
   in big endian order. The application wants to read this data into an array of
   integers in memory. Depending on the system, the storage layout of memory
   might be either big or little endian, so the data may need to be transformed
   on some platforms and not on others.  The H5T_NATIVE_INT type is set by the
   HDF5 library to be the correct type to describe the storage layout of the
   memory on the system. Thus, the code in Figure 56 will work correctly on any
   platform, performing a transformation when needed.

   <p>There are predefined native types for most atomic datatypes, which can be
   combined in composite datatypes. In general, the predefined native datatypes
   should always be used for data stored in memory.</p>

<!-- FOR USE WITH ELECTRONIC VERSION ---------------------------------->
<table x-use-null-cells
                 align=right
		width=240
		cellspacing=0
		class="tocTable">
   <tr valign=top>
     <td class="tocTableHeaderCell">
         Predefined native datatypes describe the
	storage properties of memory.</td>
   </tr>
</table>
<!-- FOR USE WITH ELECTRONIC VERSION --------------------------------->

<!-- FOR USE WITH PRINT VERSION --------------------------------------
<table x-use-null-cells
                 align=center
		width=240
		cellspacing=0
		class="tocTable">
   <tr valign=top>
     <td class="tocTableHeaderCell">
         Predefined native datatypes describe the
	storage properties of memory.</td>
   </tr>
</table>
<!-- FOR USE WITH PRINT VERSION -------------------------------------->

   <br>
   <p>For composite datatypes, the component atomic datatypes will be converted.
   For a variable length datatype, the source and destination must 
have compatible
   base datatypes. For a fixed-size string datatype, the length and padding of
   the strings will be converted. Variable length strings are converted as
   variable length datatypes.

   <p>For an array datatype, the source and destination must have the same rank
   and dimensions, and the base datatype must be compatible.  For example an
   array datatype of 4 x 3 32-bit big endian integers can be transferred to an
   array datatype of 4 x 3 little endian integers, but not to a 3 x 4 array.

<!-- NEW PAGE -->
   <p>For an enumeration datatype, data elements are converted by matching the
   symbol names of the source and destination Datatype. Figure 58 
shows an example
   of how two enumerations with the same names and different values would be
   converted. The value '2' in the source dataset would be converted
   to '0x0004' in the destination.

   <p>If the source data stream contains values which are not in the domain of
   the conversion map then an overflow exception is raised within the 
library.</p>

<table x-use-null-cells
		width=300
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center"><br>

	<table border="0">
	  <tr>
	    <td 
width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">RED</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">RED</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	  <tr>
	    <td 
width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">GREEN&nbsp;&nbsp;</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">&nbsp;&nbsp;GREEN</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">BLUE</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">BLUE</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	  <tr>
	    <td 
width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">WHITE</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">WHITE</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	  <tr>
	    <td 
width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">BLACK&nbsp;&nbsp;</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">&nbsp;&nbsp;BLACK</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	</table>
	</td></tr>
	<tr>
       <td align=center class="fullImgTableCapCell">
         <span class=figurenumber>Figure 58</span></td>
     </tr>
</table>


   <p>For compound datatypes, each field of the source and destination 
datatype is
   converted according to its type. The name and order of the fields must be the
   same in the source and the destination but the source and 
destination may have
   different alignments of the fields, and only some of the
   fields might be transferred.

   <p>Figure 59 shows the compound datatypes shows sample code to create a
   compound datatype with the fields aligned on word boundaries (s1_tid)
   and with the fields packed (s2_tid). The former is suitable as a description
   of the storage layout in memory, the latter would give a more compact store
   on disk. These types can be used for transferring data, with 
<code>s2_tid</code>
   used to create the dataset, and <code>s1_tid</code> used as
   the memory datatype.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
      typedef struct s1_t {
        int    a;
        char  b;
        double c;
     } s1_t;

           s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

     s2_tid = H5Tcopy(s1_tid);
     H5Tpack(s2_tid);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 59</span></td>
   </tr>
</table>

   <p>When the data is transferred, the fields within each data element will be
   aligned according to the datatype specification. Figure 60 shows how one data
   element would be aligned in memory and on disk. Note that the size and byte
   order of the elements might also be converted during the transfer.

   <p>It is also possible to transfer some of the fields of a compound 
datatypes.
   Continuing the example, from Figure 59, Figure 61 shows a compound datatype
   that selects the first and third fields of the <code>s1_tid</code>.
   The second datatype can be used as the memory datatype, in which case data
   is read from or written to these two fields, while skipping the middle field.
   Figure 62 shows the data for two data elements.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig60.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 60</span></td>
   </tr>
</table>

<br>

<!-- NEW PAGE -->
<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell"> <pre><code>
      typedef struct s1_t {
        int    a;
        char  b;
        double c;
     } s1_t;

     typedef struct s2_t {   /* two fields from s1_t */
        int    a;
        double c;
     } s2_t;

           s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s1_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "b_name", HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

     s2_tid = H5Tcreate (H5T_COMPOUND, sizeof(s2_t));
     H5Tinsert(s1_tid, "a_name", HOFFSET(s2_t, a), H5T_NATIVE_INT);
     H5Tinsert(s1_tid, "c_name", HOFFSET(s2_t, c), H5T_NATIVE_DOUBLE);
     </code></pre> </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 61</span></td>
   </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                 class="fullImgTable"
		align="center">
   <tr valign=top>
     <td class="fullImgTableImgCell" align="center">
     <img src="Images/Dtypes_fig62.JPG">
     </td>
   </tr>
   <tr>
     <td align=center class="fullImgTableCapCell">
     <span class=figurenumber>Figure 62</span></td>
   </tr>
</table>
</dir>
<!-- NEW PAGE -->
</body>
</html>


