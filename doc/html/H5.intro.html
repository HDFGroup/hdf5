<HTML>
<HEAD>
<TITLE>Introduction to HDF5</TITLE>

<!-- #BeginLibraryItem "/ed_libs/styles_Intro.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->

<link href="ed_styles/IntroElect.css" rel="stylesheet" type="text/css">
<!-- #EndLibraryItem --></HEAD>

<BODY  bgcolor="#FFFFFF">


<!-- #BeginLibraryItem "/ed_libs/NavBar_Intro.lbi" -->
<hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://www.hdfgroup.org/HDF5/doc1.6/UG/UG_frame.html">HDF5 User Guide</a>&nbsp;
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
<a href="RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;<br>
<a href="index.html">Other HDF5 documents and links</a>&nbsp;
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><a name="Intro-Intro">
<h1 ALIGN="CENTER">Introduction to HDF5</h1></a>

</FONT><FONT FACE="Times"><P>This is an introduction to the HDF5 data model and programming model.  Being a <I>Getting Started</I> or <I>QuickStart</I> document, this </FONT><I>Introduction to HDF5</I> <FONT FACE="Times">is intended to provide enough information for you to develop a basic understanding of how HDF5 works and is meant to be used. Knowledge of the current version of HDF will make it easier to follow the text, but it is not required.  More complete information of the sort you will need to actually use HDF5 is available in <A HREF="index.html">the HDF5 documentation</FONT></a><FONT FACE="Times">.  Available documents include the following:

<UL>
</FONT><LI><A HREF="H5.user.html"><I>HDF5 User&#146s Guide</I></A>.  Where appropriate, this <I>Introduction</I> will refer to specific sections of the <I>User&#146s Guide</I>.
<LI><I><A HREF="RM_H5Front.html">HDF5 Reference Manual</I></A>.</UL>

<FONT FACE="Times"><P>Code examples are available in the source code tree when you install HDF5.  

<UL>
</FONT><LI>The directories <code>hdf5/examples</code>,
<code>hdf5/doc/html/examples/</code>, and 
<code>hdf5/doc/html/Tutor/examples/</code> contain the examples 
used in this document.
<LI>The directory<FONT FACE="Courier" SIZE=2> hdf5/test</FONT> contains the development tests used by the HDF5 developers.  Since these codes are intended to fully exercise the system, they provide more diverse and sophisticated examples of what HDF5 can do.</UL>

<a name="Intro-TOC">
<hr>
<center>
<table border=0 width=90%>
<tr><th colspan=3>Table of Contents</th></tr></a>
<tr><td valign=top align=left width=42%>

    <a href="#Intro-Intro">Introduction to HDF5</a><p>
    <a href="#Intro-WhatIs">1. What Is HDF5?</a><br>
        <font size=-1>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-Why">Why HDF5?</a><br>
        <!--
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-Limits">Limitations of the 
              Current Release</a><br>
        -->
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-Changes">Changes in the 
              Current Release</a><p>
        </font>
    <a href="#Intro-FileOrg">2. HDF5 File Organization and</a></br>
        <font size=-1>&nbsp;&nbsp&nbsp;&nbsp;</font><a href="#Intro-FileOrg">Data Model</a><br>
        <font size=-1>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-OGroups">HDF5 Groups</a><br>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-ODatasets">HDF5 Datasets</a><br>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-OAttributes">HDF5 Attributes</a><br>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-FileTech">The File as Written to Media</a><p>
        </font>
    <a href="#Intro-APIs">3. The HDF5 API</a><br>
        <font size=-1>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-NameConv">Naming 
              Conventions</a><br>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-Include">Include Files</a><br>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-ProgModels">Programming 
              Models</a><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateFile">Creating an HDF5 file</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMDiscard">Discarding objects</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMWriteNew">Writing a dataset to a 
              new file</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMGetInfo">Getting information about 
              a dataset</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMRdWrPortion">Reading/writing a portion of 
              a dataset</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMSelectHyper">Selecting hyperslabs</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMSelectPoints">Selecting of independent 
              points</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateVariableLength">Creating 
              variable-length datatypes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateArray">Creating array datatypes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateCompound">Creating compound 
              datatypes</A>

</td><td width=6%>&nbsp;&nbsp;</td><td valign=top align=left width=42%>

    <a href="#Intro-APIs">3. The HDF5 API</a> <i>(continued)</i><br>
        <font size=-1>
        &nbsp;&nbsp&nbsp;&nbsp;<a href="#Intro-ProgModels">Programming 
              Models</a> <i>(continued)</i><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateExtendible">Creating/writing extendible 
                 and</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMCreateExtendible">chunked datasets</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMWorkGroups">Working with groups</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMWorkAttributes">Working with attributes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMWorkRefObjects">Working with references to 
              objects</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="#Intro-PMWorkRefRegions">Working with references to 
                 dataset</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
               <A href="#Intro-PMWorkRefRegions">regions</A><p>
        </font>
    <a href="Intro/IntroExamples.html" 
       target="ExampleWin">Introduction to HDF5 -- Example Codes</a><br>
        <font size=-1>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#CreateExample" 
                 target="ExampleWin">1: Creating and writing a dataset</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#CheckAndReadExample" 
                 target="ExampleWin">2. Reading a hyperslab</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#WriteSelected" 
                 target="ExampleWin">3. Writing selected data</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#VariableLength" 
                 target="ExampleWin">4. Working with variable-length</A><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#VariableLength"
                  target="ExampleWin">datatypes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#Array" 
                 target="ExampleWin">5. Working with array datatypes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#Compound" 
                 target="ExampleWin">6. Working with compound datatypes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#CreateExtendWrite" 
                 target="ExampleWin">7. Creating and writing an 
                 extendible</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#CreateExtendWrite" 
                 target="ExampleWin">dataset</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#ReadExtended" 
                 target="ExampleWin">8. Reading data</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#CreateGroups" 
                 target="ExampleWin">9. Creating groups</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <A href="Intro/IntroExamples.html#ReadWriteAttributes" 
                 target="ExampleWin">10. Writing and reading 
              attributes</A><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#CreateWriteRefObj" 
                 target="ExampleWin">11. Creating and writing references</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#CreateWriteRefObj" 
                 target="ExampleWin">to objects</a><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#ReadRefObj" 
                 target="ExampleWin">12. Reading references to objects</a><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#CreateWriteRefReg" 
                 target="ExampleWin">13. Creating and writing references</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#CreateWriteRefReg" 
                 target="ExampleWin">to dataset regions</a><br>
            &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#ReadRefReg" 
                 target="ExampleWin">14. Reading references to dataset</a><br>
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              &nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;
              <a href="Intro/IntroExamples.html#ReadRefReg" 
                 target="ExampleWin">regions</a>
        </font>
</td></tr>
</table>
</center>
<p>

<hr>
<H2><A NAME="Intro-WhatIs">1. What Is HDF5?</A></H2>
<FONT FACE="Times"><P>HDF5 is a completely new Hierarchical Data Format 
product consisting of a data format specification and a 
supporting library implementation.  HDF5 is designed to address some 
of the limitations of the older HDF product and to address current and 
anticipated requirements of modern systems and applications. 
<sup><a href="#H4H5footnote">1</a></sup>
<P>We urge you to look at HDF5, the format and the library, and give us 
feedback on what you like or do not like about it, and what features 
you would like to see added to it.
<a name="Intro-Why">
<P><B>Why HDF5?</B></a>
The development of HDF5 is motivated by a number of limitations in the 
older HDF format and library. Some of these limitations are:

<UL>
</FONT><LI>A single file cannot store more than 20,000 complex objects, and a single file cannot be larger than 2 gigabytes.
<LI>The data models are less consistent than they should be, there are more object types than necessary, and datatypes are too restricted. 
<LI>The library source is old and overly complex, does not support parallel I/O effectively, and is difficult to use in threaded applications.</UL>

<FONT FACE="Times"><P>HDF5 includes the following improvements.

<UL>
</FONT><LI>A new file format designed to address some of the deficiencies of HDF4.x, particularly the need to store larger files and more objects per file. 
<LI>A simpler, more comprehensive data model that includes only two basic structures: a multidimensional array of record structures, and a grouping structure. 
<LI>A simpler, better-engineered library and API, with improved support for parallel I/O, threads, and other requirements imposed by modern systems and applications.</UL>

<font size=-1>
<a name="H4H5footnote">1.</a>
Note that HDF and HDF5 are two different products.  
HDF is a data format first developed in the 1980s and currently 
in Release 4.<i>x</i> (HDF Release 4.<i>x</i>).
HDF5 is a new data format first released in <i>Beta</i> in 1998 and 
designed to better meet the ever-increasing demands of scientific computing 
and to take better advantage of the ever-increasing capabilities of 
computing systems.
HDF5 is currently in Release 1.<i>x</i> (HDF5 Release 1.<i>x</i>).
</font>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<H3><A NAME="Intro-Changes">Changes in the Current Release</A></H3>
<P>A detailed list of changes in HDF5 between the current release and
the preceding major release can be found in the file 
<a href="ADGuide/RELEASE.txt" target="ExtWin"><code>RELEASE.txt</code></a>,
with a highlights summary in the document 
"<a href="ADGuide/Changes.html">HDF5 Software Changes from Release to Release</a>"
in the 
<a href="ADGuide.html"><cite>HDF5 Application Developer's Guide</cite></a>.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>
<hr>


<H2><A NAME="Intro-FileOrg">2. HDF5 File Organization and Data Model</A></H2>
<FONT FACE="Times"><P>HDF5 files are organized in a hierarchical structure, with two primary structures: <I>groups</I> and <I>datasets</I>.

<UL>
</FONT><I><LI>HDF5 group: </I>a grouping structure containing instances of zero or more groups or datasets, together with supporting metadata.
<I><LI>HDF5 dataset:</I> a multidimensional array of data elements, together with supporting metadata. </UL>

<FONT FACE="Times"><P>Working with groups and group members is similar in many ways to working with directories and files in UNIX. As with UNIX directories and files, objects in an HDF5 file are often described by giving their full (or absolute) path names. 
</FONT><CODE><DL>
<DD>/</CODE> signifies the root group. </DD>
<CODE><DD>/foo</CODE> signifies a member of the root group called <CODE>foo</CODE>.</DD>
<CODE><DD>/foo/zoo</CODE> signifies a member of the group <CODE>foo</CODE>, which in turn is a member of the root group.</DD>
</DL>
<FONT FACE="Times"><P>Any HDF5 group or dataset may have an associated <I>attribute list.</I> An HDF5 <I>attribute</I> is a user-defined HDF5 structure that provides extra information about an HDF5 object. Attributes are described in more detail below. 


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


</FONT><H3><A NAME="Intro-OGroups">HDF5 Groups</A></H3>
<FONT FACE="Times"><P>An<I> HDF5 group</I> is a structure containing zero or more HDF5 objects. A group has two parts:

<UL>
</FONT><LI>A <I>group header</I>, which contains a group name and a list of group attributes. 
<LI>A group symbol table, which is a list of the HDF5 objects that belong to the group.</UL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<H3><A NAME="Intro-ODatasets">HDF5 Datasets</A></H3>
<FONT FACE="Times"><P>A dataset is stored in a file in two parts: a header and a data array. 
<P>The header contains information that is needed to interpret the array portion of the dataset, as well as metadata (or pointers to metadata) that describes or annotates the dataset. Header information includes the name of the object, its dimensionality, its number-type, information about how the data itself is stored on disk, and other information used by the library to speed up access to the dataset or maintain the file's integrity.
<P>There are four essential classes of information in any header: <I>name</I>, <I>datatype</I>, <I>dataspace</I>, and <I>storage layout</I>:
</FONT><B><DFN><P>Name.</B></DFN><FONT FACE="Times"> A dataset <I>name</I> is a sequence of alphanumeric ASCII characters.
</FONT><B><DFN><P>Datatype.</B></DFN><FONT FACE="Times"> HDF5 allows one to define many different kinds of datatypes. There are two categories of datatypes: <I>atomic</I> datatypes and <I>compound</I> datatypes. 
Atomic datatypes can also be system-specific, or <I><CODE>NATIVE</CODE></I>, and all datatypes can be <I>named</I>:
<ul>
<li><em>Atomic</em> datatypes are those that are not decomposed at the datatype interface level, such as integers and floats.
<li><I><CODE>NATIVE</CODE></I> datatypes are system-specific instances of atomic datatypes. 
<li>Compound datatypes are made up of atomic datatypes.
<li><em>Named</em> datatypes are either atomic or compound datatypes that have been specifically designated to be shared across datasets.
</ul>
<I><P>Atomic datatypes</I> include integers and floating-point numbers. Each atomic type belongs to a particular class and has several properties: size, order, precision, and offset. In this introduction, we consider only a few of these properties.
<P>Atomic classes include integer, float, 
<!-- date and time, 
    (DISCUSSION OF TIME DATATYPE COMMENTED OUT 6 FEB 2006,
     UNTIL IT IS PROPERLY SUPPORTED IN THE LIBRARY.) -->
string, bit field, and opaque. <I>(Note: Only integer, float and string  classes are available in the current implementation.)
</I><P>Properties of integer types include size, order (endian-ness), and signed-ness (signed/unsigned).
<P>Properties of float types include the size and location of the exponent and mantissa, and the location of the sign bit.
<P>The datatypes that are supported in the current implementation are: 

<UL>
</FONT><LI>Integer datatypes: 8-bit, 16-bit, 32-bit, and 64-bit integers in both little and big-endian format 
<LI>Floating-point numbers: IEEE 32-bit and 64-bit floating-point numbers in both little and big-endian format
<li>References
<LI>Strings</UL>

<p>
<em><code>NATIVE</code> datatypes.</em>  Although it is possible to describe nearly any kind of atomic datatype, most applications will use predefined datatypes that are supported by their compiler.  In HDF5 these are called <i>native</i> datatypes. <CODE>NATIVE</CODE> datatypes are C-like datatypes that are generally supported by the hardware of the machine on which the library was compiled. In order to be portable, applications should almost always use the <CODE>NATIVE </CODE>designation to describe data values in memory.
<P>The <CODE>NATIVE</CODE> architecture has base names which do not follow the same rules as the others.  Instead, native type names are similar to the C type names.  The following figure shows several examples.
<p>

<center>
<b>Examples of Native Datatypes and Corresponding C Types</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=462>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><P ALIGN="CENTER">Example</B></TD>
<TD WIDTH="51%" VALIGN="TOP">
<B><P ALIGN="CENTER">Corresponding C Type</B></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_CHAR</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>signed char</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_UCHAR</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>unsigned char</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_SHORT</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>short</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_USHORT</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>unsigned short</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_INT</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>int</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_UINT</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>unsigned</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_LONG</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>long</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_ULONG</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>unsigned long</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_LLONG</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>long long</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_ULLONG</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>unsigned long long</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_FLOAT</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>float</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_DOUBLE</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>double</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<code>H5T_NATIVE_LDOUBLE</code></TD>
<TD WIDTH="51%" VALIGN="TOP">
<code>long double</code></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<CODE>H5T_NATIVE_HSIZE</CODE></TD>
<TD WIDTH="51%" VALIGN="TOP">
<CODE>hsize_t</CODE></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<CODE>H5T_NATIVE_HSSIZE</CODE></TD>
<TD WIDTH="51%" VALIGN="TOP">
<CODE>hssize_t</CODE></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<CODE>H5T_NATIVE_HERR</CODE></TD>
<TD WIDTH="51%" VALIGN="TOP">
<CODE>herr_t</CODE></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<CODE>H5T_NATIVE_HBOOL</CODE></TD>
<TD WIDTH="51%" VALIGN="TOP">
<CODE>hbool_t</CODE></TD>
</TR>
</TABLE>
</CENTER>

<FONT FACE="Times"><P>See <A HREF="Datatypes.html"><I>Datatypes</I></A> in the<I> HDF User&#146s Guide</I> for further information.</font>


<FONT FACE="Times"><P>A <I>compound datatype</I> is one in which a 
collection of several datatypes are represented as a single unit, 
a compound datatype, similar to a <I>struct</I> in C. 
The parts of a compound datatype are called <I>members.</I> 
The members of a compound datatype may be of any datatype, 
including another compound datatype. It is possible to read members 
from a compound type without reading the whole type.
<p>
<ta/FONT><I><P>Named datatypes.</I>  Normally each dataset has its own datatype, but sometimes we may want to share a datatype among several datasets.  This can be done using a <I>named </I>datatype. A named datatype is stored in the file independently of any dataset, and referenced by all datasets that have that datatype.  Named datatypes may have an associated attributes list.  
See <A HREF="Datatypes.html"><I>Datatypes</I></A></font><FONT FACE="Times"> in the<I> HDF User&#146s Guide</I> for further information.
<B><DFN><P>Dataspace.</B> </DFN>A dataset <I>dataspace </I>describes the dimensionality of the dataset. The dimensions of a dataset can be fixed (unchanging), or they may be <I>unlimited</I>, which means that they are extendible (i.e. they can grow larger). 
<P>Properties of a dataspace consist of the <I>rank </I>(number of dimensions) of the data array, the <I>actual sizes of the dimensions</I> of the array, and the <I>maximum sizes of the dimensions </I>of the array. For a fixed-dimension dataset, the actual size is the same as the maximum size of a dimension. When a dimension is unlimited, the maximum size is set to the </FONT>value <CODE>H5P_UNLIMITED</CODE>.<FONT FACE="Times"> (An example below shows how to create extendible datasets.)
<P>A dataspace can also describe portions of a dataset, making it possible to do partial I/O operations on  <I>selections</I>.  <I>Selection</I> is supported by the dataspace interface (H5S). Given an n-dimensional dataset, there are currently four ways to do partial selection: 
<OL>

</FONT><LI>Select a logically contiguous n-dimensional hyperslab.  
<LI>Select a non-contiguous hyperslab consisting of elements or blocks of elements (hyperslabs) that are equally spaced.
<li>Select a union of hyperslabs.
<LI>Select a list of independent points. </OL>

<FONT FACE="Times"><P>Since I/O operations have two end-points, the raw data transfer functions require two dataspace arguments: one describes the application memory dataspace or subset thereof, and the other describes the file dataspace or subset thereof.
<P>See <A HREF="Dataspaces.html"><I>Dataspaces</I></A></font><FONT FACE="Times"> in the<I> HDF User&#146s Guide</I> for further information.
</FONT><B><DFN><P>Storage layout.</B></DFN><FONT FACE="Times"> The HDF5 format makes it possible to store data in a variety of ways. The default storage layout format is <I>contiguous</I>, meaning that data is stored in the same linear way that it is organized in memory. Two other storage layout formats are currently defined for HDF5: <I>compact, </I>and<I> chunked. </I>In the future, other storage layouts may be added.<I> 
<P>Compact</I> storage is used when the amount of data is small and can be stored directly in the object header. <I>(Note: Compact storage is not supported in this release.)</I> 
<I><P>Chunked</I> storage involves dividing the dataset into equal-sized "chunks" that are stored separately. Chunking has three important benefits. 
<OL>

<LI>It makes it possible to achieve good performance when accessing subsets of the datasets, even when the subset to be chosen is orthogonal to the normal storage order of the dataset. 
<LI>It makes it possible to compress large datasets and still achieve good performance when accessing subsets of the dataset. 
<LI>It makes it possible efficiently to extend the dimensions of a dataset in any direction.</OL>

<P>
See <A HREF="Datasets.html"><I>Datasets</I></A> and <A HREF="Chunking.html"><I>Dataset Chunking Issues</I></A></font><FONT FACE="Times"> in the<I> HDF User&#146s Guide</I> for further information.
We particularly encourage you to read <A HREF="Chunking.html"><I>Dataset Chunking Issues</I></A> since the issue is complex and beyond the scope of this document.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


</FONT><H3><A NAME="Intro-OAttributes">HDF5 Attributes</A></H3>
<I>Attributes </I>are small named datasets that are attached to primary datasets, groups, or named datatypes.  Attributes can be used to describe the nature and/or the intended usage of a dataset or group. An attribute has two parts: (1) a <I>name</I> and (2) a <I>value</I>.  The value part contains one or more data entries of the same datatype. 
<FONT FACE="Times"><P>The Attribute API (H5A) is used to read or write attribute information. When accessing attributes, they can be identified by name or by an <I>index value</I>.  The use of an index value makes it possible to iterate through all of the attributes associated with a given object.
<P>The HDF5 format and I/O library are designed with the assumption that attributes are small datasets. They are always stored in the object header of the object they are attached to.  Because of this, large datasets should not be stored as attributes. How large is "large" is not defined by the library and is up to the user's interpretation. (Large datasets with metadata can be stored as supplemental datasets in a group with the primary dataset.) 
<P>See <A HREF="Attributes.html"><I>Attributes</I></A></font><FONT FACE="Times"> in the<I> HDF User&#146s Guide</I> for further information.
</FONT>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<H3><A NAME="Intro-FileTech">The File as Written to Media</A></H3>

    <p>For those who are interested, this section takes a look at 
      the low-level elements of the file as the file is written to disk 
      (or other storage media) and the relation of those low-level 
      elements to the higher level elements with which users typically 
      are more familiar.  The HDF5 API generally exposes only the 
      high-level elements to the user; the low-level elements are 
      often hidden.
      The rest of this <cite>Introduction</cite> does not assume 
      an understanding of this material.

    <P>The format of an HDF5 file on disk encompasses several
      key ideas of the HDF4 and AIO file formats as well as
      addressing some shortcomings therein.  The new format is
      more self-describing than the HDF4 format and is more
      uniformly applied to data objects in the file.
      
    <table align=left width=100>
    <tr><td align=center>
        <hr>
        <img src="FF-IH_FileGroup.gif" alt="HDF5 Groups" hspace=15 vspace=15>
    </td><td>&nbsp;</td></tr><tr><td align=center>
        <strong>Figure 1:</strong> Relationships among the 
          HDF5 root group, other groups, and objects
        <hr>
    </td><td>&nbsp;</td></tr>
    </table>


    <P>An HDF5 file appears to the user as a directed graph.  
      The nodes of this graph are the higher-level HDF5 objects
      that are exposed by the HDF5 APIs:

      <ul>
         <li>Groups
         <li>Datasets
         <li>Datatypes
         <li>Dataspaces
      </ul>

    <P>At the lowest level, as information is actually written to the disk, 
       an HDF5 file is made up of the following objects:
      <ul>
         <li>A super block
         <li>B-tree nodes (containing either symbol nodes or raw data chunks)
         <li>Object headers

    <table align=right width=95>
    <tr><td>&nbsp;</td><td align=center>
        <hr>
        <img src="FF-IH_FileObject.gif" alt="HDF5 Objects" hspace=15 vspace=15>
    </td></tr><tr><td>&nbsp;</td><td align=center>
        <strong>Figure 2:</strong> HDF5 objects -- datasets, datatypes, or dataspaces
        <hr>
    </td></tr>
    </table>

         <li>Collections
         <li>Local heaps
         <li>Free space
      </ul>

      The HDF5 library uses these lower-level objects to represent the
      higher-level objects that are then presented to the user or 
      to applications through the APIs.
      For instance, a group is an object header that contains a message that
      points to a local heap and to a B-tree which points to symbol nodes.
      A dataset is an object header that contains messages that describe
      datatype, space, layout, filters, external files, fill value, etc
      with the layout message pointing to either a raw data chunk or to a
      B-tree that points to raw data chunks.

    <P>See the <A HREF="H5.format.html"><cite>HDF5 File Format 
      Specification</cite></A><FONT FACE="Times"> for further information.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>
<hr>


</FONT><H2><A NAME="Intro-APIs">3. The HDF5 Applications Programming Interface (API)</A></H2>
<FONT FACE="Times"><P>The current HDF5 API is implemented only in C. The API provides routines for creating HDF5 files, creating and writing groups, datasets, and their attributes to HDF5 files, and reading groups, datasets and their attributes from HDF5 files.
</FONT><H3><A NAME="Intro-NameConv">Naming conventions</A></H3>
<FONT FACE="Times"><P>All C routines in the HDF 5 library begin with a prefix of the form <B>H5*</B>, where <B>*</B> is a single letter indicating the object on which the operation is to be performed:

<UL>
</FONT><B><LI>H5F</B>: <B>F</B>ile-level access routines. <BR>
Example: <CODE>H5Fopen</CODE>, which opens an HDF5 file. 
<B><LI>H5G</B>: <B>G</B>roup functions, for creating and operating on groups of objects. <BR>
Example: <CODE>H5Gset</CODE><FONT FACE="Courier">,</FONT>which sets the working group to the specified group. 
<B><LI>H5T: </B>Data<B>T</B>ype functions, for creating and operating on simple and compound datatypes to be used as the elements in data arrays.<B><BR>
</B>Example: <CODE>H5Tcopy</CODE><FONT FACE="Courier">,</FONT>which creates a copy of an existing datatype. 
<B><LI>H5S: </B>Data<B>S</B>pace functions, which create and manipulate the dataspace in which the elements of a data array are stored.<BR>
Example: <CODE>H5Screate_simple</CODE>, which creates simple dataspaces. 
<B><LI>H5D: D</B>ataset functions, which manipulate the data within datasets and determine how the data is to be stored in the file. <BR>
Example: <CODE>H5Dread</CODE>, which reads all or part of a dataset into a buffer in memory. 
<B><LI>H5P</B>: <B>P</B>roperty list functions, for manipulating object creation and access properties. <BR>
Example: <CODE>H5Pset_chunk</CODE>, which sets the number of dimensions and the size of a chunk.
<B><LI>H5A</B>: <B>A</B>ttribute access and manipulating routines. <BR>
Example: <CODE>H5Aget_name</CODE>, which retrieves name of an attribute.
<B><LI>H5Z</B>: <B>C</B>ompression registration routine. <BR>
Example: <CODE>H5Zregister</CODE>, which registers new compression and uncompression functions for use with the HDF5 library.
<B><LI>H5E</B>: <B>E</B>rror handling routines. <BR>
Example: <CODE>H5Eprint</CODE>, which prints the current error stack.
<B><LI>H5R</B>: <B>R</B>eference routines. <BR>
Example: <CODE>H5Rcreate</CODE>, which creates a reference.
<B><LI>H5I</B>: <B>I</B>dentifier routine. <BR>
Example: <CODE>H5Iget_type</CODE>, which retrieves the type of an object.</UL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<H3><A NAME="Intro-Include">Include Files</A> </H3>
<FONT FACE="Times"><P>There are a number definitions and declarations that should be included with any HDF5 program. These definitions and declarations are contained in several <I>include</I> files. The main include </FONT>file is <CODE>hdf5.h</CODE>. This file<FONT FACE="Times"> includes all of the other files that your program is likely to need. <I>Be sure to include </i><code>hdf5.h</code><i> in any program that uses the HDF5 library.</I></FONT>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<H3><A NAME="Intro-ProgModels">Programming Models</A></H3>
<FONT FACE="Times"><P>In this section we describe how to program some basic operations on files, including how to

<UL>
</FONT><LI>Create a file.
<LI>Create and initialize a dataset.
<LI>Discard objects when they are no longer needed.
<LI>Write a dataset to a new file.
<LI>Obtain information about a dataset.
<LI>Read a portion of a dataset.
<LI>Create and write compound datatypes.
<LI>Create and write extendible datasets.
<LI>Create and populate groups.
<LI>Work with attributes. </UL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMCreateFile">How to create an HDF5 file</A></h3>
<P>This programming model shows how to create a file and also how to close the file.
<OL>

<LI>Create the file.
<LI>Close the file.
</ol>

<P>The following code fragment implements the specified model. If there is a possibility that the file already exists, the user must add the flag <CODE>H5ACC_TRUNC</CODE> to the access mode to overwrite the previous file's information. 
</font>
<CODE><PRE>hid_t       file;                          /* identifier */
/*
* Create a new file using H5ACC_TRUNC access,
* default file creation properties, and default file
* access properties.
* Then close the file.
*/
file = H5Fcreate(FILE, H5ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
status = H5Fclose(file); </PRE>
</CODE><DL>
<DT>&nbsp;</DT>
</DL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMComponents">How to create and initialize the essential components of a dataset for writing to a file</A></h3>
<P>Recall that datatypes and dimensionality (dataspace) are independent objects, which are created separately from any dataset that they might be attached to. Because of this the creation of a dataset requires, at a minimum, separate definitions of datatype, dimensionality, and dataset. Hence, to create a dataset the following steps need to be taken:
<ol>
<FONT FACE="Times"><LI VALUE=1>Create and initialize a dataspace for the dataset to be written.
<LI>Define the datatype for the dataset to be written. 
<LI>Create and initialize the dataset itself.</OL>

</FONT><FONT FACE="Times"><P>The following code illustrates the creation of these three components of a dataset object.
</FONT><CODE><PRE>hid_t    dataset, datatype, dataspace;   /* declare identifiers */

/* 
 * Create dataspace: Describe the size of the array and 
 * create the data space for fixed size dataset. 
 */
dimsf[0] = NX;
dimsf[1] = NY;
dataspace = H5Screate_simple(RANK, dimsf, NULL); 
/*
 * Define datatype for the data in the file.
 * We will store little endian integer numbers.
 */
datatype = H5Tcopy(H5T_NATIVE_INT);
status = H5Tset_order(datatype, H5T_ORDER_LE);
/*
 * Create a new dataset within the file using defined 
 * dataspace and datatype and default dataset creation
 * properties.
 * NOTE: H5T_NATIVE_INT can be used as datatype if conversion
 * to little endian is not needed.
 */
dataset = H5Dcreate(file, DATASETNAME, datatype, dataspace, H5P_DEFAULT);</PRE>
</CODE>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMDiscard">How to discard objects when they are no longer needed</A></h3>
<FONT FACE="Times"><P>The datatype, dataspace and dataset objects should be released once they are no longer needed by a program. Since each is an independent object, the must be released (or <I>closed</I>) separately. The following lines of code close the datatype, dataspace, and datasets that were created in the preceding section.
</FONT><CODE><P>H5Tclose(datatype);
<P>H5Dclose(dataset);
<P>H5Sclose(dataspace);
</CODE>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMWriteNew">How to write a dataset to a new file</A></h3>
<FONT FACE="Times"><P>Having defined the datatype, dataset, and dataspace parameters, you write out the data with a call to </FONT><CODE>H5Dwrite</CODE><FONT FACE="Courier">.
</FONT><CODE><PRE>/*
* Write the data to the dataset using default transfer
* properties.
*/
status = H5Dwrite(dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
	  H5P_DEFAULT, data);</PRE>
</CODE><FONT FACE="Times"><P>The third and fourth parameters of </FONT><CODE>H5Dwrite</CODE><FONT FACE="Times"> in the example describe the dataspaces in memory and in the file, respectively. They are set to the value </FONT><CODE>H5S_ALL</CODE><FONT FACE="Times"> to indicate that an entire dataset is to be written. In a later section we look at how we would access a portion of a dataset.
</FONT><P><A HREF="Intro/IntroExamples.html#CreateExample" target="ExampleWin"><FONT FACE="Times">Example 1</FONT></A><FONT FACE="Times"> contains a program that creates a file and a dataset, and writes the dataset to the file. 
<P>Reading is analogous to writing. If, in the previous example, we wish to read an entire dataset, we would use the same basic calls with the same parameters. Of course, the routine </FONT><CODE>H5Dread</CODE><FONT FACE="Times"> would replace </FONT><CODE>H5Dwrite</CODE><FONT FACE="Courier">.</FONT><FONT FACE="Times"> 
</FONT>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMGetInfo">Getting information about a dataset</A></h3>
<FONT FACE="Times"><P>Although reading is analogous to writing, it is often necessary to query a file to obtain information about a dataset. For instance, we often need to know about the datatype associated with a dataset, as well dataspace information (e.g. rank and dimensions). There are several "get" routines for obtaining this information.  The following code segment illustrates how we would get this kind of information: 
</FONT><CODE><PRE>/*
* Get datatype and dataspace identifiers and then query
* dataset class, order, size, rank and dimensions.
*/

datatype  = H5Dget_type(dataset);     /* datatype identifier */ 
class     = H5Tget_class(datatype);
if (class == H5T_INTEGER) printf("Data set has INTEGER type \n");
order     = H5Tget_order(datatype);
if (order == H5T_ORDER_LE) printf("Little endian order \n");

size  = H5Tget_size(datatype);
printf(" Data size is %d \n", size);

dataspace = H5Dget_space(dataset);    /* dataspace identifier */
rank      = H5Sget_simple_extent_ndims(dataspace);
status_n  = H5Sget_simple_extent_dims(dataspace, dims_out);
printf("rank %d, dimensions %d x %d \n", rank, dims_out[0], dims_out[1]);</PRE>
</CODE>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMRdWrPortion">Reading and writing a portion of a dataset</A></h3>
<P>In the previous discussion, we describe how to access an entire dataset with one write (or read) operation. HDF5 also supports access to portions (or selections) of a dataset in one read/write operation. Currently selections are limited to hyperslabs, their unions, and the lists of independent points. Both types of selection will be discussed in the following sections. Several sample cases of selection reading/writing are shown on the following figure.
<center>
<table bgcolor="#FFFFFF" border=1>
<tr><td align=center>
<img src="IH_mapHead.gif">
</tr></td><tr><td align=center>
a&nbsp;<img src="IH_map1.gif">
</tr></td><tr><td align=center>
b&nbsp;<img src="IH_map2.gif">
</tr></td><tr><td align=center>
c&nbsp;<img src="IH_map3.gif">
</tr></td><tr><td align=center>
d&nbsp;<img src="IH_map4.gif">
</tr></td><tr><td align=center>
<img src="IH_mapFoot.gif">
</tr></td>
</table>
</center>
</B><P>In example (a) a single hyperslab is read from the midst of a two-dimensional array in a file and stored in the corner of a smaller two-dimensional array in memory.  In (b) a regular series of blocks is read from a two-dimensional array in the file and stored as a contiguous sequence of values at a certain offset in a one-dimensional array in memory.  In (c) a sequence of points with no regular pattern is read from a two-dimensional array in a file and stored as a sequence of points with no regular pattern in a three-dimensional array in memory. 
In (d) a union of hyperslabs in the file dataspace is read and 
the data is stored in another union of hyperslabs in the memory dataspace.
<P>As these examples illustrate, whenever we perform partial read/write operations on the data, the following information must be provided: file dataspace, file dataspace selection, memory dataspace and memory dataspace selection. After the required information is specified, actual read/write operation on the portion of data is done in a single call to the HDF5 read/write functions H5Dread(write).


<H5><A NAME="Intro-PMSelectHyper">Selecting hyperslabs</A></H5>
<FONT FACE="Times"><P>Hyperslabs are portions of datasets.  A hyperslab selection can be a logically contiguous collection of points in a dataspace, or it can be regular pattern of points or blocks in a dataspace.  The following picture illustrates a selection of regularly spaced 3x2 blocks in an 8x12 dataspace.</FONT>
<p>

<center>
<b>Hyperslab selection</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=345>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
</center>

<FONT FACE="Times"><P>Four parameters are required to describe a completely general hyperslab.  Each parameter is an array whose rank is the same as that of the dataspace: 

<UL>
</FONT><CODE><LI>start</CODE>: a starting location for the hyperslab.  In the example <CODE>start</CODE> is (0,1). 
<CODE><LI>stride</CODE>: the number of elements to separate each element or block to be selected.  In the example <CODE>stride</CODE><I> </I> is (4,3).  If the stride parameter is set to NULL, the stride size defaults to 1 in each dimension.
<CODE><LI>count</CODE>: the number of elements or blocks to select along each dimension.  In the example, <CODE>count</CODE> is (2,4).
<CODE><LI>block</CODE>: the size of the block selected from the dataspace.  In the example, <CODE>block</CODE> is (3,2).  If the block parameter is set to NULL, the block size defaults to a single element in each dimension, as if the block array was set to all 1s.</UL>

<B><P>In what order is data copied?  </B>When actual I/O is performed data values are copied by default from one dataspace to another in so-called row-major, or C order.  That is, it is assumed that the first dimension varies slowest, the second next slowest, and so forth.  
<p><B>Example without strides or blocks.</B> Suppose we want to read a 3x4 hyperslab from a dataset in a file beginning at the element <CODE>&lt;1,2&gt;</CODE><FONT FACE="Times"> in the dataset. In order to do this, we must create a dataspace that describes the overall rank and dimensions of the dataset in the file, as well as the position and size of the hyperslab that we are extracting from that dataset. The following code illustrates the selection of the hyperslab in the file dataspace.
</FONT><CODE><PRE>
/* 
* Define file dataspace.
*/
dataspace = H5Dget_space(dataset);    /* dataspace identifier */
rank      = H5Sget_simple_extent_ndims(dataspace);
status_n  = H5Sget_simple_extent_dims(dataspace, dims_out, NULL);

/* 
* Define hyperslab in the dataset. 
*/
offset[0] = 1;
offset[1] = 2;
count[0]  = 3;
count[1]  = 4;
status = H5Sselect_hyperslab(dataspace, H5S_SELECT_SET, offset, NULL, 
         count, NULL);</PRE>
</CODE><FONT FACE="Times"><P>This describes the dataspace from which we wish to read. We need to define the dataspace in memory analogously. Suppose, for instance, that we have in memory a 3 dimensional 7x7x3 array into which we wish to read the 3x4 hyperslab described above beginning at the element </FONT><CODE>&lt;3,0,0&gt;</CODE><FONT FACE="Times">. Since the in-memory dataspace has three dimensions, we have to describe the hyperslab as an array with three dimensions, with the last dimension being 1: </FONT><CODE>&lt;3,4,1&gt;</CODE><FONT FACE="Times">.
<P>Notice that we must describe two things: the dimensions of the in-memory array, and the size and position of the hyperslab that we wish to read in. The following code illustrates how this would be done. 
</FONT><CODE><PRE>/*
* Define memory dataspace.
*/
dimsm[0] = 7;
dimsm[1] = 7;
dimsm[2] = 3;
memspace = H5Screate_simple(RANK_OUT,dimsm,NULL);   

/* 
* Define memory hyperslab. 
*/
offset_out[0] = 3;
offset_out[1] = 0;
offset_out[2] = 0;
count_out[0]  = 3;
count_out[1]  = 4;
count_out[2]  = 1;
status = H5Sselect_hyperslab(memspace, H5S_SELECT_SET, offset_out, NULL, 
         count_out, NULL);

/*</PRE>
</CODE><P><A HREF="Intro/IntroExamples.html#CheckAndReadExample" target="ExampleWin"><FONT FACE="Times">Example 2</FONT></A><FONT FACE="Times"> contains a complete program that performs these operations.
<B><P>Example with strides and blocks</B>.  Consider the 8x12 dataspace described above, in which we selected eight 3x2 blocks.  Suppose we wish to fill these eight blocks. </FONT>
<p>

<center>
<b>Hyperslab selection</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=345>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>X</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
</center>

<P>This hyperslab has the following parameters:<FONT FACE="Times"> </FONT><CODE>start=(0,1), stride=(4,3), count=(2,4), block=(3,2).
</CODE><FONT FACE="Times"><P>Suppose that the source dataspace in memory is this 50-element one dimensional array called </FONT><CODE>vector</CODE><FONT FACE="Times">:</FONT>
<p>

<center>
<b>A 50-element one dimensional array</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=457>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>-1</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>1</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>2</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>3</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>4</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>5</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>6</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>7</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<FONT FACE="Courier"><CODE><P>... </FONT></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>47</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>48</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>-1</CODE></TD>
</TR>
</TABLE>
</center>

<FONT FACE="Times"><P>The following code will write 48 elements from </FONT><CODE>vector</code> to our file dataset, starting with the second element in <code>vector</code>.
<pre>
/* Select hyperslab for the dataset in the file, using 3x2 blocks, (4,3) stride
 * (2,4) count starting at the position (0,1).
 */
start[0]  = 0; start[1]  = 1;
stride[0] = 4; stride[1] = 3;
count[0]  = 2; count[1]  = 4;    
block[0]  = 3; block[1]  = 2;
ret = H5Sselect_hyperslab(fid, H5S_SELECT_SET, start, stride, count, block);

/*
 * Create dataspace for the first dataset.
 */
mid1 = H5Screate_simple(MSPACE1_RANK, dim1, NULL);

/*
 * Select hyperslab. 
 * We will use 48 elements of the vector buffer starting at the second element.
 * Selected elements are 1 2 3 . . . 48
 */
start[0]  = 1;
stride[0] = 1;
count[0]  = 48;
block[0]  = 1;
ret = H5Sselect_hyperslab(mid1, H5S_SELECT_SET, start, stride, count, block);
 
/*
 * Write selection from the vector buffer to the dataset in the file.
 *
ret = H5Dwrite(dataset, H5T_NATIVE_INT, midd1, fid, H5P_DEFAULT, vector)
</pre><CODE><P>&nbsp;
</CODE><P>After these operations, the file dataspace will have the following values.
<p>

<center>
<b>Hyperslab selection with assigned values</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=460>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>1</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>2</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>3</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>4</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>5</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>6</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>7</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>8</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>9</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>10</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>11</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>12</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>13</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>14</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>15</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>16</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>17</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>18</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>19</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>20</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>21</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>22</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>23</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>24</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>25</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>26</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>27</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>28</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>29</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>30</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>31</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>32</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>33</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>34</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>35</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>36</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>37</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>38</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>39</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>40</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>41</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>42</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>43</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>44</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>45</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>46</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>47</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>48</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
</center>

<P>Notice that the values are inserted in the file dataset in row-major order.
<P><a href="Intro/IntroExamples.html#WriteSelected" target="ExampleWin">Example 3</a> includes this code and other example code illustrating the use of hyperslab selection.


<H5><A NAME="Intro-PMSelectPoints">Selecting a list of independent points</A></H5>
A hyperslab specifies a regular pattern of elements in a dataset.  It is also possible to specify a list of independent elements to read or write using the function <CODE>H5Sselect_elements</CODE>.  Suppose, for example, that we wish to write the values 53, 59, 61, 67 to the following elements of the 8x12 array used in the previous example: (0,0), (3,3), (3,5), and (5,6).  The following code selects the points and writes them to the dataset:
<pre>
#define FSPACE_RANK      2    /* Dataset rank as it is stored in the file */
#define NPOINTS          4    /* Number of points that will be selected 
                                 and overwritten */ 
#define MSPACE2_RANK     1    /* Rank of the second dataset in memory */ 
#define MSPACE2_DIM      4    /* Dataset size in memory */ 

&nbsp;
hsize_t dim2[] = {MSPACE2_DIM};       /* Dimension size of the second 
                                         dataset (in memory) */ 
int     values[] = {53, 59, 61, 67};  /* New values to be written */
hsize_t coord[NPOINTS][FSPACE_RANK];  /* Array to store selected points 
                                         from the file dataspace */ 

/*
 * Create dataspace for the second dataset.
 */
mid2 = H5Screate_simple(MSPACE2_RANK, dim2, NULL);

/*
 * Select sequence of NPOINTS points in the file dataspace.
 */
coord[0][0] = 0; coord[0][1] = 0;
coord[1][0] = 3; coord[1][1] = 3;
coord[2][0] = 3; coord[2][1] = 5;
coord[3][0] = 5; coord[3][1] = 6;

ret = H5Sselect_elements(fid, H5S_SELECT_SET, NPOINTS, 
                         (const hsize_t **)coord);

/*
 * Write new selection of points to the dataset.
 */
ret = H5Dwrite(dataset, H5T_NATIVE_INT, mid2, fid, H5P_DEFAULT, values);   
</pre>

<P>&nbsp;
</FONT><P>After these operations, the file dataspace will have the following values:
<p>

<center>
<b>Hyperslab selection with an overlay of independent points</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=460>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<B><CODE><P>53</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>1</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>2</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>3</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>4</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>5</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>6</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>7</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>8</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>9</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>10</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>11</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>12</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>13</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>14</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>15</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>16</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>17</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>18</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>19</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>20</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>21</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>22</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>23</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>24</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<B><CODE><P>59</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<B><CODE><P>61</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>25</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>26</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>27</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>28</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>29</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>30</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>31</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>32</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>33</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>34</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>35</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>36</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<B><CODE><P>67</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>37</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>38</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>39</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>40</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>41</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>42</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>43</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>44</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>45</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>46</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>47</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>48</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
</center>

<P><A HREF="Intro/IntroExamples.html#WriteSelected" target="ExampleWin"><FONT FACE="Times">Example 3</FONT></A><FONT FACE="Times"> contains a complete program that performs these subsetting operations.


<H5><A NAME="_SelectUnion">Selecting a union of hyperslabs</A></H5>

</font>
The HDF5 Library allows the user to select a union of hyperslabs and 
write or read the selection into another selection.  The shapes of
the two selections may differ, but the number of elements must be equal.
<p>
Suppose that we want to read two overlapping hyperslabs from the dataset 
written in the previous example into a union of hyperslabs in the memory 
dataset.  This exercise is illustrated in the two figures immediately below.
Note that the memory dataset has a different shape from the previously
written dataset.  Similarly, the selection in the memory dataset
could have a different shape than the selected union of hyperslabs in 
the original file; for simplicity, we will preserve the selection's shape
in this example.
<p>

<center>
<b>Selection of a union of hyperslabs in a file dataset</b><br>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=460>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<B><CODE><P>53</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>1</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>2</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>3</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>4</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>5</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>6</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>7</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>8</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>9</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>10</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>11</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>12</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>13</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>14</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>15</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>16</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>17</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>18</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<CODE><P>19</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<CODE><P>20</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>21</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44" border=1>
<CODE><P>22</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>23</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>24</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<B><CODE><P>59</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<B><CODE><P>61</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>25</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>26</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>27</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>28</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>29</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>30</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>31</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>32</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>33</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>34</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>35</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>36</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<B><CODE><P>67</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>37</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>38</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>39</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>40</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>41</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>42</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>43</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>44</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>45</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>46</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>47</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>
<CODE><P>48</CODE></TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
<font size=-1><i>(Note: The above table highlights hyperslab selections 
with green, blue, and yellow<br> shading.  This shading may not 
appear properly in black-and-white printed copies.)</i></font>
</center>


<p>

<center>
<b>Selection of a union of hyperslabs in a memory dataset</b><br>
<font size=-1>Blank cells in this figure actually contain values written 
when the dataset was initialized.</font>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=345>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>10</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>11</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>12</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<CODE><P>18</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<CODE><P>19</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<CODE><P>20</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>21</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44" border=1>
<CODE><P>22</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#44FFFF">
<B><CODE><P>59</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#88FF88">
<B><CODE><P>61</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>27</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>28</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>29</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>30</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>35</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>36</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<B><CODE><P>67</B></CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>37</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>38</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>43</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>44</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>45</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1 bgcolor="#FFFF44">
<CODE><P>46</CODE></TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP" HEIGHT=1>&nbsp;</TD>
</TR>
</TABLE>
<font size=-1><i>(Note: The above table highlights hyperslab selections 
with green, blue, and yellow<br> shading.  This shading may not 
appear properly in black-and-white printed copies.)</i></font>
</center>


<p>
The following lines of code show the required steps.
<p>
First obtain the dataspace identifier for the dataset in the file.

<pre>
    /*
     * Get dataspace of the open dataset.
     */  
    fid = H5Dget_space(dataset);
</pre>

Then select the hyperslab with the size 3x4 and 
the left upper corner at the position (1,2):

<pre>
    /*
     * Select first hyperslab for the dataset in the file. The following
     * elements are selected:
     *                     10  0 11 12
     *                     18  0 19 20
     *                      0 59  0 61
     *   
     */ 
    start[0] = 1; start[1] = 2;
    block[0] = 1; block[1] = 1;
    stride[0] = 1; stride[1] = 1;
    count[0]  = 3; count[1]  = 4;
    ret = H5Sselect_hyperslab(fid, H5S_SELECT_SET, start, stride, count, block); 
</pre>

Now select the second hyperslab with the size 6x5 at the position (2,4), 
and create the union with the first hyperslab.

<pre>
    /*
     * Add second selected hyperslab to the selection.
     * The following elements are selected:
     *                    19 20  0 21 22
     *                     0 61  0  0  0
     *                    27 28  0 29 30
     *                    35 36 67 37 38
     *                    43 44  0 45 46
     *                     0  0  0  0  0
     * Note that two hyperslabs overlap. Common elements are:
     *                                              19 20
     *                                               0 61
     */
    start[0] = 2; start[1] = 4;
    block[0] = 1; block[1] = 1;
    stride[0] = 1; stride[1] = 1;
    count[0]  = 6; count[1]  = 5;
    ret = H5Sselect_hyperslab(fid, H5S_SELECT_OR, start, stride, count, block);
</pre>
 
Note that when we add the selected hyperslab to the union, the 
second argument to the <code>H5Sselect_hyperslab</code> function 
has to be <code>H5S_SELECT_OR</code> instead of <code>H5S_SELECT_SET</code>. 
Using <code>H5S_SELECT_SET</code> would reset the selection to 
the second hyperslab.
<p>
Now define the memory dataspace and select the union of the hyperslabs 
in the memory dataset.

<pre>
    /*
     * Create memory dataspace.
     */
    mid = H5Screate_simple(MSPACE_RANK, mdim, NULL);
     
    /*
     * Select two hyperslabs in memory. Hyperslabs has the same
     * size and shape as the selected hyperslabs for the file dataspace.
     */
    start[0] = 0; start[1] = 0;
    block[0] = 1; block[1] = 1;
    stride[0] = 1; stride[1] = 1;
    count[0]  = 3; count[1]  = 4;
    ret = H5Sselect_hyperslab(mid, H5S_SELECT_SET, start, stride, count, block);     
    start[0] = 1; start[1] = 2;
    block[0] = 1; block[1] = 1;
    stride[0] = 1; stride[1] = 1;
    count[0]  = 6; count[1]  = 5;
    ret = H5Sselect_hyperslab(mid, H5S_SELECT_OR, start, stride, count, block);
</pre>
     
Finally we can read the selected data from the file dataspace to the selection
in memory with one call to the <code>H5Dread</code> function.

<pre>    ret = H5Dread(dataset, H5T_NATIVE_INT, mid, fid, H5P_DEFAULT, matrix_out);
</pre>

<P>
<A HREF="Intro/IntroExamples.html#WriteSelected" target="ExampleWin">Example 3</a> 
includes this code along with the previous selection example.




<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


</FONT><h3><A NAME="Intro-PMCreateVariableLength">Creating variable-length datatypes</A></h3>

Variable-length (VL) datatypes are sequences of an existing datatype
(atomic, VL, or compound) which are not fixed in length from one dataset location
to another.  In essence, they are similar to C character strings -- a sequence of 
a type which is pointed to by a particular type of <em>pointer</em> -- although 
they are implemented more closely to FORTRAN strings by including an explicit 
length in the pointer instead of using a particular value to terminate the 
sequence.

<p>
VL datatypes are useful to the scientific community in many different ways,
some of which are listed below:
<ul>
    <li>Ragged arrays: Multi-dimensional ragged arrays can be implemented with
        the last (fastest changing) dimension being ragged by using a
        VL datatype as the type of the element stored. (Or as a field in a
        compound datatype.)
    <li>Fractal arrays: If a compound datatype has a VL field of another compound
        type with VL fields (a <em>nested</em> VL datatype), this can be used to
        implement ragged arrays of ragged arrays, to whatever nesting depth is
        required for the user.
    <li>Polygon lists: A common storage requirement is to efficiently store arrays
        of polygons with different numbers of vertices.  VL datatypes can be
        used to efficiently and succinctly describe an array of polygons with
        different numbers of vertices.
    <li>Character strings: Perhaps the most common use of VL datatypes will be to
        store C-like VL character strings in dataset elements or as attributes
        of objects.
    <li>Indices: An array of VL object references could be used as an index to
        all the objects in a file which contain a particular sequence of
        dataset values. Perhaps an array something like the following:
        <pre>
            Value1: Object1, Object3,  Object9
            Value2: Object0, Object12, Object14, Object21, Object22
            Value3: Object2
            Value4: &lt;none&gt;
            Value5: Object1, Object10, Object12
                .
                .
        </pre>
    <li>Object Tracking: An array of VL dataset region references can be used as
        a method of tracking objects or features appearing in a sequence of
        datasets.  Perhaps an array of them would look like:
        <pre>
            Feature1: Dataset1:Region,  Dataset3:Region,  Dataset9:Region
            Feature2: Dataset0:Region,  Dataset12:Region, Dataset14:Region,
                      Dataset21:Region, Dataset22:Region
            Feature3: Dataset2:Region
            Feature4: &lt;none&gt;
            Feature5: Dataset1:Region,  Dataset10:Region, Dataset12:Region
                .
                .
        </pre>
</ul>


<h4>Variable-length datatype memory management</h4>

With each element possibly being of different sequence lengths for a
dataset with a VL datatype, the memory for the VL datatype must be dynamically
allocated.  Currently there are two methods of managing the memory for 
VL datatypes: the standard C malloc/free memory allocation routines or a method
of calling user-defined memory management routines to allocate or free memory.
Since the memory allocated when reading (or writing) may be complicated to
release, an HDF5 routine is provided to traverse a memory buffer and free the
VL datatype information without leaking memory.


<h5>Variable-length datatypes cannot be divided</h5>

VL datatypes are designed so that they cannot be subdivided by the library
with selections, etc.  This design was chosen due to the complexities in
specifying selections on each VL element of a dataset through a selection API
that is easy to understand.  Also, the selection APIs work on dataspaces, not
on datatypes.  At some point in time, we may want to create a way for
dataspaces to have VL components to them and we would need to allow selections
of those VL regions, but that is beyond the scope of this document.


<h5>What happens if the library runs out of memory while reading?</h5>

It is possible for a call to <code>H5Dread</code> to fail while reading in 
VL datatype information if the memory required exceeds that which is available.  
In this case, the <code>H5Dread</code> call will fail gracefully and any 
VL data which has been allocated prior to the memory shortage will be returned 
to the system via the memory management routines detailed below.  
It may be possible to design a <em>partial read</em> API function at a 
later date, if demand for such a function warrants.


<h5>Strings as variable-length datatypes</h5>

Since character strings are a special case of VL data that is implemented
in many different ways on different machines and in different programming 
languages, they are handled somewhat differently from other VL datatypes in HDF5.

<p>
HDF5 has native VL strings for each language API, which are stored the
same way on disk, but are exported through each language API in a natural way
for that language.  When retrieving VL strings from a dataset, users may choose
to have them stored in memory as a native VL string or in HDF5's <code>hvl_t</code> 
struct for VL datatypes.

<p>
VL strings may be created in one of two ways: by creating a VL datatype with
a base type of <code>H5T_NATIVE_ASCII</code>, <code>H5T_NATIVE_UNICODE</code>, 
etc., or by creating a string datatype and setting its length to 
<code>H5T_VARIABLE</code>.  The second method is used to access 
native VL strings in memory.  The library will convert between the two types, 
but they are stored on disk using different datatypes and have different 
memory representations.

<p>
Multi-byte character representations, such as UNICODE or <em>wide</em> 
characters in C/C++, will need the appropriate character and string datatypes 
created so that they can be described properly through the datatype API.  
Additional conversions between these types and the current ASCII characters 
will also be required.

<p>
Variable-width character strings (which might be compressed data or some
other encoding) are not currently handled by this design.  We will evaluate
how to implement them based on user feedback.


<h4>Variable-length datatype APIs</h4>

<h5>Creation</h5>

VL datatypes are created with the <code>H5Tvlen_create()</code> function 
as follows:
<dl>
    <dd><em>type_id</em> = <code>H5Tvlen_create</code>(<em>hid_t</em> <code>base_type_id</code>);
</dl>

<p>
The base datatype will be the datatype that the sequence is composed of,
characters for character strings, vertex coordinates for polygon lists, etc.
The base datatype specified for the VL datatype can be of any HDF5 datatype,
including another VL datatype, a compound datatype, or an atomic datatype.


<h5>Querying base datatype of VL datatype</h5>

It may be necessary to know the base datatype of a VL datatype before 
memory is allocated, etc.  The base datatype is queried with the 
<code>H5Tget_super()</code> function, described in the H5T documentation.


<h5>Querying minimum memory required for VL information</h5>

It order to predict the memory usage that <code>H5Dread</code> may need 
to allocate to store VL data while reading the data, the 
<code>H5Dget_vlen_size()</code> function is provided:
<dl>
    <dd><em>herr_t</em> 
        <code>H5Dvlen_get_buf_size</code>(<em>hid_t</em> <code>dataset_id</code>, 
        <em>hid_t</em> <code>type_id</code>,
        <em>hid_t</em> <code>space_id</code>, 
        <em>hsize_t</em> *<code>size</code>) 
</dl>

<p>
This routine checks the number of bytes required to store the VL data from
the dataset, using the <code>space_id</code> for the selection in the dataset 
on disk and the <code>type_id</code> for the memory representation of the 
VL data in memory.  The *<code>size</code> value is modified according to 
how many bytes are required to store the VL data in memory.


<h5>Specifying how to manage memory for the VL datatype</h5>

The memory management method is determined by dataset transfer properties
passed into the <code>H5Dread</code> and <code>H5Dwrite</code> functions 
with the dataset transfer property list.  

<p>
Default memory management is set by using <code>H5P_DEFAULT</code> 
for the dataset transfer property list identifier.
If <code>H5P_DEFAULT</code> is used with <code>H5Dread</code>,
the system <code>malloc</code> and <code>free</code> calls
will be used for allocating and freeing memory.
In such a case,  <code>H5P_DEFAULT</code> should also be passed
as the property list identifier to <code>H5Dvlen_reclaim</code>.

<p>
The rest of this subsection is relevant only to those who choose 
<i>not</i> to use default memory management.

<p>
The user can choose whether to use the 
system <code>malloc</code> and <code>free</code> calls  or
user-defined, or custom, memory management functions.
If user-defined memory management functions are to be used, 
the memory allocation and free routines must be defined via 
<code>H5Pset_vlen_mem_manager()</code>, as follows:
<dl>
    <dd><em>herr_t</em> 
        <code>H5Pset_vlen_mem_manager</code>(<em>hid_t</em> <code>plist_id</code>,
        <em>H5MM_allocate_t</em> <code>alloc</code>, 
        <em>void</em> *<code>alloc_info</code>,
        <em>H5MM_free_t</em> <code>free</code>, 
        <em>void</em> *<code>free_info</code>)
</dl>


<p>
The <code>alloc</code> and <code>free</code> parameters 
identify the memory management routines to be used.
If the user has defined custom memory management routines,
<code>alloc</code> and/or <code>free</code> should be set to make 
those routine calls (i.e., the name of the routine is used as 
the value of the parameter);  
if the user prefers to use the system's <code> malloc</code>
and/or <code>free</code>, the <code>alloc</code> and 
<code>free</code> parameters, respectively, should be set to 
<code> NULL</code>
<p>
The prototypes for the user-defined functions would appear as follows:
<dl>
    <dd><code>typedef</code> <em>void</em> 
        *(*<code>H5MM_allocate_t</code>)(<em>size_t</em> <code>size</code>, 
        <em>void</em> *<code>info</code>) ;
    <dd><code>typedef</code> <em>void</em> 
        (*<code>H5MM_free_t</code>)(<em>void</em> *<code>mem</code>, 
        <em>void</em> *<code>free_info</code>) ;
</dl>

<p>
The <code>alloc_info</code> and <code>free_info</code> parameters can be 
used to pass along any required information to the user's memory management 
routines.

<p>
In summary, if the user has defined custom memory management 
routines, the name(s) of the routines are passed in the 
<code>alloc</code> and <code>free</code> parameters and the 
custom routines' parameters are passed in the 
<code>alloc_info</code> and <code>free_info</code> parameters.
If the user wishes to use the system <code> malloc</code> and 
<code>free</code> functions, the <code>alloc</code> and/or 
<code>free</code> parameters are set to <code> NULL</code> 
and the  <code>alloc_info</code> and <code>free_info</code> 
parameters are ignored.

<h5>Recovering memory from VL buffers read in</h5>

The complex memory buffers created for a VL datatype may be reclaimed with
the <code>H5Dvlen_reclaim()</code> function call, as follows:
<dl>
    <dd><em>herr_t</em> 
        <code>H5Dvlen_reclaim</code>(<em>hid_t</em> <code>type_id</code>, 
        <em>hid_t</em> <code>space_id</code>, 
        <em>hid_t</em> <code>plist_id</code>,
        <em>void</em> *<code>buf</code>);
</dl>

<p>
The <code>type_id</code> must be the datatype stored in the buffer, 
<code>space_id</code> describes the selection for the memory buffer 
to free the VL datatypes within, 
<code>plist_id</code> is the dataset transfer property list which 
was used for the I/O transfer to create the buffer, and 
<code>buf</code> is the pointer to the buffer to free the VL memory within.  
The VL structures (<code>hvl_t</code>) in the user's buffer are 
modified to zero out the VL information after it has been freed.

<p>
If nested VL datatypes were used to create the buffer, 
this routine frees them from the bottom up, 
releasing all the memory without creating memory leaks.

<P>
<A HREF="Intro/IntroExamples.html#VariableLength" target="ExampleWin">Example 4</a>
creates a dataset with the variable-length datatype using user-defined 
functions for memory management.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMCreateArray">Creating array datatypes</A></h3>

The array class of datatypes, <code>H5T_ARRAY</code>, allows the 
construction of true, homogeneous, multi-dimensional arrays.  
Since these are homogeneous arrays, each element of the array will be 
of the same datatype, designated at the time the array is created.

<p>
Arrays can be nested.
Not only is an array datatype used as an element of an HDF5 dataset,
but the elements of an array datatype may be of any datatype, 
including another array datatype.

<p>
Array datatypes cannot be subdivided for I/O; the entire array must 
be transferred from one dataset to another. 

<p>
Within certain limitations, outlined in the next paragraph, array datatypes 
may be <em>N</em>-dimensional and of any dimension size.  
Unlimited dimensions, however, are not supported. 
Functionality similar to unlimited dimension arrays is available through 
the use of variable-length datatypes.

<p>
The maximum number of dimensions, i.e., the maximum rank, of an array
datatype is specified by the HDF5 library constant <code>H5S_MAX_RANK</code>.
The minimum rank is 1 (one).
All dimension sizes must be greater than 0 (zero). 

<p>
One array dataype may only be converted to another array datatype 
if the number of dimensions and the sizes of the dimensions are equal 
and the datatype of the first array's elements can be converted 
to the datatype of the second array's elements.

<h4>Array datatype APIs</h4>

There are three functions that are specific to array datatypes: 
one, <code>H5Tarray_create</code>, for creating an array datatype, 
and two, <code>H5Tget_array_ndims</code> and <code>H5Tget_array_dims</code>,
for working with existing array datatypes.

<h5>Creating</h5>

The function <code>H5Tarray_create</code> creates a new array datatype object.
Parameters specify 
  <ul>
  <li>the base datatype of each element of the array,
  <li>the rank of the array, i.e., the number of dimensions, 
  <li>the size of each dimension, and
  <li>the dimension permutation of the array, i.e., whether the 
      elements of the array are listed in C or FORTRAN order.
      (<b>Note:</b> The permutation feature is not implemented in Release 1.4.)
  </ul>

<dir>
    <em>hid_t</em> <code>H5Tarray_create</code>(
                   <em>hid_t</em> <code>base</code>,
                   <em>int</em> <code>rank</code>,
                   <em>const hsize_t</em> <code>dims[/*rank*/]</code>,
                   <em>const int</em> <code>perm[/*rank*/]</code>
            )
</dir>

<h5>Working with existing array datatypes</h5>

When working with existing arrays, one must first determine the 
the rank, or number of dimensions, of the array.

<p>
The function <code>H5Tget_array_ndims</code> returns the rank of a
specified array datatype.

<dir>
    <em>int</em> <code>H5Tget_array_ndims</code>(
                 <em>hid_t</em> <code>adtype_id</code>
            )
</dir>

In many instances, one needs further information.
The function <code>H5Tget_array_dims</code> retrieves the 
permutation of the array and the size of each dimension.
(<b>Note:</b> The permutation feature is not implemented in Release 1.4.)

<dir>
    <em>int</em> <code>H5Tget_array_dims</code>(
                 <em>hid_t</em> <code>adtype_id</code>,
                 <em>hsize_t *</em><code>dims[]</code>,
                 <em>int *</em><code>perm[]</code>
            )
</dir>


<p>
<A HREF="Intro/IntroExamples.html#Array" target="ExampleWin">Example 5</a> 
creates an array datatype and a dataset containing elements of the 
array datatype in an HDF5 file.  It then writes the dataset to the file.  


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


</FONT><h3><A NAME="Intro-PMCreateCompound">Creating compound datatypes</A></h3>
<B><P>Properties of compound datatypes. </B>A compound datatype is similar to a struct in C or a common block in Fortran. It is a collection of one or more atomic types or small arrays of such types. To create and use of a compound datatype you need to refer to various <i>properties</i> of the data compound datatype:

<UL>
<LI>It is of class <i>compound</i><I>.</I> 
<LI>It has a fixed total <i>size</i>, in bytes. 
<LI>It consists of zero or more <i>members</i> (defined in any order) with unique names and which occupy non-overlapping regions within the datum. 
<LI>Each member has its own <i>datatype</i>. 
<LI>Each member is referenced by an <i>index number</i> between zero and N-1, where N is the number of members in the compound datatype. 
<LI>Each member has a <i>name</i> which is unique among its siblings in a compound datatype. 
<LI>Each member has a fixed <i>byte offset</i>, which is the first byte (smallest byte address) of that member in a compound datatype. 
<LI>Each member can be a small array of up to four dimensions.</UL>

<FONT FACE="Times"><P>Properties of members of a compound datatype are defined when the member is added to the compound type and cannot be subsequently modified.
<B><P>Defining compound datatypes. </B>Compound datatypes must be built out of other datatypes. First, one creates an empty compound datatype and specifies its total size. Then members are added to the compound datatype in any order.
<I><P>Member names. </I>Each member must have a descriptive name, which is the key used to uniquely identify the member within the compound datatype. A member name in an HDF5 datatype does not necessarily have to be the same as the name of the corresponding member in the C struct in memory, although this is often the case. Nor does one need to define all members of the C struct in the HDF5 compound datatype (or vice versa). 
<I><P>Offsets. </I>Usually a C struct will be defined to hold a data point in memory, and the offsets of the members in memory will be the offsets of the struct members from the beginning of an instance of the struct. The library defines the macro to compute the offset of a member within a struct:
</FONT><CODE><br>&nbsp;&nbsp;HOFFSET(s,m)<FONT SIZE=5> </FONT></CODE>
<br><FONT FACE="Times">This macro computes the offset of member </FONT><FONT FACE="Courier"><EM>m</EM> </FONT><FONT FACE="Times">within a struct variable <EM>s</EM>. 
<P>Here is an example in which a compound datatype is created to describe complex numbers whose type is defined by the </FONT><CODE>complex_t</CODE><FONT FACE="Times" SIZE=2> </FONT><FONT FACE="Times">struct. 
</FONT><CODE><PRE>typedef struct {
   double re;   /*real part */
   double im;   /*imaginary part */
} complex_t;

complex_t tmp;  /*used only to compute offsets */
hid_t complex_id = H5Tcreate (H5T_COMPOUND, sizeof tmp);
H5Tinsert (complex_id, "real", HOFFSET(tmp,re),
           H5T_NATIVE_DOUBLE);
H5Tinsert (complex_id, "imaginary", HOFFSET(tmp,im),
           H5T_NATIVE_DOUBLE);</PRE>
</CODE><P><A HREF="Intro/IntroExamples.html#Compound" target="ExampleWin">Example 6</A><FONT FACE="Times"> shows how to create a compound datatype, write an array that has the compound datatype to the file, and read back subsets of the members.
</FONT>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMCreateExtendible">Creating and writing extendible and chunked datasets</A></h3>
<FONT FACE="Times"><P>An <I>extendible</I> dataset is one whose dimensions can grow. In HDF5, it is possible to define a dataset to have certain initial dimensions, then later to increase the size of any of the initial dimensions. 
<P>For example, you can create and store the following 3x3 HDF5 dataset:
</FONT><PRE>     1 1 1
     1 1 1 
     1 1 1 </PRE>
<FONT FACE="Times"><P>then later to extend this into a 10x3 dataset by adding 7 rows, such as this:
</FONT><PRE>     1 1 1 
     1 1 1 
     1 1 1 
     2 2 2
     2 2 2
     2 2 2
     2 2 2
     2 2 2
     2 2 2
     2 2 2</PRE>
<FONT FACE="Times"><P>then further extend it to a 10x5 dataset by adding two columns, such as this:
</FONT><PRE>     1 1 1 3 3 
     1 1 1 3 3 
     1 1 1 3 3 
     2 2 2 3 3
     2 2 2 3 3
     2 2 2 3 3
     2 2 2 3 3
     2 2 2 3 3
     2 2 2 3 3
     2 2 2 3 3</PRE>
<FONT FACE="Times"><P>HDF 5 requires you to use <I>chunking</I> in order to define extendible datasets. Chunking makes it possible to extend datasets efficiently, without having to reorganize storage excessively. 
<P>The following operations are required in order to write an extendible dataset:
<OL>

<LI>Declare the dataspace of the dataset to have <I>unlimited dimensions</I> for all dimensions that might eventually be extended.
<LI>Set dataset creation properties to enable chunking and create a dataset.
<LI>Extend the size of the dataset.</OL>

<P>For example, suppose we wish to create a dataset similar to the one shown above. We want to start with a 3x3 dataset, then later extend it in both directions. 
<B><P>Declaring unlimited dimensions. </B>We could declare the dataspace to have unlimited dimensions with the following code, which uses the predefined constant </FONT><CODE>H5S_UNLIMITED</CODE><FONT FACE="Times"> to specify unlimited dimensions.
</FONT><PRE>hsize_t dims[2] = { 3, 3}; /* dataset dimensions
at the creation time */ 
hsize_t maxdims[2] = {H5S_UNLIMITED, H5S_UNLIMITED};
/*
 * Create the data space with unlimited dimensions. 
 */
dataspace = H5Screate_simple(RANK, dims, maxdims); </PRE>
<B><P>Enabling chunking.  </B>We can then set the dataset storage layout properties to enable chunking.  We do this using the routine <CODE>H5Pset_chunk</CODE><FONT SIZE=4>:
</FONT><PRE>hid_t cparms; 
hsize_t chunk_dims[2] ={2, 5};
/* 
 * Modify dataset creation properties to enable chunking.
 */
cparms = H5Pcreate (H5P_DATASET_CREATE);
status = H5Pset_chunk( cparms, RANK, chunk_dims);
</PRE>

Then create a dataset.
<pre>
/*
 * Create a new dataset within the file using cparms
 * creation properties.
 */
dataset = H5Dcreate(file, DATASETNAME, H5T_NATIVE_INT, dataspace,
                 cparms);
</pre>

<B><P>Extending dataset size.  </B>Finally, when we want to extend the size of the dataset, we invoke <CODE>H5Dextend </CODE>to extend the size of the dataset.  In the following example, we extend the dataset along the first dimension, by seven rows, so that the new dimensions are <CODE>&lt;10,3&gt;</CODE>:
<PRE>/*
 * Extend the dataset. Dataset becomes 10 x 3.
 */
dims[0] = dims[0] + 7;
size[0] = dims[0]; 
size[1] = dims[1]; 
status = H5Dextend (dataset, size);</PRE>
<FONT FACE="Courier" SIZE=2><P>&nbsp;
</FONT><P><A HREF="Intro/IntroExamples.html#CreateExtendWrite" target="ExampleWin">Example 7</A> shows how to create a 3x3 extendible dataset, write the dataset, extend the dataset to 10x3, write the dataset again, extend it again to 10x5, write the dataset again.
<P><A HREF="Intro/IntroExamples.html#ReadExtended" target="ExampleWin">Example 8</A> shows how to read the data written by Example 7.  


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMWorkGroups">Working with groups in a file</A></h3>
<P>Groups provide a mechanism for organizing meaningful and extendible sets of datasets within an HDF5 file. The H5G API contains routines for working with groups. 
<B><P>Creating a group. </B>To create a group, use 
<CODE>H5Gcreate</CODE>.  For example, the following code 
creates a group called <code>Data</code> in the root group.
<pre>
 /*
  *  Create a group in the file.
  */
 grp = H5Gcreate(file, "/Data", 0);
</pre>
A group may be created in another group by providing the 
absolute name of the group to the <code>H5Gcreate</code> 
function or by specifying its location.  For example, 
to create the group <code>Data_new</code> in the 
<code>Data</code> group, one can use the following sequence 
of calls:
<pre>
 /*
  * Create group "Data_new" in the group "Data" by specifying
  * absolute name of the group.
  */
 grp_new = H5Gcreate(file, "/Data/Data_new", 0);
</pre>
or
<pre>
 /*
  * Create group "Data_new" in the "Data" group.
  */
 grp_new = H5Gcreate(grp, "Data_new", 0);
</pre>
Note that the group identifier <code>grp</code> is used 
as the first parameter in the <code>H5Gcreate</code> function 
when the relative name is provided.   
<p>
The third parameter in <code>H5Gcreate</code> optionally 
specifies how much file space to reserve to store the names 
that will appear in this group.  If a non-positive
value is supplied, then a default size is chosen.
<p>
<code>H5Gclose</code> closes the group and releases the 
group identifier.
<p>

<b>Creating a dataset in a particular group.</b>
As with groups, a dataset can be created in a particular 
group by specifying its absolute name as illustrated in 
the following example:

<pre> 
 /*
  * Create the dataset "Compressed_Data" in the group using the 
  * absolute name. The dataset creation property list is modified 
  * to use GZIP compression with the compression effort set to 6.
  * Note that compression can be used only when the dataset is 
  * chunked.
  */
 dims[0] = 1000;
 dims[1] = 20;
 cdims[0] = 20;
 cdims[1] = 20;
 dataspace = H5Screate_simple(RANK, dims, NULL);
 plist     = H5Pcreate(H5P_DATASET_CREATE);
             H5Pset_chunk(plist, 2, cdims);
             H5Pset_deflate( plist, 6);
 dataset = H5Dcreate(file, "/Data/Compressed_Data", H5T_NATIVE_INT,
                     dataspace, plist);
</pre>
A relative dataset name may also be used when a dataset is 
created.  First obtain the identifier of the group in which 
the dataset is to be created.  Then create the dataset
with <code>H5Dcreate</code> as illustrated in the following 
example:
<pre>
 /* 
  * Open the group.
  */
 grp = H5Gopen(file, "Data");

 /*
  * Create the dataset "Compressed_Data" in the "Data" group
  * by providing a group identifier and a relative dataset 
  * name as parameters to the H5Dcreate function.
  */
 dataset = H5Dcreate(grp, "Compressed_Data", H5T_NATIVE_INT,
                     dataspace, plist);
</pre>
<p>

<b>Accessing an object in a group.</b>
Any object in a group can be accessed by its absolute or 
relative name.  The following lines of code show how to use 
the absolute name to access the dataset 
<code>Compressed_Data</code> in the group <code>Data</code> 
created in the examples above:
<pre>
  /*
   * Open the dataset "Compressed_Data" in the "Data" group. 
   */
  dataset = H5Dopen(file, "/Data/Compressed_Data");
</pre>
The same dataset can be accessed in another manner.  First
access the group to which the dataset belongs, then open 
the dataset. 
<pre>
  /*
   * Open the group "data" in the file.
   */
  grp  = H5Gopen(file, "Data");
 
  /*
   * Access the "Compressed_Data" dataset in the group.
   */
  dataset = H5Dopen(grp, "Compressed_Data");
</pre>

<p>
<A HREF="Intro/IntroExamples.html#CreateGroups" target="ExampleWin">Example 9</A> 
shows how to create a group in a file and a 
dataset in a group.  It uses the iterator function 
<code>H5Giterate</code> to find the names of the objects
in the root group, and <code>H5Glink</code> and <code>H5Gunlink</code>
to create a new group name and delete the original name.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMWorkAttributes">Working with attributes</A></h3>
<P>Think of an attribute as a small datasets that is attached to a normal dataset or group.  The H5A API contains routines for working with attributes.  Since attributes share many of the characteristics of datasets, the programming model for working with attributes is analogous in many ways to the model for working with datasets.  The primary differences are that an attribute must be attached to a dataset or a group, and subsetting operations cannot be performed on attributes.
<B><P>To create an attribute </B>belonging to a particular dataset or group<B>, </B>first create a dataspace for the attribute with the call to <CODE>H5Screate</CODE>, then create the attribute using <CODE>H5Acreate</CODE>.  For example, the following code creates an attribute called <CODE> Integer_attribute </CODE>that is a member of a dataset whose identifier is <CODE>dataset</CODE>. The attribute identifier is <CODE>attr2</CODE>.<CODE> H5Awrite</CODE> then sets the value of the attribute of that of the integer variable <CODE>point</code>. <code>H5Aclose</code> <FONT FACE="Times">then releases the attribute identifier.
</CODE>
</FONT>
<pre>
int point = 1;                         /* Value of the scalar attribute */ 

/*
 * Create scalar attribute.
 */
aid2  = H5Screate(H5S_SCALAR);
attr2 = H5Acreate(dataset, "Integer attribute", H5T_NATIVE_INT, aid2,
                  H5P_DEFAULT);

/*
 * Write scalar attribute.
 */
ret = H5Awrite(attr2, H5T_NATIVE_INT, &amp;point); 

/*
 * Close attribute dataspace.
 */
ret = H5Sclose(aid2); 

/*
 * Close attribute.
 */
ret = H5Aclose(attr2); 
</pre>
<CODE><P>&nbsp;
</CODE><B><P>To read a scalar attribute whose name and datatype are known</B>, first open the attribute using <CODE>H5Aopen_name</CODE>, then use H5Aread to get its value.  For example the following reads a scalar attribute called <CODE>Integer_attribute</CODE> whose datatype is a native integer, and whose parent dataset has the identifier <CODE>dataset</CODE>.
<pre>
/*
 * Attach to the scalar attribute using attribute name, then read and 
 * display its value.
 */
attr = H5Aopen_name(dataset,"Integer attribute");
ret  = H5Aread(attr, H5T_NATIVE_INT, &amp;point_out);
printf("The value of the attribute \"Integer attribute\" is %d \n", point_out); 
ret =  H5Aclose(attr);
</pre>
</FONT><B><P>Reading an attribute whose characteristics are not known. </B>It may be necessary to query a<FONT FACE="Times"> file to obtain information about an attribute, namely its name, datatype, rank and dimensions. The following code opens an attribute by its index value using </FONT><CODE>H5Aopen_index</CODE><FONT FACE="Times">, then reads in information about its datatype.
</FONT>
<pre>
/*
 * Attach to the string attribute using its index, then read and display the value.
 */
attr =  H5Aopen_idx(dataset, 2);
atype = H5Tcopy(H5T_C_S1);
        H5Tset_size(atype, 4);
ret   = H5Aread(attr, atype, string_out);
printf("The value of the attribute with the index 2 is %s \n", string_out);
</pre>
<code>
</CODE><P>In practice, if the characteristics of attributes are not known, 
the code involved in accessing and processing the attribute can be quite 
complex.  For this reason, HDF5 includes a function called 
<CODE>H5Aiterate</CODE>, which applies a user-supplied function to each 
of a set of attributes.  The user-supplied function can contain the code 
that interprets, accesses and processes each attribute. 
<p>
<a href="Intro/IntroExamples.html#ReadWriteAttributes" target="ExampleWin">Example 10</a> <A NAME="_Toc429885323">illustrates the use of the <code>H5Aiterate</code> function, as well as the other attribute examples described above.</A> 


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMWorkRefObjects">Working with references to objects</A></h3>

In HDF5, objects (i.e. groups, datasets, and named datatypes) are usually 
accessed by name. This access method was discussed in previous sections. 
There is another way to access stored objects -- by reference.
<P>
An object reference is based on the relative file address of the object header
in the file and is constant for the life of the object. Once a reference to
an object is created and stored in a dataset in the file, it can be used
to dereference the object it points to. References are handy for creating
a file index or for grouping related objects by storing references to them in
one dataset.
<P>

<h4>Creating and storing references to objects</h4>
The following steps are involved in creating and storing file references
to objects:
<OL>
<LI> Create the objects or open them if they already exist in the file.
<LI> Create a dataset to store the objects' references.
<LI> Create and store references to the objects in a buffer.
<LI> Write a buffer with the references to the dataset.
</OL>


<h5>Programming example</h5>
<a href="Intro/IntroExamples.html#CreateWriteRefObj" target="ExampleWin">Example 11</a> 
creates a group and two datasets and a named datatype in the group. 
References to these four objects are stored in the dataset in the 
root group.  

<p>
<b>Notes:</b>
Note the following elements of this example:
<UL>
<LI> The following code, 
<PRE>
    dataset = H5Dcreate ( fid1,"Dataset3",H5T_STD_REF_OBJ,sid1,H5P_DEFAULT );
</PRE>
  creates a dataset to store references. Notice that the 
  <code>H5T_SDT_REF_OBJ</code> datatype is used to specify that 
  references to objects will be stored. 
  The datatype <code>H5T_STD_REF_DSETREG</code> is used to store the 
  dataset region references and is be discussed later.
<LI>The next few calls to the <code>H5Rcreate</code> function create 
  references to the objects and store them in the buffer <I>wbuf</I>. 
  The signature of the <code>H5Rcreate</code> function is:
<PRE>
   herr_t H5Rcreate ( void* buf, hid_t loc_id, const char *name, 
                      H5R_type_t ref_type, hid_t space_id )    
</PRE>
<UL>
    <LI> The first argument specifies the buffer to store the reference.
    <LI> The second and third arguments specify the name of the referenced 
         object.  In the example, the file identifier <I>fid1</I> and 
         absolute name of the dataset <code>/Group1/Dataset1</code> 
         identify the dataset. One could also use the group identifier 
         of group <code>Group1</code> and the relative name of the dataset 
         <code>Dataset1</code> to create the same reference.
    <LI> The fourth argument specifies the type of the reference. 
         The example uses references to the objects (<code>H5R_OBJECT</code>).
         Another type of reference, reference to the dataset region 
         (<code>H5R_DATASET_REGION</code>), is discussed later. 
    <LI> The fifth argument specifies the space identifier. When references 
         to the objects are created, it should be set to <code>-1</code>. 
</UL>
<LI>The <code>H5Dwrite</code> function writes a dataset with the 
    references to the file. Notice that the <code>H5T_SDT_REF_OBJ</code>
    datatype is used to describe the dataset's memory datatype.
</UL>

<b>Output file contents:</b>
The contents of the <code>trefer1.h5</code> file created by this example 
are as follows:
<PRE>

HDF5 "trefer1.h5" {
GROUP "/" {
   DATASET "Dataset3" {
      DATATYPE { H5T_REFERENCE }
      DATASPACE { SIMPLE ( 4 ) / ( 4 ) }
      DATA {
         DATASET 0:1696, DATASET 0:2152, GROUP 0:1320, DATATYPE 0:2268
      }
   }
   GROUP "Group1" {
      DATASET "Dataset1" {
         DATATYPE { H5T_STD_U32LE }
         DATASPACE { SIMPLE ( 4 ) / ( 4 ) }
         DATA {
            0, 3, 6, 9
         }
      }
      DATASET "Dataset2" {
         DATATYPE { H5T_STD_U8LE }
         DATASPACE { SIMPLE ( 4 ) / ( 4 ) }
         DATA {
            0, 0, 0, 0
         }
      }
      DATATYPE "Datatype1" {
         H5T_STD_I32BE "a";
         H5T_STD_I32BE "b";
         H5T_IEEE_F32BE "c";
      }
   }
}
}

</PRE>
Notice how the data in  dataset <code>Dataset3</code> is described. 
The two numbers with the colon in between represent a unique identifier 
of the object. These numbers are constant for the life of the object.
 

<h4>Reading references and accessing objects using references</h4>

The following steps are involved:
<OL>
<LI> Open the dataset with the references and read them. 
     The <code>H5T_STD_REF_OBJ</code> datatype must be used to 
     describe the memory datatype.
<LI> Use the read reference to obtain the identifier of the object the 
     reference points to.
<LI> Open the dereferenced object and perform the desired operations.
<LI> Close all objects when the task is complete. 
</OL>

<h5>Programming example</h5>

<a href="Intro/IntroExamples.html#ReadRefObj" target="ExampleWin">Example 12</a>
opens and reads dataset <code>Dataset3</code> from the file created created 
in Example 11. Then the program dereferences the references 
to dataset <code>Dataset1</code>, the group and the named datatype,
and opens those objects. 
The program reads and displays the dataset's data, the group's comment, and 
the number of members of the compound datatype.

<p>
<b>Output file contents:</b>
The output of this program is as follows:

<PRE>

Dataset data : 
 0  3  6  9 

Group comment is Foo! 
 
Number of compound datatype members is 3 
</PRE> 


<p>
<b>Notes:</b>
Note the following elements of this example:

<UL>
<LI> The <code>H5Dread</code> function was used to read dataset 
     <code>Dataset3</code> containing the references to the objects. 
     The <code>H5T_STD_REF_OBJ</code> memory datatype was 
     used to read references to memory.
<LI> <code>H5Rdereference</code> obtains the object's identifier. 
     The signature of this function is:
<PRE>
         hid_t H5Rdereference (hid_t datatset, H5R_type_t ref_type, void *ref)
</PRE> 
   <UL>
    <LI> The first argument is an identifier of the dataset with the 
         references.
    <LI> The second argument specifies the reference type. 
         <code>H5R_OBJECT</code> was used to specify a reference to an 
         object. Another type, used to specifiy a reference to a dataset 
         region and discussed later, is <code>H5R_DATASET_REGION</code>.
    <LI> The third argument is a buffer to store the reference to be read.
    <LI> The function returns an identifier of the object the reference 
         points to.  In this simplified situation, the type that was
         stored in the dataset is known. When the type of the object is 
         unknown, <code>H5Rget_object_type</code> should be used to 
         identify the type of object the reference points to. 
    </UL>
</UL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>


<h3><A NAME="Intro-PMWorkRefRegions">Working with references to dataset regions</A></h3>

A dataset region reference points to the dataset selection by storing the
relative file address  of the dataset header and the global heap offset of
the referenced selection.  The selection referenced is located by retrieving
the coordinates of the areas in the selection from the global heap. This
internal mechanism of storing and retrieving dataset selections is transparent
to the user. A reference to the dataset selection (region) is constant for 
the life of the dataset.

<h4>Creating and storing references to dataset regions</h4>
The following steps are involved in creating and storing references to
the dataset regions:
<OL>

<LI> Create a dataset to store the dataset regions (selections).
<P>
<LI> Create selections in the dataset(s). Dataset(s) should already exist 
   in the file.
<P>
<LI> Create references to the selections and store them in a buffer.
<P>
<LI> Write references to the dataset regions in the file.
<P>
<LI> Close all objects.
</OL>

<h5>Programming example</H5>

<a href="Intro/IntroExamples.html#CreateWriteRefReg" target="ExampleWin">Example 13</a>
creates a dataset in the file. Then it creates a dataset to store 
references to the dataset regions (selections).
The first selection is a 6 x 6 hyperslab. 
The second selection is a point selection in the same dataset.
References to both selections are created and stored in the buffer, 
and then written to the dataset in the file.

<p>
<b>Notes:</b>
Note the following elements of this example:
<UL>
<LI> The code, 
<PRE>
    dset1=H5Dcreate(fid1,"Dataset1",H5T_STD_REF_DSETREG,sid1,H5P_DEFAULT);
</PRE>
   creates a dataset to store references to the dataset(s) regions (selections).
   Notice that the <code>H5T_STD_REF_DSETREG</code> datatype is used.

<LI> This program uses hyperslab and point selections. The dataspace 
   handle <I>sid2</I> is used for the calls to <code>H5Sselect_hyperslab</code>
   and <code>H5Sselect_elements</code>.  The handle was created when dataset 
   <code><b>Dataset2</b></code> was created and it describes the dataset's 
   dataspace. It was not closed when the dataset was closed to decrease 
   the number of function calls used in the example. 
   In a real application program, one should open the dataset and determine 
   its dataspace using the <code>H5Dget_space</code> function. 
<LI> <code>H5Rcreate</code> is used to create a dataset region reference 
   and store it in a buffer.  The signature of the function is:
<PRE>
     herr_t H5Rcreate(void *buf, hid_t loc_id, const char *name,
                      H5R_type_t ref_type, hid_t space_id)
</PRE>
<UL>
    <LI> The first argument specifies the buffer to store the reference.
    <LI> The second and third arguments specify the name of the referenced 
         dataset.  In the example, the file identifier <I>fid1</I> and the 
         absolute name of the dataset <code><b>/Dataset2</b></code> were 
         used to identify the dataset. The reference to the region of this 
         dataset is stored in the buffer <I>buf</I>.  
    
    <LI> The fourth argument specifies the type of the reference. Since 
       the example creates references to the dataset regions, the 
       <code>H5R_DATASET_REGION</code> datatype is used. 
    <LI> The fifth argument is a dataspace identifier of the referenced 
       dataset. 
</UL>
</UL>

<b>Output file contents:</b>
The contents of the file <code>trefer2.h5</code> created by this program 
are as follows:

<PRE>
HDF5 "trefer2.h5" {
GROUP "/" {
   DATASET "Dataset1" {
      DATATYPE { H5T_REFERENCE }
      DATASPACE { SIMPLE ( 4 ) / ( 4 ) }
      DATA {
         DATASET 0:744 {(2,2)-(7,7)}, DATASET 0:744 {(6,9), (2,2), (8,4), (1,6),
          (2,8), (3,2), (0,4), (9,0), (7,1), (3,3)}, NULL, NULL
      }
   }
   DATASET "Dataset2" {
      DATATYPE { H5T_STD_U8LE }
      DATASPACE { SIMPLE ( 10, 10 ) / ( 10, 10 ) }
      DATA {
         0, 3, 6, 9, 12, 15, 18, 21, 24, 27,
         30, 33, 36, 39, 42, 45, 48, 51, 54, 57,
         60, 63, 66, 69, 72, 75, 78, 81, 84, 87,
         90, 93, 96, 99, 102, 105, 108, 111, 114, 117,
         120, 123, 126, 129, 132, 135, 138, 141, 144, 147,
         150, 153, 156, 159, 162, 165, 168, 171, 174, 177,
         180, 183, 186, 189, 192, 195, 198, 201, 204, 207,
         210, 213, 216, 219, 222, 225, 228, 231, 234, 237,
         240, 243, 246, 249, 252, 255, 255, 255, 255, 255,
         255, 255, 255, 255, 255, 255, 255, 255, 255, 255
      }
   }
}
}
</PRE>
Notice how raw data of the dataset with the dataset regions is displayed.
Each element of the raw data consists of a reference to the dataset 
(<code>DATASET  number1:number2</code>) and its selected region. 
If the selection is a hyperslab, the corner coordinates of the hyperslab 
are displayed. 
For the point selection, the coordinates of each point are displayed.
Since only two selections were stored, the third and fourth elements of the 
dataset <code>Dataset1</code> are set to <code>NULL</code>. 
This was done by the buffer inizialization in the program.

<h4>Reading references to dataset regions</h4>

The following steps are involved in reading references to dataset 
regions and referenced dataset regions (selections).
<OL>
<LI> Open and read the dataset containing references to the dataset regions.
   The datatype <code>H5T_STD_REF_DSETREG</code> must be used during 
   read operation.
<LI>Use <code>H5Rdereference</code> to obtain the dataset identifier 
    from the read dataset region reference.
    <PRE>                       <B>OR</B>
    </PRE>
   Use <code>H5Rget_region</code> to obtain the dataspace identifier for 
   the dataset containing the selection from the read dataset region reference.
<LI> With the dataspace identifier, the H5S interface functions,  
     <code>H5Sget_select_</code>*, can be used to obtain information 
     about the selection.
<LI> Close all objects when they are no longer needed.
</OL>

<H5>Programming example</H5>

<a href="Intro/IntroExamples.html#ReadRefReg" target="ExampleWin">Example 14</a>
reads a dataset containing dataset region references.
It reads data from the dereferenced dataset and displays the number of 
elements and raw data. Then it reads two selections:
a hyperslab selection and a point selection. The program queries a 
number of points in the hyperslab  and the coordinates and displays them. 
Then it queries a number of selected points and their coordinates and 
displays the information.


<p>
<b>Output:</b>
The output of this program is :
<PRE>

 Number of elements in the dataset is : 100
 0  3  6  9  12  15  18  21  24  27 
 30  33  36  39  42  45  48  51  54  57 
 60  63  66  69  72  75  78  81  84  87 
 90  93  96  99  102  105  108  111  114  117 
 120  123  126  129  132  135  138  141  144  147 
 150  153  156  159  162  165  168  171  174  177 
 180  183  186  189  192  195  198  201  204  207 
 210  213  216  219  222  225  228  231  234  237 
 240  243  246  249  252  255  255  255  255  255 
 255  255  255  255  255  255  255  255  255  255 
 Number of elements in the hyperslab is : 36 
 Hyperslab coordinates are : 
 ( 2 , 2 ) ( 7 , 7 ) 
 Number of selected elements is : 10
 Coordinates of selected elements are : 
 ( 6 , 9 ) 
 ( 2 , 2 ) 
 ( 8 , 4 ) 
 ( 1 , 6 ) 
 ( 2 , 8 ) 
 ( 3 , 2 ) 
 ( 0 , 4 ) 
 ( 9 , 0 ) 
 ( 7 , 1 ) 
 ( 3 , 3 ) 
 
</PRE>

<b>Notes:</b>
Note the following elements of this example:
<UL>
<LI> The dataset with the region references was read by <code>H5Dread</code>
   with the <code>H5T_STD_REF_DSETREG</code> datatype specified.
<LI> The read reference can be used to obtain the dataset identifier 
    with the following call:
<PRE>
    dset2 = H5Rdereference (dset1,H5R_DATASET_REGION,&rbuf[0]);
</PRE>
   or to obtain spacial information (dataspace and selection) with the call
   to <code>H5Rget_region</code>:
<PRE>
    sid2=H5Rget_region(dset1,H5R_DATASET_REGION,&rbuf[0]);
</PRE> 
   The reference to the dataset region has information for both the dataset 
   itself and its selection. In both functions:
<UL>
       <LI> The first parameter is an identifier of the dataset with the 
         region references.
       <LI> The second parameter specifies the type of  reference stored. 
         In this example, a reference to the dataset region is stored.
       <LI> The third parameter is a buffer containing the reference of the 
         specified type.
</UL>
<LI> This example introduces several <code>H5Sget_select</code>* 
   functions used to obtain information about selections:

<UL>
    <code>H5Sget_select_npoints:</code>  returns the number of elements in 
       the hyperslab<BR>
    <code>H5Sget_select_hyper_nblocks:</code> returns the number of blocks 
       in the hyperslab<BR>
    <code>H5Sget_select_blocklist:</code> returns the "lower left" and 
       "upper right" coordinates of the blocks in the hyperslab selection<BR>
    <code>H5Sget_select_bounds:</code> returns the coordinates of the 
       "minimal" block containing a hyperslab selection<BR>
    <code>H5Sget_select_elem_npoints:</code> returns the number of points 
       in the element selection<BR>  
    <code>H5Sget_select_elem_points:</code> returns the coordinates of 
       the element selection
</UL>
</UL>


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font>
<hr>


<H2>4. Example Codes</H2>
For the example codes, see 
<a href="Intro/IntroExamples.html" target="ExampleWin" target="ExampleWin"><cite>Introduction to HDF5 -- Example Codes</cite></a>.


<p align=right><font size=-1><a href="#Intro-TOC">(Return to TOC)</a></font> 


<!-- #BeginLibraryItem "/ed_libs/NavBar_Intro.lbi" -->
<hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://www.hdfgroup.org/HDF5/doc1.6/UG/UG_frame.html">HDF5 User Guide</a>&nbsp;
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
<a href="RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;<br>
<a href="index.html">Other HDF5 documents and links</a>&nbsp;
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><address>
<table width=100% border=0>
<tr><td align=left valign=top>
 
<!-- #BeginLibraryItem "/ed_libs/Footer.lbi" -->

<address>
The HDF Group Help Desk: <img src="Graphics/help.png" align=top height=16>
<br>
Describes HDF5 Release 1.6.10, November 2009 
</address>


<!-- #EndLibraryItem -->
 
Last modified: 6 February 2006 

</td><td align=right valign=top>
<a href="Copyright.html">Copyright</a>&nbsp;&nbsp;
</td></tr>
</table>             


</BODY>
</HTML>
