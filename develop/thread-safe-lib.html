<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: Thread Safe Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better serve our user community by answering the following short survey:  <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;1.15.0</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('thread-safe-lib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Thread Safe Library</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_tsafe_compilation"></a>
Library header files and conditional compilation</h1>
<p>The following code is placed at the beginning of H5private.h: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef H5_HAVE_THREADSAFE</span></div>
<div class="line"><span class="preprocessor">#include &lt;pthread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p><code>H5_HAVE_THREADSAFE</code> is defined when the HDF5 library is compiled with the <em>&ndash;enable-threadsafe</em> configuration option using autotools or <em>HDF5_ENABLE_THREADSAFE=ON</em> using CMake. In general, code for the non-threadsafe version of HDF5 library are placed within the <code># else</code> part of the conditional compilation. The exception to this rule are the changes to the <code>FUNC_ENTER</code> (in H5private.h), <code>HRETURN</code> and <code>HRETURN_ERROR</code> (in H5Eprivate.h) macros (see section <a class="el" href="thread-safe-lib.html#subsec_tsafe_macro_ret">Changes to HRETURN and HRETURN_ERROR</a>). </p>
<h1><a class="anchor" id="sec_tsafe_global"></a>
Global variables/structures</h1>
<h2><a class="anchor" id="subsec_tsafe_global_var"></a>
Global library initialization variable</h2>
<p>In the threadsafe implementation, the global library initialization variable <code>H5_libinit_g</code> is changed to a global structure consisting of the variable with its associated lock (locks are explained in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_locks">Recursive Locks</a>): </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#ad470b00eccd2115c707c02de5fa1120d">hbool_t</a>  H5_libinit_g = FALSE;</div>
<div class="ttc" id="a_h5public_8h_html_ad470b00eccd2115c707c02de5fa1120d"><div class="ttname"><a href="_h5public_8h.html#ad470b00eccd2115c707c02de5fa1120d">hbool_t</a></div><div class="ttdeci">bool hbool_t</div><div class="ttdef"><b>Definition</b> H5public.h:253</div></div>
</div><!-- fragment --><p>becomes </p><div class="fragment"><div class="line">H5_api_t H5_g;</div>
</div><!-- fragment --><p>where <code>H5_api_t</code> is </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5_api_struct {</div>
<div class="line">  H5_mutex_t init_lock;           <span class="comment">// API entrance mutex</span></div>
<div class="line">  <a class="code hl_typedef" href="_h5public_8h.html#ad470b00eccd2115c707c02de5fa1120d">hbool_t</a> H5_libinit_g;</div>
<div class="line">} H5_api_t;</div>
</div><!-- fragment --><p>All former references to <code>H5_libinit_g</code> in the library are now made using the macro <code>H5_INIT_GLOBAL</code>. If the threadsafe library is to be used, the macro is set to <code>H5_g.H5_libinit_g</code> instead.</p>
<h2><a class="anchor" id="subsec_tsafe_global_serial"></a>
Global serialization variable</h2>
<p>A new global boolean variable <code>H5_allow_concurrent_g</code> is used to determine if multiple threads are allowed to an API call simultaneously. This is set to <code>FALSE</code>.</p>
<p>All APIs that are allowed to do so have their own local variable that shadows the global variable and is set to <code>TRUE</code>. In phase 1, no such APIs exist.</p>
<p>It is defined in <code>H5.c</code> as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#ad470b00eccd2115c707c02de5fa1120d">hbool_t</a> H5_allow_concurrent_g = FALSE;</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_global_init"></a>
Global thread initialization variable</h2>
<p>The global variable <code>H5_first_init_g</code> of type <code>pthread_once_t</code> is used to allow only the first thread in the application process to call an initialization function using <code>pthread_once</code>. All subsequent calls to <code>pthread_once</code> by any thread are disregarded.</p>
<p>The call sets up the mutex in the global structure <code>H5_g</code> (see section <a class="el" href="thread-safe-lib.html#subsec_tsafe_global_var">Global library initialization variable</a>) via an initialization function <code>H5_first_thread_init</code>. The first thread initialization function is described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_first">First thread initialization</a>.</p>
<p><code>H5_first_init_g</code> is defined in <code>H5.c</code> as follows: </p><div class="fragment"><div class="line">pthread_once_t H5_first_init_g = PTHREAD_ONCE_INIT;</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_global_key"></a>
Global key for per-thread error stacks</h2>
<p>A global pthread-managed key <code>H5_errstk_key_g</code> is used to allow pthreads to maintain a separate error stack (of type <code>H5E_t</code>) for each thread. This is defined in <code>H5.c</code> as: </p><div class="fragment"><div class="line">pthread_key_t H5_errstk_key_g;</div>
</div><!-- fragment --><p>Error stack management is described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_err">Per-thread error stack management</a>.</p>
<h2><a class="anchor" id="subsec_tsafe_global_cancel"></a>
Global structure and key for thread cancellation prevention</h2>
<p>We need to preserve the thread cancellation status of each thread individually by using a key <code>H5_cancel_key_g</code>. The status is preserved using a structure (of type <code>H5_cancel_t</code>) which maintains the cancellability state of the thread before it entered the library and a count (which works very much like the recursive lock counter) which keeps track of the number of API calls the thread makes within the library.</p>
<p>The structure is defined in <code>H5private.h</code> as: </p><div class="fragment"><div class="line"><span class="comment">// cancellability structure</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5_cancel_struct {</div>
<div class="line">  <span class="keywordtype">int</span> previous_state;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cancel_count;</div>
<div class="line">} H5_cancel_t;</div>
</div><!-- fragment --><p>Thread cancellation is described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_cancel">Thread Cancellation safety</a>.</p>
<h1><a class="anchor" id="sec_tsafe_macro"></a>
Changes to Macro expansions</h1>
<h2><a class="anchor" id="subsec_tsafe_macro_fe"></a>
Changes to FUNC_ENTER</h2>
<p>The <code>FUNC_ENTER</code> macro is now extended to include macro calls to initialize first threads, disable cancellability and wraps a lock operation around the checking of the global initialization flag. It should be noted that the cancellability should be disabled before acquiring the lock on the library. Doing so otherwise would allow the possibility that the thread be cancelled just after it has acquired the lock on the library and in that scenario, if the cleanup routines are not properly set, the library would be permanently locked out.</p>
<p>The additional macro code and new macro definitions can be found in Appendix <a class="el" href="thread-safe-lib.html#subsec_tsafe_app_E">Macro expansion codes</a>. The changes are made in <code>H5private.h</code>.</p>
<h2><a class="anchor" id="subsec_tsafe_macro_ret"></a>
Changes to HRETURN and HRETURN_ERROR</h2>
<p>The <code>HRETURN</code> and <code>HRETURN_ERROR</code> macros are the counterparts to the <code>FUNC_ENTER</code> macro described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_macro_fe">Changes to FUNC_ENTER</a>. <code>FUNC_LEAVE</code> makes a macro call to <code>HRETURN</code>, so it is also covered here.</p>
<p>The basic changes to these two macros involve adding macro calls to call an unlock operation and re-enable cancellability if necessary. It should be noted that the cancellability should be re-enabled only after the thread has released the lock to the library. The consequence of doing otherwise would be similar to that described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_macro_fe">Changes to FUNC_ENTER</a>.</p>
<p>The additional macro code and new macro definitions can be found in Appendix <a class="el" href="thread-safe-lib.html#subsec_tsafe_app_E">Macro expansion codes</a>. The changes are made in <code>H5Eprivate.h</code>.</p>
<h1><a class="anchor" id="sec_tsafe_impl"></a>
Implementation of threadsafe functionality</h1>
<h2><a class="anchor" id="subsec_tsafe_impl_locks"></a>
Recursive Locks</h2>
<p>A recursive mutex lock m allows a thread t1 to successfully lock m more than once without blocking t1. Another thread t2 will block if t2 tries to lock m while t1 holds the lock to m. If t1 makes k lock calls on m, then it also needs to make k unlock calls on m before it releases the lock.</p>
<p>Our implementation of recursive locks is built on top of a pthread mutex lock (which is not recursive). It makes use of a pthread condition variable to have unsuccessful threads wait on the mutex. Waiting threads are awaken by a signal from the final unlock call made by the thread holding the lock.</p>
<p>Recursive locks are defined to be the following type (<code>H5private.h</code>): </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5_mutex_struct {</div>
<div class="line">  pthread_t owner_thread;         <span class="comment">// current lock owner</span></div>
<div class="line">  pthread_mutex_t atomic_lock;    <span class="comment">// lock for atomicity of new mechanism</span></div>
<div class="line">  pthread_cond_t cond_var;        <span class="comment">// condition variable</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lock_count;</div>
<div class="line">} H5_mutex_t;</div>
</div><!-- fragment --><p>Detailed implementation code can be found in Appendix <a class="el" href="thread-safe-lib.html#subsec_tsafe_app_A">Recursive Lock implementation code</a>. The implementation changes are made in <code>H5TS.c</code>.</p>
<h2><a class="anchor" id="subsec_tsafe_impl_first"></a>
First thread initialization</h2>
<p>Because the mutex lock associated with a recursive lock cannot be statically initialized, a mechanism is required to initialize the recursive lock associated with <code>H5_g</code> so that it can be used for the first time.</p>
<p>The pthreads library allows this through the pthread_once call which as described in section <a class="el" href="thread-safe-lib.html#subsec_tsafe_global_init">Global thread initialization variable</a> allows only the first thread accessing the library in an application to initialize <code>H5_g</code>.</p>
<p>In addition to initializing <code>H5_g</code>, it also initializes the key (see section <a class="el" href="thread-safe-lib.html#subsec_tsafe_global_key">Global key for per-thread error stacks</a>) for use with per-thread error stacks (see section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_err">Per-thread error stack management</a>).</p>
<p>The first thread initialization mechanism is implemented as the function call <code>H5_first_thread_init()</code> in <code>H5TS.c</code>. This is described in appendix B.</p>
<h2><a class="anchor" id="subsec_tsafe_impl_err"></a>
Per-thread error stack management</h2>
<p>Pthreads allows individual threads to access dynamic and persistent per-thread data through the use of keys. Each key is associated with a table that maps threads to data items. Keys can be initialized by <code>pthread_key_create()</code> in pthreads (see sections <a class="el" href="thread-safe-lib.html#subsec_tsafe_global_key">Global key for per-thread error stacks</a> and <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_first">First thread initialization</a>). Per-thread data items are accessed using a key through the <code>pthread_getspecific()</code> and <code>pthread_setspecific()</code> calls to read and write to the association table respectively.</p>
<p>Per-thread error stacks are accessed through the key <code>H5_errstk_key_g</code> which is initialized by the first thread initialization call (see section <a class="el" href="thread-safe-lib.html#subsec_tsafe_impl_first">First thread initialization</a>).</p>
<p>In the non-threadsafe version of the library, there is a global stack variable <code>H5E_stack_g[1]</code> which is no longer defined in the threadsafe version. At the same time, the macro call to gain access to the error stack <code>H5E_get_my_stack</code> is changed from: </p><div class="fragment"><div class="line"><span class="preprocessor">#define H5E_get_my_stack() (H5E_stack_g+0)</span></div>
</div><!-- fragment --><p>to: </p><div class="fragment"><div class="line"><span class="preprocessor">#define H5E_get_my_stack() H5E_get_stack()</span></div>
</div><!-- fragment --><p>where <code>H5E_get_stack()</code> is a surrogate function that does the following operations: </p><ol>
<li>
<p class="startli">if a thread is attempting to get an error stack for the first time, the error stack is dynamically allocated for the thread and associated with <code>H5_errstk_key_g</code> using <code>pthread_setspecific()</code>. The way we detect if it is the first time is through <code>pthread_getspecific()</code> which returns <code>NULL</code> if no previous value is associated with the thread using the key.</p>
<p class="endli"></p>
</li>
<li>
if <code>pthread_getspecific()</code> returns a non-null value, then that is the pointer to the error stack associated with the thread and the stack can be used as usual. </li>
</ol>
<p>A final change to the error reporting routines is as follows; the current implementation reports errors to always be detected at thread 0. In the threadsafe implementation, this is changed to report the number returned by a call to <code>pthread_self()</code>.</p>
<p>The change in code (reflected in <code>H5Eprint</code> of file <code>H5E.c</code>) is as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef H5_HAVE_THREADSAFE</span></div>
<div class="line">  fprintf (stream, <span class="stringliteral">&quot;HDF5-DIAG: Error detected in thread %d.&quot;</span> ,pthread_self());</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  fprintf (stream, <span class="stringliteral">&quot;HDF5-DIAG: Error detected in thread 0.&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Code for <code>H5E_get_stack()</code> can be found in Appendix <a class="el" href="thread-safe-lib.html#subsec_tsafe_app_C">Per-thread error stack acquisition</a>. All the above changes were made in <code>H5E.c</code>.</p>
<h2><a class="anchor" id="subsec_tsafe_impl_cancel"></a>
Thread Cancellation safety</h2>
<p>To prevent thread cancellations from killing a thread while it is in the library, we maintain per-thread information about the cancellability status of the thread before it entered the library so that we can restore that same status when the thread leaves the library.</p>
<p>By <em>enter</em> and <em>leave</em> the library, we mean the points when a thread makes an API call from a user application and the time that API call returns. Other API or callback function calls made from within that API call are considered <em>within</em> the library.</p>
<p>Because other API calls may be made from within the first API call, we need to maintain a counter to determine which was the first and correspondingly the last return.</p>
<p>When a thread makes an API call, the macro <code>H5_API_SET_CANCEL</code> calls the worker function <code>H5_cancel_count_inc()</code> which does the following: </p><ol>
<li>
if this is the first time the thread has entered the library, a new cancellability structure needs to be assigned to it. </li>
<li>
if the thread is already within the library when the API call is made, then cancel_count is simply incremented. Otherwise, we set the cancellability state to <code>PTHREAD_CANCEL_DISABLE</code> while storing the previous state into the cancellability structure. <code>cancel_count</code> is also incremented in this case. </li>
</ol>
<p>When a thread leaves an API call, the macro <code>H5_API_UNSET_CANCEL</code> calls the worker function <code>H5_cancel_count_dec()</code> which does the following: </p><ol>
<li>
if <code>cancel_count</code> is greater than 1, indicating that the thread is not yet about to leave the library, then <code>cancel_count</code> is simply decremented. </li>
<li>
otherwise, we reset the cancellability state back to its original state before it entered the library and decrement the count (back to zero). </li>
</ol>
<p><code>H5_cancel_count_inc</code> and <code>H5_cancel_count_dec</code> are described in Appendix <a class="el" href="thread-safe-lib.html#subsec_tsafe_app_D">Thread cancellation mechanisms</a> and may be found in <code>H5TS.c</code>.</p>
<h1><a class="anchor" id="sec_tsafe_test"></a>
Test programs</h1>
<p>Except where stated, all tests involve 16 simultaneous threads that make use of HDF5 API calls without any explicit synchronization typically required in a non-threadsafe environment.</p>
<h2><a class="anchor" id="subsec_tsafe_test_create"></a>
Data set create and write</h2>
<p>The test program sets up 16 threads to simultaneously create 16 different datasets named from <em>zero</em> to <em>fifteen</em> for a single file and then writing an integer value into that dataset equal to the dataset's named value.</p>
<p>The main thread would join with all 16 threads and attempt to match the resulting HDF5 file with expected results - that each dataset contains the correct value (0 for <em>zero</em>, 1 for <em>one</em> etc ...) and all datasets were correctly created.</p>
<p>The test is implemented in the file <code>ttsafe_dcreate.c</code>.</p>
<h2><a class="anchor" id="subsec_tsafe_test_err"></a>
Test on error stack</h2>
<p>The error stack test is one in which 16 threads simultaneously try to create datasets with the same name. The result, when properly serialized, should be equivalent to 16 attempts to create the dataset with the same name.</p>
<p>The error stack implementation runs correctly if it reports 15 instances of the dataset name conflict error and finally generates a correct HDF5 containing that single dataset. Each thread should report its own stack of errors with a thread number associated with it.</p>
<p>The test is implemented in the file <code>ttsafe_error.c</code>.</p>
<h2><a class="anchor" id="subsec_tsafe_test_cancel"></a>
Test on cancellation safety</h2>
<p>The main idea in thread cancellation safety is as follows; a child thread is spawned to create and write to a dataset. Following that, it makes a <code>H5Diterate</code> call on that dataset which activates a callback function.</p>
<p>A deliberate barrier is invoked at the callback function which waits for both the main and child thread to arrive at that point. After that happens, the main thread proceeds to make a thread cancel call on the child thread while the latter sleeps for 3 seconds before proceeding to write a new value to the dataset.</p>
<p>After the iterate call, the child thread logically proceeds to wait another 3 seconds before writing another newer value to the dataset.</p>
<p>The test is correct if the main thread manages to read the second value at the end of the test. This means that cancellation did not take place until the end of the iteration call despite of the 3 second wait within the iteration callback and the extra dataset write operation. Furthermore, the cancellation should occur before the child can proceed to write the last value into the dataset.</p>
<h2><a class="anchor" id="subsec_tsafe_test_attr"></a>
Test on attribute creation</h2>
<p>A main thread makes 16 threaded calls to <code>H5Acreate</code> with a generated name for each attribute. Sixteen attributes should be created for the single dataset in random (chronological) order and receive values depending on its generated attribute name (e.g. <em>attrib010</em> would receive the value 10).</p>
<p>After joining with all child threads, the main thread proceeds to read each attribute by generated name to see if the value tallies. Failure is detected if the attribute name does not exist (meaning they were never created) or if the wrong values were read back.</p>
<h1><a class="anchor" id="sec_tsafe_app"></a>
Appendix</h1>
<h2><a class="anchor" id="subsec_tsafe_app_A"></a>
Recursive Lock implementation code</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> H5_mutex_init(H5_mutex_t *H5_mutex)</div>
<div class="line">{</div>
<div class="line">   H5_mutex-&amp;gt;owner_thread = NULL;</div>
<div class="line">   pthread_mutex_init(&amp;amp;H5_mutex-&amp;gt;atomic_lock, NULL);</div>
<div class="line">   pthread_cond_init(&amp;amp;H5_mutex-&amp;gt;cond_var, NULL);</div>
<div class="line">  H5_mutex-&amp;gt;lock_count = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> H5_mutex_lock(H5_mutex_t *H5_mutex)</div>
<div class="line">{</div>
<div class="line">   pthread_mutex_lock(&amp;amp;H5_mutex-&amp;gt;atomic_lock);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span> (pthread_equal(pthread_self(), H5_mutex-&amp;gt;owner_thread)) {</div>
<div class="line">      <span class="comment">// already owned by self - increment count</span></div>
<div class="line">      H5_mutex-&amp;gt;lock_count++;</div>
<div class="line">   } </div>
<div class="line">   <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (H5_mutex-&amp;gt;owner_thread == NULL) {</div>
<div class="line">          <span class="comment">// no one else has locked it - set owner and grab lock</span></div>
<div class="line">          H5_mutex-&amp;gt;owner_thread = pthread_self();</div>
<div class="line">          H5_mutex-&amp;gt;lock_count = 1;</div>
<div class="line">      } </div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">/* if already locked by someone else */</span></div>
<div class="line">          <span class="keywordflow">while</span> (1) {</div>
<div class="line">              pthread_cond_wait(&amp;amp;H5_mutex-&amp;gt;cond_var, &amp;amp;H5_mutex-&amp;gt;atomic_lock);</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">if</span> (H5_mutex-&amp;gt;owner_thread == NULL) {</div>
<div class="line">                  H5_mutex-&amp;gt;owner_thread = pthread_self();</div>
<div class="line">                  H5_mutex-&amp;gt;lock_count = 1;</div>
<div class="line">                  <span class="keywordflow">break</span>;</div>
<div class="line">              } <span class="comment">// else do nothing and loop back to wait on condition</span></div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   pthread_mutex_unlock(&amp;amp;H5_mutex-&amp;gt;atomic_lock);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> H5_mutex_unlock(H5_mutex_t *H5_mutex)</div>
<div class="line">{</div>
<div class="line">   pthread_mutex_lock(&amp;amp;H5_mutex-&amp;gt;atomic_lock);</div>
<div class="line">   H5_mutex-&amp;gt;lock_count--;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span> (H5_mutex-&amp;gt;lock_count == 0) {</div>
<div class="line">      H5_mutex-&amp;gt;owner_thread = NULL;</div>
<div class="line">      pthread_cond_signal(&amp;amp;H5_mutex-&amp;gt;cond_var);</div>
<div class="line">   }</div>
<div class="line">   pthread_mutex_unlock(&amp;amp;H5_mutex-&amp;gt;atomic_lock);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_app_B"></a>
First thread initialization</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> H5_first_thread_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// initialize global API mutex lock</span></div>
<div class="line">  H5_g.H5_libinit_g = FALSE;</div>
<div class="line">  H5_g.init_lock.owner_thread = NULL;</div>
<div class="line">  pthread_mutex_init(&amp;amp;H5_g.init_lock.atomic_lock, NULL);</div>
<div class="line">  pthread_cond_init(&amp;amp;H5_g.init_lock.cond_var, NULL);</div>
<div class="line">  H5_g.init_lock.lock_count = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// initialize key for thread-specific error stacks</span></div>
<div class="line">  pthread_key_create(&amp;amp;H5_errstk_key_g, NULL);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// initialize key for thread cancellability mechanism</span></div>
<div class="line">  pthread_key_create(&amp;amp;H5_cancel_key_g, NULL);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_app_C"></a>
Per-thread error stack acquisition</h2>
<div class="fragment"><div class="line">H5E_t *H5E_get_stack(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  H5E_t *estack;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (estack = pthread_getspecific(H5_errstk_key_g)) {</div>
<div class="line">      <span class="keywordflow">return</span> estack;</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// no associated value with current thread - create one</span></div>
<div class="line">      estack = (H5E_t *)malloc(<span class="keyword">sizeof</span>(H5E_t));</div>
<div class="line">      pthread_setspecific(H5_errstk_key_g, (<span class="keywordtype">void</span> *)estack);</div>
<div class="line">      <span class="keywordflow">return</span> estack;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_app_D"></a>
Thread cancellation mechanisms</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> H5_cancel_count_inc(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  H5_cancel_t *cancel_counter;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cancel_counter = pthread_getspecific(H5_cancel_key_g)) {</div>
<div class="line">    <span class="comment">// do nothing here</span></div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// first time thread calls library - create new counter and</span></div>
<div class="line">    <span class="comment">// associate with key</span></div>
<div class="line">    cancel_counter = (H5_cancel_t *)malloc(<span class="keyword">sizeof</span>(H5_cancel_t));</div>
<div class="line">    cancel_counter-&amp;gt;cancel_count = 0;</div>
<div class="line">    pthread_setspecific(H5_cancel_key_g, (<span class="keywordtype">void</span> *)cancel_counter);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cancel_counter-&amp;gt;cancel_count == 0) {</div>
<div class="line">    <span class="comment">/* thread entering library */</span></div>
<div class="line">    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;amp;(cancel_counter-&amp;gt;previous_state));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  cancel_counter-&amp;gt;cancel_count++;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> H5_cancel_count_dec(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  H5_cancel_t *cancel_counter = pthread_getspecific(H5_cancel_key_g);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cancel_counter-&amp;gt;cancel_count == 1)</div>
<div class="line">    pthread_setcancelstate(cancel_counter-&amp;gt;previous_state, NULL);</div>
<div class="line"> </div>
<div class="line">  cancel_counter-&amp;gt;cancel_count--;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_tsafe_app_E"></a>
Macro expansion codes</h2>
<h3><a class="anchor" id="subsubsec_tsafe_app_E1"></a>
&lt;code&gt;FUNC_ENTER&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Initialize the library                                   \</span></div>
<div class="line"><span class="comment">H5_FIRST_THREAD_INIT                                        \</span></div>
<div class="line"><span class="comment">H5_API_UNSET_CANCEL                                         \</span></div>
<div class="line"><span class="comment">H5_API_LOCK_BEGIN                                           \</span></div>
<div class="line"><span class="comment">  if (!(H5_INIT_GLOBAL)) {                                  \</span></div>
<div class="line"><span class="comment">    H5_INIT_GLOBAL = TRUE;                                  \</span></div>
<div class="line"><span class="comment">      if (H5_init_library() &amp;lt; 0) {                       \</span></div>
<div class="line"><span class="comment">        HRETURN_ERROR (H5E_FUNC, H5E_CANTINIT, err,         \</span></div>
<div class="line"><span class="comment">                      &quot;library initialization failed&quot;);     \</span></div>
<div class="line"><span class="comment">      }                                                     \</span></div>
<div class="line"><span class="comment">  }                                                         \</span></div>
<div class="line"><span class="comment">  H5_API_LOCK_END                                           \</span></div>
<div class="line"><span class="comment">           :</span></div>
<div class="line">           :</div>
<div class="line">           :</div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E2"></a>
&lt;code&gt;H5_FIRST_THREAD_INIT&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Macro for first thread initialization</span></div>
<div class="line"><span class="preprocessor">#define H5_FIRST_THREAD_INIT                                \</span></div>
<div class="line"><span class="preprocessor">  pthread_once(&amp;amp;H5_first_init_g, H5_first_thread_init);</span></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E3"></a>
&lt;code&gt;H5_API_UNSET_CANCEL&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_UNSET_CANCEL                                 \</span></div>
<div class="line"><span class="preprocessor">  if (H5_IS_API(__func__)) {                                \</span></div>
<div class="line"><span class="preprocessor">    H5_cancel_count_inc();                                  \</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E4"></a>
&lt;code&gt;H5_API_LOCK_BEGIN&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_LOCK_BEGIN                                   \</span></div>
<div class="line"><span class="preprocessor">   if (H5_IS_API(__func__)) {                               \</span></div>
<div class="line"><span class="preprocessor">     H5_mutex_lock(&amp;amp;H5_g.init_lock);</span></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E5"></a>
&lt;code&gt;H5_API_LOCK_END&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_LOCK_END }</span></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E6"></a>
&lt;code&gt;HRETURN&lt;/code&gt; and &lt;code&gt;HRETURN_ERROR&lt;/code&gt;</h3>
<div class="fragment"><div class="line">          :</div>
<div class="line">          :</div>
<div class="line">  H5_API_UNLOCK_BEGIN                                       \</div>
<div class="line">  H5_API_UNLOCK_END                                         \</div>
<div class="line">  H5_API_SET_CANCEL                                         \</div>
<div class="line">  return ret_val;                                           \</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E7"></a>
&lt;code&gt;H5_API_UNLOCK_BEGIN&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_UNLOCK_BEGIN                                 \</span></div>
<div class="line"><span class="preprocessor">  if (H5_IS_API(__func__)) {                                \</span></div>
<div class="line"><span class="preprocessor">    H5_mutex_unlock(&amp;amp;H5_g.init_lock);</span></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E8"></a>
&lt;code&gt;H5_API_UNLOCK_END&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_UNLOCK_END }</span></div>
<div class="line">&lt;/pre&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_tsafe_app_E9"></a>
&lt;code&gt;H5_API_SET_CANCEL&lt;/code&gt;</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define H5_API_SET_CANCEL                                   \</span></div>
<div class="line"><span class="preprocessor">  if (H5_IS_API(__func__)) {                                \</span></div>
<div class="line"><span class="preprocessor">    H5_cancel_count_dec();                                  \</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
