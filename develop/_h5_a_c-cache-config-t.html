<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: Metadata Cache Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better serve our user community by answering the following short survey:  <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;1.15.0.417ae79</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_h5_a_c-cache-config-t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Metadata Cache Configuration</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#gcf">General configuration fields</a></li>
<li class="level1"><a href="#csicf">Cache size increase control fields</a></li>
<li class="level1"><a href="#csdcf">Cache size decrease control fields</a></li>
<li class="level1"><a href="#pcf">Parallel Configuration Fields</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="gcf"></a>
General configuration fields</h1>
<dl class="section user"><dt>version</dt><dd>Integer field containing the version number of this version of the <a class="el" href="struct_h5_a_c__cache__config__t.html">H5AC_cache_config_t</a> structure. Any instance of <a class="el" href="struct_h5_a_c__cache__config__t.html">H5AC_cache_config_t</a> passed to the cache must have a known version number, or an error will be flagged.</dd></dl>
<dl class="section user"><dt>rpt_fcn_enabled</dt><dd><p class="startdd">Boolean field used to enable and disable the default reporting function. This function is invoked every time the automatic cache resize code is run, and reports on its activities.</p>
<p class="enddd">This is a debugging function, and should normally be turned off. </p>
</dd></dl>
<dl class="section user"><dt>open_trace_file</dt><dd><p class="startdd">Boolean field indicating whether the trace_file_name field should be used to open a trace file for the cache.</p>
<p class="interdd"><em>*** DEPRECATED ***</em> Use <code>H5Fstart/stop</code> logging functions instead</p>
<p class="interdd">The trace file is a debugging feature that allow the capture of top level metadata cache requests for purposes of debugging and/or optimization. This field should normally be set to <code>FALSE</code>, as trace file collection imposes considerable overhead.</p>
<p class="enddd">This field should only be set to <code>TRUE</code> when the trace_file_name contains the full path of the desired trace file, and either there is no open trace file on the cache, or the <code>close_trace_file</code> field is also <code>TRUE</code>. </p>
</dd></dl>
<dl class="section user"><dt>close_trace_file</dt><dd><p class="startdd">Boolean field indicating whether the current trace file (if any) should be closed.</p>
<p class="interdd"><em>*** DEPRECATED ***</em> Use <code>H5Fstart/stop</code> logging functions instead</p>
<p class="enddd">See the above comments on the open_trace_file field. This field should be set to <code>FALSE</code> unless there is an open trace file on the cache that you wish to close. </p>
</dd></dl>
<dl class="section user"><dt>trace_file_name</dt><dd><p class="startdd">Full path of the trace file to be opened if the open_trace_file field is <code>TRUE</code>.</p>
<p class="interdd"><em>*** DEPRECATED ***</em> Use <code>H5Fstart/stop</code> logging functions instead</p>
<p class="interdd">In the parallel case, an ascii representation of the mpi rank of the process will be appended to the file name to yield a unique trace file name for each process.</p>
<p class="enddd">The length of the path must not exceed <a class="el" href="_h5_a_cpublic_8h.html#a717f1f3545cfc3d1b2208c96cc0c3bd3">H5AC__MAX_TRACE_FILE_NAME_LEN</a> characters. </p>
</dd></dl>
<dl class="section user"><dt>evictions_enabled</dt><dd><p class="startdd">Boolean field used to either report the current evictions enabled status of the cache, or to set the cache's evictions enabled status.</p>
<p class="interdd">In general, the metadata cache should always be allowed to evict entries. However, in some cases it is advantageous to disable evictions briefly, and thereby postpone metadata writes. However, this must be done with care, as the cache can grow quickly. If you do this, re-enable evictions as soon as possible and monitor cache size.</p>
<p class="enddd">At present, evictions can only be disabled if automatic cache resizing is also disabled (that is, <code>(incr_mode == H5C_incr__off ) &amp;&amp; ( decr_mode == H5C_decr__off )</code>). There is no logical reason why this should be so, but it simplifies implementation and testing, and I can't think of any reason why it would be desirable. If you can think of one, I'll revisit the issue. (JM) </p>
</dd></dl>
<dl class="section user"><dt>set_initial_size</dt><dd>Boolean flag indicating whether the size of the initial size of the cache is to be set to the value given in the initial_size field. If set_initial_size is <code>FALSE</code>, the initial_size field is ignored.</dd></dl>
<dl class="section user"><dt>initial_size</dt><dd>If enabled, this field contain the size the cache is to be set to upon receipt of this structure. Needless to say, initial_size must lie in the closed interval <code>[min_size, max_size]</code>.</dd></dl>
<dl class="section user"><dt>min_clean_fraction</dt><dd><code>double</code> in the range 0 to 1 indicating the fraction of the cache that is to be kept clean. This field is only used in parallel mode. Typical values are 0.1 to 0.5.</dd></dl>
<dl class="section user"><dt>max_size</dt><dd>Maximum size to which the cache can be adjusted. The supplied value must fall in the closed interval <code>[MIN_MAX_CACHE_SIZE, MAX_MAX_CACHE_SIZE]</code>. Also, <code>max_size</code> must be greater than or equal to <code>min_size</code>.</dd></dl>
<dl class="section user"><dt>min_size</dt><dd>Minimum size to which the cache can be adjusted. The supplied value must fall in the closed interval <code>[H5C__MIN_MAX_CACHE_SIZE, H5C__MAX_MAX_CACHE_SIZE]</code>. Also, <code>min_size</code> must be less than or equal to <code>max_size</code>.</dd></dl>
<dl class="section user"><dt>epoch_length</dt><dd><p class="startdd">Number of accesses on the cache over which to collect hit rate stats before running the automatic cache resize code, if it is enabled.</p>
<p class="enddd">At the end of an epoch, we discard prior hit rate data and start collecting afresh. The epoch_length must lie in the closed interval <code>[H5C__MIN_AR_EPOCH_LENGTH, H5C__MAX_AR_EPOCH_LENGTH]</code>. </p>
</dd></dl>
<h1><a class="anchor" id="csicf"></a>
Cache size increase control fields</h1>
<dl class="section user"><dt>incr_mode</dt><dd>Instance of the <code>H5C_cache_incr_mode</code> enumerated type whose value indicates how we determine whether the cache size should be increased. At present there are two possible values: <ul>
<li><code>H5C_incr__off:</code> Don't attempt to increase the size of the cache automatically.<br  />
 When this increment mode is selected, the remaining fields in the cache size increase section ar ignored. </li>
<li><code>H5C_incr__threshold:</code> Attempt to increase the size of the cache whenever the average hit rate over the last epoch drops below the value supplied in the <code>lower_hr_threshold</code> field.<br  />
 Note that this attempt will fail if the cache is already at its maximum size, or if the cache is not already using all available space.</li>
</ul>
Note that you must set <code>decr_mode</code> to <code>H5C_incr__off</code> if you disable metadata cache entry evictions.</dd></dl>
<dl class="section user"><dt>lower_hr_threshold</dt><dd><p class="startdd">Lower hit rate threshold. If the increment mode (<code>incr_mode</code>) is <code>H5C_incr__threshold</code> and the hit rate drops below the value supplied in this field in an epoch, increment the cache size by <code>size_increment</code>. Note that cache size may not be incremented above <code>max_size</code>, and that the increment may be further restricted by the <code>max_increment</code> field if it is enabled.</p>
<p class="enddd">When enabled, this field must contain a value in the range [0.0, 1.0]. Depending on the <code>incr_mode</code> selected, it may also have to be less than <code>upper_hr_threshold</code>. </p>
</dd></dl>
<dl class="section user"><dt>increment</dt><dd><p class="startdd">Double containing the multiplier used to derive the new cache size from the old if a cache size increment is triggered. The increment must be greater than 1.0, and should not exceed 2.0.</p>
<p class="enddd">The new cache size is obtained my multiplying the current max cache size by the increment, and then clamping to <code>max_size</code> and to stay within the <code>max_increment</code> as necessary. </p>
</dd></dl>
<dl class="section user"><dt>apply_max_increment</dt><dd>Boolean flag indicating whether the <code>max_increment</code> field should be used to limit the maximum cache size increment.</dd></dl>
<dl class="section user"><dt>max_increment</dt><dd>If enabled by the <code>apply_max_increment</code> field described above, this field contains the maximum number of bytes by which the cache size can be increased in a single re-size.</dd></dl>
<dl class="section user"><dt>flash_incr_mode</dt><dd><p class="startdd">Instance of the <code>H5C_cache_flash_incr_mode</code> enumerated type whose value indicates whether and by which algorithm we should make flash increases in the size of the cache to accommodate insertion of large entries and large increases in the size of a single entry.</p>
<p class="interdd">The addition of the flash increment mode was occasioned by performance problems that appear when a local heap is increased to a size in excess of the current cache size. While the existing re-size code dealt with this eventually, performance was very bad for the remainder of the epoch.</p>
<p class="interdd">At present, there are two possible values for the <code>flash_incr_mode:</code> </p>
<ul>
<li><code>H5C_flash_incr__off:</code> Don't perform flash increases in the size of the cache.</li>
</ul>
<ul>
<li><code>H5C_flash_incr__add_space:</code> Let <code>x</code> be either the size of a newly newly inserted entry, or the number of bytes by which the size of an existing entry has been increased.<br  />
 If <code>x &gt; flash_threshold * current max cache size</code>, increase the current maximum cache size by <code>x * flash_multiple</code> less any free space in the cache, and star a new epoch. For now at least, pay no attention to the maximum increment.</li>
</ul>
<p>In both of the above cases, the flash increment pays no attention to the maximum increment (at least in this first incarnation), but DOES stay within max_size.</p>
<p class="interdd">With a little thought, it should be obvious that the above flash cache size increase algorithm is not sufficient for all circumstances &ndash; for example, suppose the user round robins through <code>(1/flash_threshold) +1</code> groups, adding one data set to each on each pass. Then all will increase in size at about the same time, requiring the max cache size to at least double to maintain acceptable performance, however the above flash increment algorithm will not be triggered.</p>
<p class="enddd">Hopefully, the add space algorithms detailed above will be sufficient for the performance problems encountered to date. However, we should expect to revisit the issue. </p>
</dd></dl>
<dl class="section user"><dt>flash_multiple</dt><dd>Double containing the multiple described above in the <code>H5C_flash_incr__add_space</code> section of the discussion of the <code>flash_incr_mode</code> section. This field is ignored unless <code>flash_incr_mode</code> is <code>H5C_flash_incr__add_space</code>.</dd></dl>
<dl class="section user"><dt>flash_threshold</dt><dd>Double containing the factor by which current max cache size is multiplied to obtain the size threshold for the add_space flash increment algorithm. The field is ignored unless <code>flash_incr_mode</code> is <code>H5C_flash_incr__add_space</code>.</dd></dl>
<h1><a class="anchor" id="csdcf"></a>
Cache size decrease control fields</h1>
<dl class="section user"><dt>decr_mode</dt><dd><p class="startdd">Instance of the <code>H5C_cache_decr_mode</code> enumerated type whose value indicates how we determine whether the cache size should be decreased. At present there are four possibilities.</p>
<ul>
<li><code>H5C_decr__off:</code> Don't attempt to decrease the size of the cache automatically.<br  />
 When this increment mode is selected, the remaining fields in the cache size decrease section are ignored. </li>
<li><code>H5C_decr__threshold:</code> Attempt to decrease the size of the cache whenever the average hit rate over the last epoch rises above the value supplied in the <code>upper_hr_threshold</code> field. </li>
<li><code>H5C_decr__age_out:</code> At the end of each epoch, search the cache for entries that have not been accessed for at least the number of epochs specified in the epochs_before_eviction field, and evict these entries. Conceptually, the maximum cache size is then decreased to match the new actual cache size. However, this reduction may be modified by the <code>min_size</code>, the <code>max_decrement</code>, and/or the <code>empty_reserve</code>. </li>
<li><code>H5C_decr__age_out_with_threshold:</code> Same as age_out, but we only attempt to reduce the cache size when the hit rate observed over the last epoch exceeds the value provided in the <code>upper_hr_threshold</code> field.</li>
</ul>
<p>Note that you must set <code>decr_mode</code> to <code>H5C_decr__off</code> if you disable metadata cache entry evictions. </p>
</dd></dl>
<dl class="section user"><dt>upper_hr_threshold</dt><dd><p class="startdd">Upper hit rate threshold. The use of this field varies according to the current <code>decr_mode</code> :</p>
<p class="interdd"><code>H5C_decr__off</code> or <code>H5C_decr__age_out:</code> The value of this field is ignored.</p>
<ul>
<li><code>H5C_decr__threshold:</code> If the hit rate exceeds this threshold in any epoch, attempt to decrement the cache size by size_decrement.<br  />
 Note that cache size may not be decremented below <code>min_size</code>.<br  />
 Note also that if the <code>upper_threshold</code> is 1.0, the cache size<br  />
 will never be reduced.</li>
</ul>
<ul>
<li><code>H5C_decr__age_out_with_threshold:</code> If the hit rate exceeds this threshold in any epoch, attempt to reduce the cache size by evicting entries that have not been accessed for more than the specified number of epochs. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>decrement</dt><dd><p class="startdd">This field is only used when the decr_mode is <code>H5C_decr__threshold</code>.</p>
<p class="enddd">The field is a double containing the multiplier used to derive the new cache size from the old if a cache size decrement is triggered. The decrement must be in the range 0.0 (in which case the cache will try to contract to its minimum size) to 1.0 (in which case the cache will never shrink). </p>
</dd></dl>
<dl class="section user"><dt>apply_max_decrement</dt><dd>Boolean flag used to determine whether decrements in cache size are to be limited by the <code>max_decrement</code> field.</dd></dl>
<dl class="section user"><dt>max_decrement</dt><dd>Maximum number of bytes by which the cache size can be decreased in a single re-size. Note that decrements may also be restricted by the <code>min_size</code> of the cache, and (in age out modes) by the <code>empty_reserve</code> field.</dd></dl>
<dl class="section user"><dt>epochs_before_eviction</dt><dd><p class="startdd">Integer field used in <code>H5C_decr__age_out</code> and <code>H5C_decr__age_out_with_threshold</code> decrement modes.</p>
<p class="enddd">This field contains the number of epochs an entry must remain unaccessed before it is evicted in an attempt to reduce the cache size. If applicable, this field must lie in the range <code>[1, H5C__MAX_EPOCH_MARKERS]</code>. </p>
</dd></dl>
<dl class="section user"><dt>apply_empty_reserve</dt><dd>Boolean field controlling whether the empty_reserve field is to be used in computing the new cache size when the decr_mode is H5C_decr__age_out or H5C_decr__age_out_with_threshold.</dd></dl>
<dl class="section user"><dt>empty_reserve</dt><dd><p class="startdd">To avoid a constant racheting down of cache size by small amounts in the <code>H5C_decr__age_out</code> and <code>H5C_decr__age_out_with_threshold</code> modes, this field allows one to require that any cache size reductions leave the specified fraction of unused space in the cache.</p>
<p class="enddd">The value of this field must be in the range [0.0, 1.0]. I would expect typical values to be in the range of 0.01 to 0.1. </p>
</dd></dl>
<h1><a class="anchor" id="pcf"></a>
Parallel Configuration Fields</h1>
<p>In PHDF5, all operations that modify metadata must be executed collectively.</p>
<p>We used to think that this was enough to ensure consistency across the metadata caches, but since we allow processes to read metadata individually, the order of dirty entries in the LRU list can vary across processes, which can result in inconsistencies between the caches.</p>
<p>PHDF5 uses several strategies to prevent such inconsistencies in metadata, all of which use the fact that the same stream of dirty metadata is seen by all processes for purposes of synchronization. This is done by having each process count the number of bytes of dirty metadata generated, and then running a "sync point" whenever this count exceeds a user specified threshold (see <code>dirty_bytes_threshold</code> below).</p>
<p>The current metadata write strategy is indicated by the <code>metadata_write_strategy</code> field. The possible values of this field, along with the associated metadata write strategies are discussed below.</p>
<dl class="section user"><dt>dirty_bytes_threshold</dt><dd><p class="startdd">Threshold of dirty byte creation used to synchronize updates between caches. (See above for outline and motivation.)</p>
<p class="enddd">This value MUST be consistent across all processes accessing the file. This field is ignored unless HDF5 has been compiled for parallel. </p>
</dd></dl>
<dl class="section user"><dt>metadata_write_strategy</dt><dd>Integer field containing a code indicating the desired metadata write strategy. The valid values of this field are enumerated and discussed below:</dd></dl>
<ul>
<li><a class="el" href="_h5_a_cpublic_8h.html#a5ef1a23a562608db819d7e805f490404">H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY</a><br  />
 When metadata_write_strategy is set to this value, only process zero is allowed to write dirty metadata to disk. All other processes must retain dirty metadata until they are informed at a sync point that the dirty metadata in question has been written to disk.<br  />
 When the sync point is reached (or when there is a user generated flush), process zero flushes sufficient entries to bring it into compliance with its min clean size (or flushes all dirty entries in the case of a user generated flush), broad casts the list of entries just cleaned to all the other processes, and then exits the sync point.<br  />
 Upon receipt of the broadcast, the other processes mark the indicated entries as clean, and leave the sync point as well.</li>
</ul>
<ul>
<li><a class="el" href="_h5_a_cpublic_8h.html#af7cea0f4927dfafa3017a34e2b84cce3">H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED</a><br  />
 In the distributed metadata write strategy, process zero still makes the decisions as to what entries should be flushed, but the actual flushes are distributed across the processes in the computation to the extent possible.<br  />
 In this strategy, when a sync point is triggered (either by dirty metadata creation or manual flush), all processes enter a barrier.<br  />
 On the other side of the barrier, process 0 constructs an ordered list of the entries to be flushed, and then broadcasts this list to the caches in all the processes.<br  />
 All processes then scan the list of entries to be flushed, flushing some, and marking the rest as clean. The algorithm for this purpose ensures that each entry in the list is flushed exactly once, and all are marked clean in each cache.<br  />
 Note that in the case of a flush of the cache, no message passing is necessary, as all processes have the same list of dirty entries, and all of these entries must be flushed. Thus in this case it is sufficient for each process to sort its list of dirty entries after leaving the initial barrier, and use this list as if it had been received from process zero.<br  />
 To avoid possible messages from the past/future, all caches must wait until all caches are done before leaving the sync point. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
