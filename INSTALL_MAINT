Information for HDF5 maintainers:

* You can run make from any directory.  However, running in a
  subdirectory only knows how to build things in that directory and
  below.  However, all makefiles know when their target depends on
  something outside the local directory tree:

	$ cd test
	$ make
	make: *** No rule to make target ../src/libhdf5.a

* All Makefiles understand the following targets:

        all              -- build locally.
        install          -- install libs, headers, progs.
        uninstall        -- remove installed files.
        mostlyclean      -- remove temp files (eg, *.o but not *.a).
        clean            -- mostlyclean plus libs and progs.
        distclean        -- all non-distributed files.
        maintainer-clean -- all derived files but H5config.h.in and configure.

* Most Makefiles also understand:

	TAGS		-- build a tags table
	dep, depend	-- recalculate source dependencies
	lib		-- build just the libraries w/o programs

* If you have personal preferences for which make, compiler, compiler
  flags, preprocessor flags, etc., that you use and you don't want to
  set environment variables, then use a site configuration file.

  When configure starts, it looks in the config directory for files
  whose name is some combination of the CPU name, vendor, and
  operating system in this order:

	CPU-VENDOR-OS
	VENDOR-OS
	CPU-VENDOR
	OS
	VENDOR
	CPU

  The first file which is found is sourced and can therefore affect
  the behavior of the rest of configure. See config/BlankForm for the
  template.

* If you use GNU make along with gcc the Makefile will contain targets
  that automatically maintain a list of source interdependencies; you
  seldom have to say `make clean'.  I say `seldom' because if you
  change how one `*.h' file includes other `*.h' files you'll have
  to force an update.

  To force an update of all dependency information remove the
  `.depend' file from each directory and type `make'.  For
  instance:

	$ cd $HDF5_HOME
	$ find . -name .depend -exec rm {} \;
	$ make

  If you're not using GNU make and gcc then dependencies come from
  ".distdep" files in each directory.  Those files are generated on
  GNU systems and inserted into the Makefile's by running
  config.status (which happens near the end of configure).

* If you use GNU make along with gcc then the Perl script `trace' is
  run just before dependencies are calculated to update any H5TRACE()
  calls that might appear in the file.  Otherwise, after changing the
  type of a function (return type or argument types) one should run
  `trace' manually on those source files (e.g., ../bin/trace *.c).

* Object files stay in the directory and are added to the library as a
  final step instead of placing the file in the library immediately
  and removing it from the directory.  The reason is three-fold:

	1.  Most versions of make don't allow `$(LIB)($(SRC:.c=.o))'
	    which makes it necessary to have two lists of files, one
	    that ends with `.c' and the other that has the library
	    name wrapped around each `.o' file.

	2.  Some versions of make/ar have problems with modification
	    times of archive members.

	3.  Adding object files immediately causes problems on SMP
	    machines where make is doing more than one thing at a
	    time.

* When using GNU make on an SMP you can cause it to compile more than
  one thing at a time.  At the top of the source tree invoke make as

	$ make -j -l6

  which causes make to fork as many children as possible as long as
  the load average doesn't go above 6.  In subdirectories one can say

	$ make -j2

  which limits the number of children to two (this doesn't work at the
  top level because the `-j2' is not passed to recursive makes).
