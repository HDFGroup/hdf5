## config/conclude.am
## (Use double hashes for copyright notice so that automake treats it as
## comments and does not pass it to Makefile.in)
## Copyright by The HDF Group.
## All rights reserved.
##
## This file is part of HDF5.  The full HDF5 copyright notice, including
## terms governing use, modification, and redistribution, is contained in
## the COPYING file, which can be found at the root of the source code
## distribution tree, or in https://www.hdfgroup.org/licenses.
## If you do not have access to either file, you may request a copy from
## help@hdfgroup.org.


## Textually included at the end of most HDF5 Makefiles.am.
## Contains build rules.

# Automake needs to be taught how to build lib, progs and tests targets.
# These will be filled in automatically for the most part (e.g.,
# lib_LIBRARIES are built for lib target), but EXTRA_LIB, EXTRA_PROG, and
# EXTRA_TEST variables are supplied to allow the user to force targets to
# be built at certain times.
LIB = $(lib_LIBRARIES) $(lib_LTLIBRARIES) $(noinst_LIBRARIES)                 \
      $(noinst_LTLIBRARIES) $(check_LIBRARIES) $(check_LTLIBRARIES) $(EXTRA_LIB)
PROGS = $(bin_PROGRAMS) $(bin_SCRIPTS) $(noinst_PROGRAMS) $(noinst_SCRIPTS)   \
        $(EXTRA_PROG)
chk_TESTS = $(check_PROGRAMS) $(check_SCRIPTS) $(EXTRA_TEST)
TESTS = $(TEST_PROG) $(TEST_SCRIPT) $(EXTRA_TEST)

TEST_EXTENSIONS = .sh
SH_LOG_COMPILER = $(SHELL)
AM_SH_LOG_FLAGS =
REALTIMEOUTPUT = $(realtimeOutput)

# lib/progs/tests targets recurse into subdirectories. build-* targets
# build files in this directory.
build-lib: $(LIB)
build-progs: $(LIB) $(PROGS)
build-tests: $(LIB) $(PROGS) $(chk_TESTS)

# General rule for recursive building targets.
# BUILT_SOURCES contain targets that need to be built before anything else
# in the directory (e.g., for Fortran type detection)
lib progs tests check-s check-p :: $(BUILT_SOURCES)
	@$(MAKE) $(AM_MAKEFLAGS) build-$@ || exit 1;
	@for d in X $(SUBDIRS); do                                             \
	    if test $$d != X && test $$d != .; then                           \
	        (set -x; cd $$d && $(MAKE) $(AM_MAKEFLAGS) $@) || exit 1;     \
	    fi;                                                               \
	done

# General rule for recursive cleaning targets.  Like the rule above,
# but doesn't require building BUILT_SOURCES.
check-clean ::
	@$(MAKE) $(AM_MAKEFLAGS) build-$@ || exit 1;
	@for d in X $(SUBDIRS); do                                             \
	    if test $$d != X && test $$d != .; then                           \
	        (set -x; cd $$d && $(MAKE) $(AM_MAKEFLAGS) $@) || exit 1;     \
	    fi;                                                               \
	done

# Tell Automake to build tests when the user types `make all' (this is
# not its default behavior).  Also build EXTRA_LIB and EXTRA_PROG since
# Automake won't build them automatically, either.
all-local: $(EXTRA_LIB) $(EXTRA_PROG) $(chk_TESTS)

# make install-doc doesn't do anything outside of doc directory, but
# Makefiles should recognize it.
# UPDATE: docs no longer reside in this build tree, so this target
# is deprecated.
install-doc uninstall-doc:
	@echo "Nothing to be done."

# clean up files generated by tests so they can be re-run.
build-check-clean:
	$(RM) -rf $(CHECK_CLEANFILES)

# run check-clean whenever mostlyclean is run
mostlyclean-local: build-check-clean

# check-install is just a synonym for installcheck
check-install: installcheck

# Run each test in order, passing $(TEST_FLAGS) to the program.
# Since tests are done in a shell loop, "make -i" does apply inside it.
# Set HDF5_Make_Ignore to a non-blank string to ignore errors inside the loop.
# The timestamps give a rough idea how much time the tests use.
#
# Note that targets in chk_TESTS (defined above) will be built when the user
# types 'make tests' or 'make check', but only programs in TEST_PROG,
# TEST_PROG_PARA, or TEST_SCRIPT will actually be executed.
check-TESTS: test

test _test:
	@$(MAKE) build-check-s
	@$(MAKE) build-check-p

# Actual execution of check-s.
build-check-s: $(LIB) $(PROGS) $(chk_TESTS)
	@if test -n "$(TEST_PROG)$(TEST_SCRIPT)"; then      \
	   echo "===Serial tests in `echo ${PWD} | sed -e s:.*/::` begin `date`==="; \
	fi
	@$(MAKE) $(AM_MAKEFLAGS) _exec_check-s
	@if test -n "$(TEST_PROG)$(TEST_SCRIPT)"; then      \
	    echo "===Serial tests in `echo ${PWD} | sed -e s:.*/::` ended `date`===";\
	fi

TEST_PROG_CHKEXE=$(TEST_PROG:=.chkexe_)
TEST_PROG_PARA_CHKEXE=$(TEST_PROG_PARA:=.chkexe_)
TEST_SCRIPT_CHKSH=$(TEST_SCRIPT:=.chkexe_)
TEST_SCRIPT_PARA_CHKSH=$(TEST_SCRIPT_PARA:=.chkexe_)

_exec_check-s: $(TEST_PROG_CHKEXE) $(TEST_SCRIPT_CHKSH)

# The dummy.chkexe here prevents the target from being
# empty if there are no tests in the current directory.
# $${log} is the log file.
# $${tname} is the name of test.
$(TEST_PROG_CHKEXE) $(TEST_PROG_PARA_CHKEXE) dummy.chkexe_:
	@if test "X$@" != "X.chkexe_" && test "X$@" != "Xdummy.chkexe_"; then \
	   tname=$(@:.chkexe_=)$(EXEEXT);\
	   log=$(@:.chkexe_=.chklog); \
	   echo "============================"; \
	   if [ $(@:.chkexe_=.chkexe) -nt $${tname} ]; then \
	      echo "No need to test $${tname} again."; \
	   else \
              if test -n "$(REALTIMEOUTPUT)"; then \
                 echo "============================" | tee $${log}; \
              else \
                 echo "============================" > $${log}; \
              fi; \
              if test "X$(FORTRAN_API)" = "Xyes"; then \
                 echo "Fortran API: Testing $${tname} $(TEST_FLAGS)"; \
                 if test -n "$(REALTIMEOUTPUT)"; then \
                    echo "Fortran API: Test log for $${tname} $(TEST_FLAGS)" | tee -a $${log}; \
                 else \
                    echo "Fortran API: Test log for $${tname} $(TEST_FLAGS)" >> $${log}; \
                 fi; \
              elif test "X$(CXX_API)" = "Xyes"; then \
                 echo "C++ API: Testing $${tname} $(TEST_FLAGS)"; \
                 if test -n "$(REALTIMEOUTPUT)"; then \
                    echo "C++ API: Test log for $${tname} $(TEST_FLAGS)" | tee -a $${log};\
                 else \
                    echo "C++ API: Test log for $${tname} $(TEST_FLAGS)" >> $${log};\
                 fi; \
              else \
                 echo "Testing: $${tname} $(TEST_FLAGS)"; \
                 if test -n "$(REALTIMEOUTPUT)"; then \
                    echo "Test log for $${tname} $(TEST_FLAGS)" | tee -a $${log}; \
                 else \
                    echo "Test log for $${tname} $(TEST_FLAGS)" >> $${log}; \
                 fi; \
              fi; \
              if test -n "$(REALTIMEOUTPUT)"; then \
                if test -n "$(HDF5_VOL_CONNECTOR)"; then \
                  echo "VOL connector: $(HDF5_VOL_CONNECTOR)" | tee -a $${log}; \
                fi; \
                if test -n "$(HDF5_DRIVER)"; then \
                  echo "Virtual file driver (VFD): $(HDF5_DRIVER)" | tee -a $${log}; \
                fi; \
              else \
                if test -n "$(HDF5_VOL_CONNECTOR)"; then \
                  echo "VOL connector: $(HDF5_VOL_CONNECTOR)" >> $${log}; \
                fi; \
                if test -n "$(HDF5_DRIVER)"; then \
                  echo "Virtual file driver (VFD): $(HDF5_DRIVER)" >> $${log}; \
                fi; \
              fi; \
              if test -n "$(REALTIMEOUTPUT)"; then \
                 echo "============================" | tee -a $${log}; \
              else \
                 echo "============================" >> $${log}; \
              fi; \
              if test -n "$(REALTIMEOUTPUT)"; then \
                 srcdir="$(srcdir)" \
                 $(TIME) $(RUNEXEC) ./$${tname} $(TEST_FLAGS) | tee -a $${log} 2>&1 \
                 && touch $(@:.chkexe_=.chkexe) || \
                 (test $$HDF5_Make_Ignore && echo "*** Error ignored") || \
                 (cat $${log} && false) || exit 1; \
              else \
                 srcdir="$(srcdir)" \
                 $(TIME) $(RUNEXEC) ./$${tname} $(TEST_FLAGS) >> $${log} 2>&1 \
                 && touch $(@:.chkexe_=.chkexe) || \
                 (test $$HDF5_Make_Ignore && echo "*** Error ignored") || \
                 (cat $${log} && false) || exit 1; \
              fi; \
	      echo "" >> $${log}; \
              if test -n "$(REALTIMEOUTPUT)"; then \
                 echo "Finished testing $${tname} $(TEST_FLAGS)" | tee -a $${log}; \
                 echo "============================" | tee -a $${log}; \
              else \
                 echo "Finished testing $${tname} $(TEST_FLAGS)" >> $${log}; \
                 echo "============================" >> $${log}; \
              fi; \
              if test -z "$(REALTIMEOUTPUT)"; then \
                 cat $${log}; \
              fi; \
	   fi; \
	fi

# The dummysh.chkexe here prevents the target from being
# empty if there are no tests in the current directory.
# $${log} is the log file.
# $${tname} is the name of test.
$(TEST_SCRIPT_CHKSH) $(TEST_SCRIPT_PARA_CHKSH) dummysh.chkexe_:
	@if test "X$@" != "X.chkexe_" && test "X$@" != "Xdummysh.chkexe_"; then \
	   cmd=$(@:.chkexe_=);\
	   tname=`basename $$cmd`;\
	   chkname=`basename $(@:.chkexe_=.chkexe)`;\
	   log=`basename $(@:.chkexe_=.chklog)`; \
	   echo "============================"; \
	   newer=true; \
	   for i in $${cmd} $(SCRIPT_DEPEND); do \
              if [ $${chkname} -ot $$i ]; then \
		 newer=false; \
		 break; \
	      fi; \
           done; \
	   if $${newer}; then \
	      echo "No need to test $${tname} again."; \
	   else \
	      echo "============================" > $${log}; \
	      if test "X$(FORTRAN_API)" = "Xyes"; then \
	         echo "Fortran API: Testing $${tname} $(TEST_FLAGS)"; \
	         echo "Fortran API: $${tname} $(TEST_FLAGS) Test Log" >> $${log}; \
	      elif test "X$(CXX_API)" = "Xyes"; then \
	         echo "C++ API: Testing $${tname} $(TEST_FLAGS)"; \
	         echo "C++ API: $${tname} $(TEST_FLAGS) Test Log" >> $${log}; \
	      else \
	         echo "Testing $${tname} $(TEST_FLAGS)"; \
	         echo "$${tname} $(TEST_FLAGS) Test Log" >> $${log}; \
	      fi; \
	      echo "============================" >> $${log}; \
	      RUNSERIAL="$(RUNSERIAL)" RUNPARALLEL="$(RUNPARALLEL)"           \
	      srcdir="$(srcdir)" \
	         $(TIME) $(SHELL) $$cmd $(TEST_FLAGS) >> $${log} 2>&1 \
	         && touch $${chkname} || \
	         (test $$HDF5_Make_Ignore && echo "*** Error ignored") || \
	         (cat $${log} && false) || exit 1; \
	      echo "" >> $${log}; \
	      echo "Finished testing $${tname} $(TEST_FLAGS)" >> $${log}; \
	      echo "============================" >> $${log}; \
	      echo "Finished testing $${tname} $(TEST_FLAGS)"; \
	      cat $${log}; \
	   fi; \
	   echo "============================"; \
	fi

# Actual execution of check-p.
build-check-p: $(LIB) $(PROGS) $(chk_TESTS)
	@if test -n "$(TEST_PROG_PARA)$(TEST_SCRIPT_PARA)"; then      \
	   echo "===Parallel tests in `echo ${PWD} | sed -e s:.*/::` begin `date`==="; \
	fi
	@if test -n "$(TEST_PROG_PARA)"; then                                \
	    echo "**** Hint ****";                                            \
	    echo "Parallel test files reside in the current directory"        \
	         "by default.";                                               \
	    echo "Set HDF5_PARAPREFIX to use another directory. e.g.,";       \
	    echo "    HDF5_PARAPREFIX=/PFS/user/me";                          \
	    echo "    export HDF5_PARAPREFIX";                                \
	    echo "    make check";                                            \
	    echo "**** end of Hint ****";                                     \
	fi
	@for test in $(TEST_PROG_PARA) dummy; do                             \
	   if test $$test != dummy; then                                      \
	      $(MAKE) $(AM_MAKEFLAGS) $$test.chkexe_ \
	      RUNEXEC="$(RUNPARALLEL)" || exit 1; \
	   fi;                                                                \
	done
	@for test in $(TEST_SCRIPT_PARA) dummy; do                           \
	  if test $$test != dummy; then                                      \
	    $(MAKE) $(AM_MAKEFLAGS) $$test.chkexe_ || exit 1; \
	  fi;                                                                 \
	done
	@if test -n "$(TEST_PROG_PARA)$(TEST_SCRIPT_PARA)"; then      \
	    echo "===Parallel tests in `echo ${PWD} | sed -e s:.*/::` ended `date`===";\
	fi

VFD_LIST = sec2 stdio core core_paged split multi family splitter

# log VFD currently has file space allocation bugs
# VFD_LIST += log

if DIRECT_VFD_CONDITIONAL
  VFD_LIST += direct
endif
if BUILD_PARALLEL_CONDITIONAL
  # MPI I/O VFD is currently incompatible with too many tests in the VFD test set
  # VFD_LIST += mpio
endif
if MIRROR_VFD_CONDITIONAL
  # Mirror VFD needs network configuration, etc. and isn't easy to set
  # reasonable defaults for that info.
  # VFD_LIST += mirror
endif
if ROS3_VFD_CONDITIONAL
  VFD_LIST += ros3
endif
if HDFS_VFD_CONDITIONAL
  VFD_LIST += hdfs
endif
if SUBFILING_VFD_CONDITIONAL
  # Several VFD tests fail with Subfiling since it
  # doesn't currently support collective I/O
  # VFD_LIST += subfiling
endif

# Run test with different Virtual File Driver
check-vfd: $(LIB) $(PROGS) $(chk_TESTS)
	@for vfd in $(VFD_LIST) dummy; do                                     \
	    if test $$vfd != dummy; then                                      \
	        echo "============================";                          \
	        echo "Testing Virtual File Driver $$vfd";                     \
	        echo "============================";                          \
	        $(MAKE) $(AM_MAKEFLAGS) check-clean || exit 1;                \
	        HDF5_DRIVER=$$vfd $(MAKE) $(AM_MAKEFLAGS) check || exit 1;    \
	    fi;                                                               \
	done

# Test with just the native connector, with a single pass-through connector
# and with a doubly-stacked pass-through.
#
# native = 0
# pass-through = 1
VOL_LIST = native "pass_through under_vol=0;under_info={}" \
           "pass_through under_vol=1;under_info={under_vol=0;under_info={}}"

# Run test with different passthrough Virtual Object Layer Connector
# NOTE: Will only succeed with passthrough VOL connectors that use
#       the native VOL connector as the terminal connector.
check-passthrough-vol: $(LIB) $(PROGS) $(chk_TESTS)
	@for vol in $(VOL_LIST) dummy; do                                     \
	    if test "$$vol" != dummy; then                                    \
	        echo "============================";                          \
	        echo "Testing VOL Connector: \"$$vol\"";                      \
	        echo "============================";                          \
	        $(MAKE) $(AM_MAKEFLAGS) check-clean || exit 1;                \
	        HDF5_VOL_CONNECTOR="$$vol" $(MAKE) $(AM_MAKEFLAGS) check || exit 1;    \
	    fi;                                                               \
	done
