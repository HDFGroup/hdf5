#!/usr/bin/env bash
#
# Copyright by The HDF Group.
# All rights reserved.
#
# This file is part of HDF5.  The full HDF5 copyright notice, including
# terms governing use, modification, and redistribution, is contained in
# the COPYING file, which can be found at the root of the source code
# distribution tree, or in https://www.hdfgroup.org/licenses.
# If you do not have access to either file, you may request a copy from
# help@hdfgroup.org.
#
BLD='\033[1m'
GRN='\033[0;32m'
RED='\033[0;31m'
PUR='\033[0;35m'
CYN='\033[0;36m'
NC='\033[0m' # No Color

############################################################
# Usage                                                    #
############################################################
function usage() {
   echo ""
   # Display usage
   echo "Purpose: Combine subfiles into a single HDF5 file. Requires the subfiling
         configuration file either as a command-line argument, or the script will
         search for the *.config file in the current directory."
   echo ""
   echo "usage: h5fuse.sh [-h] [-f filename] [-v] [-q] [-i] [-o]"
   echo "-h            Print this help."
   echo "-v            Verbose output."
   echo "-q            Quiet all output."
   echo "-i            Ignore missing subfiles. Useful for node local storage."
   echo "-o filename   HDF5 output file."
   echo "-f filename   Subfile configuration file."
   echo ""
}

############################################################
############################################################
# Main program                                             #
############################################################
############################################################

############################################################
# Process the input options. Add options as needed.        #
############################################################
# Get the options
file_config=""
verbose="false"
quiet="false"
ignore="false"
hdf5_file=""
while getopts "ihqvf:o:" option; do
   case $option in
      h) # display Help
         usage
         exit;;
      f) # subfiling configuration dir
         file_config=$OPTARG;;
      q) # quiet all output
         quiet="true";;
      i) # ignore missing subfiles
         ignore="true";;
      v) # verbose output
         verbose="true";;
      o) # HDF5 fused file
         hdf5_file=$OPTARG;;
     \?) # Invalid option
         usage
         exit 1;;
     * ) usage
         exit 1;;
   esac
done

FAILED=1
nfiles=1
############################################################
# Configure file checks                                    #
############################################################
#
SUBF_CONFDIR="${H5FD_SUBFILING_SUBFILE_PREFIX:-.}"
WRKDIR=$PWD

# cd to the subfiles location
cd "$SUBF_CONFDIR"
# cp the configure file from the global file system
cp "$WRKDIR/*.config" . > /dev/null 2>&1

if [ -z "$file_config" ]; then
    nfiles=$(find "$SUBF_CONFDIR" -maxdepth 1 -type f -iname "*.config" -printf '.' | wc -m)
    if [[ "$nfiles" != "1" ]]; then
      if [[ "$nfiles" == "0" ]]; then
         echo -e "$RED Failed to find .config file in current directory. $NC"
         usage
         exit $FAILED
      else
         echo -e "$RED More than one .config file found in current directory. $NC"
         usage
         exit $FAILED
      fi
    fi
    file_config=$(find "$SUBF_CONFDIR" -maxdepth 1 -type f -iname '*.config')
fi

if [ ! -f "$file_config" ]; then
    echo -e "${RED} configuration file ${BLD}$file_config${NC} ${RED}does not exist. $NC"
    exit $FAILED
fi

stripe_size=$(grep "stripe_size=" "$file_config"  | cut -d "=" -f2)
if test -z "$stripe_size"; then
    echo -e "$RED failed to find stripe_size in $file_config $NC"
    exit $FAILED
fi

if [ "$hdf5_file" = "" ]; then
    hdf5_file="$(grep "hdf5_file=" "$file_config"  | cut -d "=" -f2)"
    if test -z "$hdf5_file"; then
        echo -e "$RED failed to find hdf5 output file in $file_config $NC"
        exit $FAILED
    fi
fi

subfile_dir="$(grep "subfile_dir=" "$file_config"  | cut -d "=" -f2)"
if test -z "$subfile_dir"; then
    echo -e "$RED failed to find subfile directory in $file_config $NC"
    exit $FAILED
fi

# For bash 4.4+
mapfile -t subfiles < <( sed -e '1,/subfile_dir=/d' "$file_config" )
#for i in "${subfiles[@]}"; do
#      echo "$i"
#done
if [ ${#subfiles[@]} -eq 0 ]; then
    echo -e "$RED failed to find subfiles list in $file_config $NC"
    exit $FAILED
fi
nsubfiles=${#subfiles[@]}
#rm -f "$hdf5_file"

## COMBINE SUBFILES INTO AN HDF5 FILE ##
skip=0
START="$(date +%s%N)"

skip=0
seek=0
seek_cnt=0
subfile_exists="true"
for i in "${subfiles[@]}"; do
    subfile="${subfile_dir}/${i}"
    fsize=0
    # Verify the file exists, it might not for node-local storage.
    if [ ! -f "${subfile}" ]; then
        if [ "${ignore}" == "false" ];then
            echo -e "$RED ERROR: file \"${subfile}\" does not exist. $NC"
            exit $FAILED
        fi
        subfile_exists="false"
    else
        subfile_exists="true"
        # Get the number of bytes of the file
        fsize=$(wc -c "${subfile}" | awk '{print $1}')
    fi

    # bs=BYTES read and write up to BYTES bytes at a time; overrides ibs and obs
    # ibs=BYTES read up to BYTES bytes at a time
    # obs=BYTES write BYTES bytes at a time
    # seek=N skip N obs-sized blocks at start of output
    # skip=N skip N ibs-sized blocks at start of input

    status=1
    if [ "$subfile_exists" == "false" ]; then
        seek_cnt=$((seek_cnt+1))
        seek=$seek_cnt
    else
      # If the subfile is empty, skip fusing it
      if [ "$fsize" -ne 0 ]; then
        records_left=$fsize
        while [ "$status" -gt 0 ]; do
            if [ $((skip*stripe_size)) -le "$fsize"  ] && [ "$records_left" -gt 0 ]; then
                EXEC="dd count=1 bs=$stripe_size if=$subfile of=$hdf5_file skip=$skip seek=$seek conv=notrunc"
                if [ "$quiet" == "false" ]; then
                    echo -e "$GRN $EXEC $NC"
                fi
                err="$( $EXEC > /dev/null 2>&1 &)"
                if [ "$verbose" == "true" ]; then
                    echo -e "$CYN" $err "$NC"
                fi
                records_left=$((records_left-stripe_size))
                skip=$((skip+1))
                seek=$((seek_cnt+skip*nsubfiles))
            else
                status=0
                skip=0
            fi
        done; wait
        seek_cnt=$((seek_cnt+1))
        seek=$seek_cnt
      fi
   fi
done; wait

END=$(( $(date +%s%N) - START ))
DURATION_SEC=$(awk -vp="$END" -vq=0.000000001 'BEGIN{printf "%.4f" ,p * q}')
if [ "$quiet" == "false" ]; then
    echo -e "$PUR COMPLETION TIME = $DURATION_SEC s $NC"
fi
