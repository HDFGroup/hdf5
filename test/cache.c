/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright by The HDF Group.                                               *
 * All rights reserved.                                                      *
 *                                                                           *
 * This file is part of HDF5.  The full HDF5 copyright notice, including     *
 * terms governing use, modification, and redistribution, is contained in    *
 * the COPYING file, which can be found at the root of the source code       *
 * distribution tree, or in https://www.hdfgroup.org/licenses.               *
 * If you do not have access to either file, you may request a copy from     *
 * help@hdfgroup.org.                                                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 *        This file contains tests for the cache implemented in H5C.c
 */
#include "cache_common.h"
#include "H5MFprivate.h"

H5C_t *saved_cache = NULL; /* store the pointer to the instance of
                            * of H5C_t created by H5Fcreate()
                            * here between test cache setup and
                            * shutdown.
                            */

haddr_t saved_actual_base_addr = HADDR_UNDEF; /* Store the address of the
                                               * space allocated for cache items in the file between
                                               * cache setup & takedown
                                               */

hid_t saved_fapl_id = H5P_DEFAULT; /* store the fapl id here between
                                    * cache setup and takedown.  Note
                                    * that if saved_fapl_id == H5P_DEFAULT,
                                    * we assume that there is no fapl to
                                    * close.
                                    */

hid_t saved_fcpl_id = H5P_DEFAULT; /* store the fcpl id here between
                                    * cache setup and takedown.  Note
                                    * that if saved_fcpl_id == H5P_DEFAULT,
                                    * we assume that there is no fcpl to
                                    * close.
                                    */

hid_t saved_fid = H5I_INVALID_HID; /* store the file id here between cache setup
                                    * and takedown.
                                    */
bool write_permitted         = true;
bool try_core_file_driver    = false;
bool core_file_driver_failed = false;

/* global variable declarations: */

static const char *FILENAME[] = {"cache_test", NULL};

/* private typedef declarations: */

struct flush_cache_test_spec {
    int          entry_num;
    int          entry_type;
    int          entry_index;
    bool         insert_flag;
    unsigned int flags;
    bool         expected_deserialized;
    bool         expected_serialized;
    bool         expected_destroyed;
};

struct pe_flush_cache_test_spec {
    int          entry_num;
    int          entry_type;
    int          entry_index;
    bool         insert_flag;
    unsigned int flags;
    int          num_pins;
    int          pin_type[MAX_PINS];
    int          pin_idx[MAX_PINS];
    bool         expected_deserialized;
    bool         expected_serialized;
    bool         expected_destroyed;
};

struct fo_flush_entry_check {
    int    entry_num;
    int    entry_type;
    int    entry_index;
    size_t expected_size;
    bool   in_cache;
    bool   at_main_addr;
    bool   is_dirty;
    bool   is_protected;
    bool   is_pinned;
    bool   expected_deserialized;
    bool   expected_serialized;
    bool   expected_destroyed;
};

struct fo_flush_cache_test_spec {
    int             entry_num;
    int             entry_type;
    int             entry_index;
    bool            insert_flag;
    unsigned int    flags;
    bool            resize_flag;
    size_t          new_size;
    int             num_pins;
    int             pin_type[MAX_PINS];
    int             pin_idx[MAX_PINS];
    int             num_flush_ops;
    struct flush_op flush_ops[MAX_FLUSH_OPS];
    bool            expected_deserialized;
    bool            expected_serialized;
    bool            expected_destroyed;
};

struct move_entry_test_spec {
    int  entry_type;
    int  entry_index;
    bool is_pinned;
    bool is_protected;
};

struct pinned_single_entry_test_spec {
    int          test_num;
    int          entry_type;
    int          entry_idx;
    bool         dirty_flag;
    bool         mark_dirty;
    bool         pop_mark_dirty_prot;
    bool         pop_mark_dirty_pinned;
    bool         unprotect_unpin;
    unsigned int flags;
    unsigned int flush_flags;
    bool         expected_serialized;
    bool         expected_destroyed;
};

/* private function declarations: */

static unsigned smoke_check_1(int express_test, unsigned paged);
static unsigned smoke_check_2(int express_test, unsigned paged);
static unsigned smoke_check_3(int express_test, unsigned paged);
static unsigned smoke_check_4(int express_test, unsigned paged);
static unsigned smoke_check_5(int express_test, unsigned paged);
static unsigned smoke_check_6(int express_test, unsigned paged);
static unsigned smoke_check_7(int express_test, unsigned paged);
static unsigned smoke_check_8(int express_test, unsigned paged);
static unsigned smoke_check_9(int express_test, unsigned paged);
static unsigned smoke_check_10(int express_test, unsigned paged);
static unsigned write_permitted_check(int express_test, unsigned paged);
static unsigned check_insert_entry(unsigned paged);
static unsigned check_flush_cache(unsigned paged);
static void     check_flush_cache__empty_cache(H5F_t *file_ptr);
static void     check_flush_cache__multi_entry(H5F_t *file_ptr);
static void     check_flush_cache__multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                                    unsigned int spec_size, struct flush_cache_test_spec spec[]);
static void check_flush_cache__pe_multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                                   unsigned int                    spec_size,
                                                   struct pe_flush_cache_test_spec spec[]);
static void check_flush_cache__single_entry(H5F_t *file_ptr);
static void check_flush_cache__single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                                 bool insert_flag, unsigned int flags,
                                                 unsigned int flush_flags, bool expected_deserialized,
                                                 bool expected_serialized, bool expected_destroyed);
static void check_flush_cache__pinned_single_entry_test(H5F_t *file_ptr, int test_num, int entry_type,
                                                        int entry_idx, bool unprot_dirty_flag,
                                                        bool mark_dirty, bool pop_mark_dirty_prot,
                                                        bool pop_mark_dirty_pinned, bool unprotect_unpin,
                                                        unsigned int flags, unsigned int flush_flags,
                                                        bool expected_serialized, bool expected_destroyed);
static void check_flush_cache__flush_ops(H5F_t *file_ptr);
static void check_flush_cache__flush_op_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                             int spec_size, const struct fo_flush_cache_test_spec spec[],
                                             unsigned init_expected_index_len,
                                             size_t init_expected_index_size, unsigned expected_index_len,
                                             size_t expected_index_size, int check_size,
                                             struct fo_flush_entry_check check[]);
static void check_flush_cache__flush_op_eviction_test(H5F_t *file_ptr);
static unsigned check_get_entry_status(unsigned paged);
static unsigned check_expunge_entry(unsigned paged);
static unsigned check_multiple_read_protect(unsigned paged);
static unsigned check_move_entry(unsigned paged);
static void     check_move_entry__run_test(H5F_t *file_ptr, unsigned test_num,
                                           struct move_entry_test_spec *spec_ptr);
static unsigned check_pin_protected_entry(unsigned paged);
static unsigned check_resize_entry(unsigned paged);
static unsigned check_evictions_enabled(unsigned paged);
static unsigned check_flush_protected_err(unsigned paged);
static unsigned check_destroy_pinned_err(unsigned paged);
static unsigned check_destroy_protected_err(unsigned paged);
static unsigned check_duplicate_insert_err(unsigned paged);
static unsigned check_double_pin_err(unsigned paged);
static unsigned check_double_unpin_err(unsigned paged);
static unsigned check_pin_entry_errs(unsigned paged);
static unsigned check_double_protect_err(unsigned paged);
static unsigned check_double_unprotect_err(unsigned paged);
static unsigned check_mark_entry_dirty_errs(unsigned paged);
static unsigned check_expunge_entry_errs(unsigned paged);
static unsigned check_move_entry_errs(unsigned paged);
static unsigned check_resize_entry_errs(unsigned paged);
static unsigned check_unprotect_ro_dirty_err(unsigned paged);
static unsigned check_protect_ro_rw_err(unsigned paged);
static unsigned check_protect_retries(unsigned paged);
static unsigned check_check_evictions_enabled_err(unsigned paged);
static unsigned check_auto_cache_resize(bool cork_ageout, unsigned paged);
static unsigned check_auto_cache_resize_disable(unsigned paged);
static unsigned check_auto_cache_resize_epoch_markers(unsigned paged);
static unsigned check_auto_cache_resize_input_errs(unsigned paged);
static unsigned check_auto_cache_resize_aux_fcns(unsigned paged);
static unsigned check_metadata_blizzard_absence(bool fill_via_insertion, unsigned paged);
static unsigned check_flush_deps(unsigned paged);
static unsigned check_flush_deps_err(unsigned paged);
static unsigned check_flush_deps_order(unsigned paged);
static unsigned check_notify_cb(unsigned paged);
static unsigned check_metadata_cork(bool fill_via_insertion, unsigned paged);
static unsigned check_entry_deletions_during_scans(unsigned paged);
static void     cedds__expunge_dirty_entry_in_flush_test(H5F_t *file_ptr);
static void     cedds__H5C_make_space_in_cache(H5F_t *file_ptr);
static void     cedds__H5C__autoadjust__ageout__evict_aged_out_entries(H5F_t *file_ptr);
static void     cedds__H5C_flush_invalidate_cache__bucket_scan(H5F_t *file_ptr);
static unsigned check_stats(unsigned paged);
#if H5C_COLLECT_CACHE_STATS
static void check_stats__smoke_check_1(H5F_t *file_ptr);
#endif /* H5C_COLLECT_CACHE_STATS */

static H5F_t *setup_cache(size_t max_cache_size, size_t min_clean_size, unsigned paged);

static void takedown_cache(H5F_t *file_ptr, bool dump_stats, bool dump_detailed_stats);

/**************************************************************************/
/**************************************************************************/
/********************************* tests: *********************************/
/**************************************************************************/
/**************************************************************************/

/*-------------------------------------------------------------------------
 * Function:    smoke_check_1()
 *
 * Purpose:    A basic functional test, inserts, destroys, and moves in
 *              the mix, along with repeated protects and unprotects.
 *        All entries are marked as clean.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_1(int express_test, unsigned paged)
{
    bool    show_progress    = false;
    int     dirty_unprotects = false;
    int     dirty_destroys   = false;
    bool    display_stats    = false;
    int32_t lag              = 10;
    int32_t max_index        = (10 * 1024) - 1;
    int     mile_stone       = 1;
    H5F_t  *file_ptr         = NULL;

    if (paged)
        TESTING("smoke check #1P -- all clean, ins, dest, ren, 4/2 MB cache");
    else
        TESTING("smoke check #1 -- all clean, ins, dest, ren, 4/2 MB cache");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024), paged);

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ false,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ false,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ false,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_1() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_2()
 *
 * Purpose:    A basic functional test, with inserts, destroys, and
 *        moves in the mix, along with some repeated protects
 *        and unprotects.  About half the entries are marked as
 *        dirty.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_2(int express_test, unsigned paged)
{
    bool    show_progress    = false;
    int     dirty_unprotects = true;
    int     dirty_destroys   = true;
    bool    display_stats    = false;
    int32_t max_index        = (10 * 1024) - 1;
    int32_t lag              = 10;
    int     mile_stone       = 1;
    H5F_t  *file_ptr         = NULL;

    if (paged)
        TESTING("smoke check #2P -- ~1/2 dirty, ins, dest, ren, 4/2 MB cache");
    else
        TESTING("smoke check #2 -- ~1/2 dirty, ins, dest, ren, 4/2 MB cache");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024), paged);

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_2() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_3()
 *
 * Purpose:    A basic functional test on a tiny cache, with inserts,
 *        destroys, and moves in the mix, along with repeated
 *        protects and unprotects.  All entries are marked as clean.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_3(int express_test, unsigned paged)
{
    bool    show_progress    = false;
    int     dirty_unprotects = false;
    int     dirty_destroys   = false;
    bool    display_stats    = false;
    int32_t max_index        = (10 * 1024) - 1;
    int32_t lag              = 10;
    int     mile_stone       = 1;
    H5F_t  *file_ptr         = NULL;

    if (paged)
        TESTING("smoke check #3P -- all clean, ins, dest, ren, 2/1 KB cache");
    else
        TESTING("smoke check #3 -- all clean, ins, dest, ren, 2/1 KB cache");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_3() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_4()
 *
 * Purpose:    A basic functional test on a tiny cache, with inserts,
 *         destroys, and moves in the mix, along with repeated
 *        protects and unprotects.  About half the entries are
 *        marked as dirty.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_4(int express_test, unsigned paged)
{
    bool    show_progress    = false;
    int     dirty_unprotects = true;
    int     dirty_destroys   = true;
    bool    display_stats    = false;
    int32_t max_index        = (10 * 1024) - 1;
    int32_t lag              = 10;
    int     mile_stone       = 1;
    H5F_t  *file_ptr         = NULL;

    if (paged)
        TESTING("smoke check #4P -- ~1/2 dirty, ins, dest, ren, 2/1 KB cache");
    else
        TESTING("smoke check #4 -- ~1/2 dirty, ins, dest, ren, 2/1 KB cache");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr               */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr               */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_4() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_5()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *        repeated protects and unprotects.  All entries are marked
 *        as clean.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_5(int express_test, unsigned paged)
{
    herr_t              result;
    bool                show_progress    = false;
    int                 dirty_unprotects = false;
    bool                display_stats    = false;
    int32_t             max_index        = 1024;
    int                 mile_stone       = 1;
    H5F_t              *file_ptr         = NULL;
    H5C_t              *cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.9,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.5};

    if (paged)
        TESTING("smoke check #5P -- all clean, ins, prot, unprot, AR cache 1");
    else
        TESTING("smoke check #5 -- all clean, ins, prot, unprot, AR cache 1");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ false);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ false);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ true,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_5() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_6()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *              repeated protects and unprotects.  About one half of all
 *        entries are marked as dirty.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_6(int express_test, unsigned paged)
{
    herr_t              result;
    bool                show_progress    = false;
    int                 dirty_unprotects = false;
    bool                display_stats    = false;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t              *file_ptr         = NULL;
    H5C_t              *cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.9,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    if (paged)
        TESTING("smoke check #6P -- ~1/2 dirty, ins, prot, unprot, AR cache 1");
    else
        TESTING("smoke check #6 -- ~1/2 dirty, ins, prot, unprot, AR cache 1");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    pass = true;

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ false);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ false);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ true,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_6() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_7()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *        repeated protects and unprotects.  All entries are marked
 *        as clean.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_7(int express_test, unsigned paged)
{
    herr_t              result;
    bool                show_progress    = false;
    int                 dirty_unprotects = false;
    bool                display_stats    = false;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t              *file_ptr         = NULL;
    H5C_t              *cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 100000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (8 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */
        H5C_decr__age_out_with_threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.9,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.1};

    if (paged)
        TESTING("smoke check #7P -- all clean, ins, prot, unprot, AR cache 2");
    else
        TESTING("smoke check #7 -- all clean, ins, prot, unprot, AR cache 2");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ false);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ false);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ true,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_7() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_8()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *              repeated protects and unprotects.  About one half of all
 *        entries are marked as dirty.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_8(int express_test, unsigned paged)
{
    herr_t              result;
    bool                show_progress    = false;
    int                 dirty_unprotects = false;
    bool                display_stats    = false;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t              *file_ptr         = NULL;
    H5C_t              *cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 100000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */
        H5C_decr__age_out_with_threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.9,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.1};

    if (paged)
        TESTING("smoke check #8P -- ~1/2 dirty, ins, prot, unprot, AR cache 2");
    else
        TESTING("smoke check #8 -- ~1/2 dirty, ins, prot, unprot, AR cache 2");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ false);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ false);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ false,
                              /* reset_stats            */ true,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ false,
                              /* do_inserts             */ true,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ false,
                               /* reset_stats            */ true,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ false,
                               /* do_inserts             */ true,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_8() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_9()
 *
 * Purpose:    A repeat of smoke check 1, only with the cache corked
 *         part of the time.
 *
 *         Recall that smoke check 1 is a basic functional test,
 *         with inserts, destroys, and moves in the mix, along
 *         with repeated protects and unprotects.  All entries are
 *         marked as clean.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_9(int express_test, unsigned paged)
{
    herr_t  result;
    bool    show_progress          = false;
    int     dirty_unprotects       = false;
    int     dirty_destroys         = false;
    bool    display_stats          = false;
    bool    display_detailed_stats = false;
    int32_t max_index              = (10 * 1024) - 1;
    int32_t lag                    = 10;
    int     mile_stone             = 1;
    H5F_t  *file_ptr               = NULL;
    H5C_t  *cache_ptr              = NULL;

    if (paged)
        TESTING("smoke check #9P -- all clean, ins, dest, ren, 4/2 MB, corked");
    else
        TESTING("smoke check #9 -- all clean, ins, dest, ren, 4/2 MB, corked");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    /* disable evictions */

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 1.\n";
        }
    }

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    /* enable evictions */

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 1.\n";
        }
    }

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled \n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 2.\n";
        }
    }

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled \n", __func__, mile_stone++,
                (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 2.\n";
        }
    }

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled \n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 3.\n";
        }
    }

    if (show_progress) /* 12 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 13 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 14 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 3.\n";
        }
    }

    if (show_progress) /* 15 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 16 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 4.\n";
        }
    }

    if (show_progress) /* 17 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 18 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_9() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_10()
 *
 * Purpose:    A repeat of smoke check 2, only with the cache corked
 *         part of the time.
 *
 *         Recall that smoke check 2 is a basic functional test,
 *         with inserts, destroys, and moves in the mix, along
 *         with some repeated protects and unprotects.  About half
 *         the entries are marked as dirty.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_10(int express_test, unsigned paged)
{
    herr_t  result;
    bool    show_progress          = false;
    int     dirty_unprotects       = true;
    int     dirty_destroys         = true;
    bool    display_stats          = false;
    bool    display_detailed_stats = false;
    int32_t max_index              = (10 * 1024) - 1;
    int32_t lag                    = 10;
    int     mile_stone             = 1;
    H5F_t  *file_ptr               = NULL;
    H5C_t  *cache_ptr              = NULL;

    if (paged)
        TESTING("smoke check #10P -- ~1/2 dirty, ins, dest, ren, 4/2 MB, corked");
    else
        TESTING("smoke check #10 -- ~1/2 dirty, ins, dest, ren, 4/2 MB, corked");

    if (paged && (express_test > 0)) {

        SKIPPED();
        return (0);
    }

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 1.\n";
        }
    }

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 1.\n";
        }
    }

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 2.\n";
        }
    }

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 2.\n";
        }
    }

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 12 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 3.\n";
        }
    }

    if (show_progress) /* 13 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ false,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 14 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't enable evictions 3.\n";
        }
    }

    if (show_progress) /* 15 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", __func__, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ true,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 16 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result < 0) {

            pass         = false;
            failure_mssg = "can't disable evictions 4.\n";
        }
    }

    if (show_progress) /* 17 */
        fprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 18 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_10() */

/*-------------------------------------------------------------------------
 * Function:    write_permitted_check()
 *
 * Purpose:    A basic test of the write permitted function.  In essence,
 *        we load the cache up with dirty entryies, set
 *        write_permitted to false, and then protect a bunch of
 *        entries.  If there are any writes while write_permitted is
 *        false, the test will fail.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
write_permitted_check(int
#if !H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
                          H5_ATTR_UNUSED
#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
                               express_test,
                      unsigned paged)
{

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS

    bool    show_progress = false;
    bool    display_stats = false;
    int32_t max_index     = (10 * 1024) - 1;
    int32_t lag           = 10;
    int     mile_stone    = 1;
    H5F_t  *file_ptr      = NULL;

#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    if (paged)
        TESTING("write permitted check -- 1/0 MB cache (paged aggregation)");
    else
        TESTING("write permitted check -- 1/0 MB cache");

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS

    switch (express_test) {
        case 0:
            max_index = (10 * 1024) - 1;
            break;

        case 1:
            max_index = (1 * 1024) - 1;
            break;

        case 2:
            max_index = (512) - 1;
            break;

        default:
            SKIPPED();
            fprintf(stdout, "    Long tests disabled.\n");
            return 0; /* <========== note return */
            break;
    }

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(1 * 1024 * 1024), (size_t)0, paged);

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ true,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ true,
                           /* dirty_unprotects       */ true);

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    write_permitted = false;

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ false,
                            /* do_moves             */ true,
                            /* move_to_main_addr    */ true,
                            /* do_destroys            */ false,
                            /* do_mult_ro_protects    */ true,
                            /* dirty_destroys         */ false,
                            /* dirty_unprotects       */ NO_CHANGE);

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    write_permitted = true;

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* do_moves             */ true,
                           /* move_to_main_addr    */ false,
                           /* do_destroys            */ false,
                           /* do_mult_ro_protects    */ true,
                           /* dirty_destroys         */ true,
                           /* dirty_unprotects       */ true);

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ true,
                /* dump_stats          */ false,
                /* dump_detailed_stats */ false);

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* max_index              */ max_index,
                           /* lag                    */ lag,
                           /* verbose                */ false,
                           /* reset_stats            */ true,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ true,
                           /* do_inserts             */ true,
                           /* dirty_unprotects       */ true);

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    write_permitted = false;

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* max_index              */ max_index,
                            /* lag                    */ lag,
                            /* verbose                */ false,
                            /* reset_stats            */ true,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ true,
                            /* do_inserts             */ false,
                            /* dirty_unprotects       */ NO_CHANGE);

    write_permitted = true;

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, true);

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    SKIPPED();

    fprintf(stdout, "    Clean and dirty LRU lists disabled.\n");

#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    return (unsigned)!pass;

} /* write_permitted_check() */

/*-------------------------------------------------------------------------
 * Function:    check_insert_entry()
 *
 * Purpose:     Verify that H5C_insert_entry behaves as expected.
 *              Test the behaviour with different flags.
 *
 *              This test was added primarily to test basic insert
 *              pinned entry functionality, but I through in explicit
 *              tests for other functionality that is tested implicitly
 *              elsewhere.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_insert_entry(unsigned paged)
{
    int                       entry_type = PICO_ENTRY_TYPE;
    int                       i;
    herr_t                    result;
    bool                      in_cache;
    bool                      is_dirty;
    bool                      is_protected;
    bool                      is_pinned;
    size_t                    entry_size;
    H5F_t                    *file_ptr  = NULL;
    H5C_t                    *cache_ptr = NULL;
    test_entry_t             *base_addr;
    test_entry_t             *entry_ptr;
    struct H5C_cache_entry_t *search_ptr;

    if (paged)
        TESTING("H5C_insert_entry() functionality (paged aggregation)");
    else
        TESTING("H5C_insert_entry() functionality");

    pass = true;

    /* Allocate a cache, and insert entries into it using all
     * combinations of flags.  Verify that the entries are inserted,
     * and that the flags have the desired effects.
     *
     * Note that the dirty parameter in insert_entry is no longer
     * used, as we have decided that all inserted entries are
     * dirty by definition. (Which sounds very reasonable, but didn't
     * used to be the case.)
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        insert_entry(file_ptr, entry_type, 0, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, entry_type, 1, H5C__PIN_ENTRY_FLAG);
    }

    /* Verify that the entries are inserted as desired. */

    i         = 0;
    base_addr = entries[0];
    while (pass && (i < 2)) {
        entry_ptr = &(base_addr[i]);

        /* Start by checking everything we can via H5C_get_entry_status() */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass         = false;
            failure_mssg = "H5C_get_entry_status() reports failure.";
        }

        if (pass) {

            /* check the universals */
            if ((!in_cache) || (!is_dirty) || (is_protected) || (entry_size != entry_sizes[entry_type])) {

                pass         = false;
                failure_mssg = "Unexpected insert results 1.";
            }
        }

        if (pass) {

            /* verify that the pinned flag got set correctly */
            if (i == 1) {

                if (!is_pinned) {

                    pass         = false;
                    failure_mssg = "Unexpected insert results 2.";
                }
            }
            else if (is_pinned) {

                pass         = false;
                failure_mssg = "Unexpected insert results 3.";
            }
            else if (is_pinned != ((entry_ptr->header).is_pinned)) {

                pass         = false;
                failure_mssg = "Unexpected insert results 4.";
            }
        }

        /* That's all we can get from H5C_get_entry_status().
         * Now start looking at the cache data structures directly.
         */

        if (pass) {

            /* Verify that pinned entries are in the pinned entry list */
            if ((entry_ptr->header).is_pinned) {

                search_ptr = cache_ptr->pel_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->next;
                }

                if (search_ptr == NULL) {

                    pass         = false;
                    failure_mssg = "Unexpected insert results 7.";
                }
            }
        }

        if (pass) {

            /* Verify that unpinned entries are in the LRU list */
            if (!((entry_ptr->header).is_pinned)) {

                search_ptr = cache_ptr->LRU_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->next;
                }

                if (search_ptr == NULL) {

                    pass         = false;
                    failure_mssg = "Unexpected insert results 8.";
                }
            }
        }

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
        if (pass) {

            /* Verify that unpinned entries are in the dirty LRU list */
            if (!((entry_ptr->header).is_pinned)) {

                search_ptr = cache_ptr->dLRU_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->aux_next;
                }

                if (search_ptr == NULL) {

                    pass         = false;
                    failure_mssg = "Unexpected insert results 9.";
                }
            }
        }
#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

        i++;

    } /* while */

    /* So much for looking at the individual entries.  Now verify
     * that the various counts and sized in the cache header are
     * as expected.
     */

    if (pass) {

        if ((cache_ptr->index_len != 2) || (cache_ptr->index_size != 2 * entry_sizes[entry_type]) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * entry_sizes[entry_type]))) ||
            (cache_ptr->pl_len != 0) || (cache_ptr->pl_size != (size_t)0) || (cache_ptr->pel_len != 1) ||
            (cache_ptr->pel_size != 1 * entry_sizes[entry_type]) || (cache_ptr->LRU_list_len != 1) ||
            (cache_ptr->LRU_list_size != 1 * entry_sizes[entry_type])
#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
            || (cache_ptr->dLRU_list_len != 1) ||
            (cache_ptr->dLRU_list_size != 1 * entry_sizes[entry_type]) || (cache_ptr->cLRU_list_len != 0) ||
            (cache_ptr->cLRU_list_size != (size_t)0)
#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
        ) {

            pass         = false;
            failure_mssg = "Unexpected insert results 10.";
        }
    }

    /* Finally, if stats collection is enabled, verify that the expected
     * stats are collected.
     */
#if H5C_COLLECT_CACHE_STATS
    if (pass) {

        if ((cache_ptr->insertions[entry_type] != 2) || (cache_ptr->pinned_insertions[entry_type] != 1) ||
            (cache_ptr->pins[entry_type] != 1) || (cache_ptr->unpins[entry_type] != 0) ||
            (cache_ptr->dirty_pins[entry_type] != 0) || (cache_ptr->max_index_len != 2) ||
            (cache_ptr->max_index_size != 2 * entry_sizes[entry_type]) || (cache_ptr->max_pl_len != 0) ||
            (cache_ptr->max_pl_size != (size_t)0) || (cache_ptr->max_pel_len != 1) ||
            (cache_ptr->max_pel_size != 1 * entry_sizes[entry_type])) {

            pass         = false;
            failure_mssg = "Unexpected insert results 11.";
        }
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* Unpin the pinned entries so we can take down the cache cleanly. */

    if (pass) {

        unpin_entry(entry_type, 1);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_insert_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache()
 *
 * Purpose:    Verify that flush_cache behaves as expected.  In particular,
 *        test the behaviour with different flags.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_cache(unsigned paged)
{
    H5F_t *file_ptr = NULL;

    if (paged)
        TESTING("H5C_flush_cache() functionality (paged aggregation)");
    else
        TESTING("H5C_flush_cache() functionality");

    pass = true;

    /* allocate a cache, and flush it under various circumstances.
     * To the extent possible, verify that the desired actions took
     * place.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);
    }

    /* first test behaviour on an empty cache.  Can't do much sanity
     * checking in this case, so simply check the return values.
     */

    if (pass) {

        check_flush_cache__empty_cache(file_ptr);
    }

    /* now do a series of similar tests with a cache with a single entry.
     * Start with a clean entry, with no flags set.
     */

    if (pass) {

        check_flush_cache__single_entry(file_ptr);
    }

    if (pass) {

        check_flush_cache__multi_entry(file_ptr);
    }

    if (pass) {

        check_flush_cache__flush_ops(file_ptr);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_flush_cache() */

/*-------------------------------------------------------------------------
 *
 * Function:    check_flush_cache__empty_cache()
 *
 * Purpose :    Verify that flush_cache behaves as expected with an empty
 *              cache.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__empty_cache(H5F_t *file_ptr)
{
    H5C_t *cache_ptr = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = false;
        failure_mssg = "cache_ptr NULL on entry to empty cache case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = false;
        failure_mssg = "cache not empty at beginning of empty cache case.";
    }

    /* Test behaviour on an empty cache.  Can't do much sanity
     * checking in this case, so simply check the return values.
     *
     * Check of return values is done in the H5C_FLUSH_CACHE() macro.
     */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "flush with flags = 0x00 failed on empty cache.\n")
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "flush with flags = 0x04 failed on empty cache.\n")
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_CLEAR_ONLY_FLAG,
                        "flush with flags = 0x08 failed on empty cache.\n")
    }

} /* check_flush_cache__empty_cache() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__multi_entry()
 *
 * Purpose:    Verify that flush_cache behaves as expected when the cache
 *        contains multiple elements.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__multi_entry(H5F_t *file_ptr)
{
    H5C_t *cache_ptr = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = false;
        failure_mssg = "cache_ptr NULL on entry to multi entry case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = false;
        failure_mssg = "cache not empty at beginning of multi entry case.";
    }

    if (pass) {
        int                          test_num    = 1;
        unsigned int                 flush_flags = H5C__NO_FLAGS_SET;
        unsigned int                 spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {{/* entry_num             = */ 0,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 100,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 1,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 75,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 2,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 25,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 3,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 50,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 4,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 10,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 5,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 20,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 6,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 30,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 7,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 40,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 2;
        unsigned int                 flush_flags = H5C__FLUSH_INVALIDATE_FLAG;
        unsigned int                 spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {{/* entry_num             = */ 0,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 100,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 1,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 75,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 2,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 25,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 3,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 50,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 4,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 10,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 5,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 20,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 6,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 30,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 7,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 40,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ true}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 3;
        unsigned int                 flush_flags = H5C__FLUSH_CLEAR_ONLY_FLAG;
        unsigned int                 spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {{/* entry_num             = */ 0,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 100,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 1,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 75,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 2,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 25,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 3,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 50,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 4,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 10,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 5,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 20,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 6,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 30,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 7,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 40,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 4;
        unsigned int                 flush_flags = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG;
        unsigned int                 spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {{/* entry_num             = */ 0,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 100,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 1,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 75,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 2,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 25,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 3,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 50,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 4,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 10,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 5,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 20,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 6,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 30,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true},
                                                {/* entry_num             = */ 7,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 40,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ true}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    /* verify that all other flags are ignored */
    if (pass) {
        int          test_num    = 5;
        unsigned int flush_flags = (unsigned)~(H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG);
        unsigned int spec_size   = 8;
        struct flush_cache_test_spec spec[8] = {{/* entry_num             = */ 0,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 100,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 1,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 75,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 2,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 25,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 3,
                                                 /* entry_type            = */ PICO_ENTRY_TYPE,
                                                 /* entry_index           = */ 50,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 4,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 10,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ false,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 5,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 20,
                                                 /* insert_flag           = */ false,
                                                 /* flags                 = */ H5C__DIRTIED_FLAG,
                                                 /* expected_deserialized = */ true,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 6,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 30,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false},
                                                {/* entry_num             = */ 7,
                                                 /* entry_type            = */ MONSTER_ENTRY_TYPE,
                                                 /* entry_index           = */ 40,
                                                 /* insert_flag           = */ true,
                                                 /* flags                 = */ H5C__NO_FLAGS_SET,
                                                 /* expected_deserialized = */ false,
                                                 /* expected_serialized   = */ true,
                                                 /* expected_destroyed    = */ false}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    /* Now do pinned entry tests:
     *
     * For the most part, this test is directed at testing the ability
     * of the flush routine to unravel collections of pinned entries.
     */

    if (pass) {
        int                             test_num    = 1;
        unsigned int                    flush_flags = H5C__NO_FLAGS_SET;
        unsigned int                    spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num             = */ 0,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 100,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 1,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 75,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 2,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 25,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 2,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 3,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 50,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 3,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 4,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 10,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 4,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, 50, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 5,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 20,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 5,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1,
              -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, 50, 10, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 6,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 30,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 6,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE,
              MONSTER_ENTRY_TYPE, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, 50, 10, 20, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false},
            {/* entry_num             = */ 7,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 40,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 7,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE,
              MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, 50, 10, 20, 30, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ false}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                             test_num    = 2;
        unsigned int                    flush_flags = H5C__FLUSH_INVALIDATE_FLAG;
        unsigned int                    spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num             = */ 0,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 100,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 1,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 75,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 2,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 25,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 2,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 3,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 50,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 3,
             /* pin_type[MAX_PINS]    = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, 75, 25, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 4,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 10,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 5,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 20,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {MONSTER_ENTRY_TYPE, -1, -1, -1, -1 - 1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {10, -1, -1, -1 - 1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 6,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 30,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 2,
             /* pin_type[MAX_PINS]    = */ {MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {10, 20, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 7,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 40,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 3,
             /* pin_type[MAX_PINS]    = */
             {MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {10, 20, 30, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ true,
             /* expected_destroyed    = */ true}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                             test_num    = 3;
        unsigned int                    flush_flags = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG;
        unsigned int                    spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num             = */ 0,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 100,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 1,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 75,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 2,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 25,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 3,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 50,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 1,
             /* pin_type[MAX_PINS]    = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 4,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 10,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 5,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 20,
             /* insert_flag           = */ false,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ true,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 6,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 30,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true},
            {/* entry_num             = */ 7,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 40,
             /* insert_flag           = */ true,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* num_pins              = */ 0,
             /* pin_type[MAX_PINS]    = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]     = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_deserialized = */ false,
             /* expected_serialized   = */ false,
             /* expected_destroyed    = */ true}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

} /* check_flush_cache__multi_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__multi_entry_test()
 *
 * Purpose :    Run a multi entry flush cache test.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                    unsigned int spec_size, struct flush_cache_test_spec spec[])
{
    H5C_t        *cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    unsigned      u;
    size_t        total_entry_size = 0;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = false;

        snprintf(msg, (size_t)128, "cache not empty at beginning of multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = false;
        snprintf(msg, (size_t)128, "missing/bad test spec on entry to multi entry test #%d.", test_num);
        failure_mssg = msg;
    }

    u = 0;
    while (pass && (u < spec_size)) {

        if (((unsigned)spec[u].entry_num != u) || (spec[u].entry_type < 0) ||
            (spec[u].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[u].entry_index < 0) ||
            (spec[u].entry_index > max_indices[spec[u].entry_type])) {

            pass = false;
            snprintf(msg, (size_t)128, "bad data in spec[%u] on entry to multi entry test #%d.", u, test_num);
            failure_mssg = msg;
        }
        u++;
    }

    u = 0;
    while (pass && (u < spec_size)) {

        if (spec[u].insert_flag) {

            insert_entry(file_ptr, spec[u].entry_type, spec[u].entry_index, spec[u].flags);
        }
        else {

            protect_entry(file_ptr, spec[u].entry_type, spec[u].entry_index);

            unprotect_entry(file_ptr, spec[u].entry_type, spec[u].entry_index, spec[u].flags);
        }

        total_entry_size += entry_sizes[spec[u].entry_type];

        u++;
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, flush_flags, "dummy failure message.\n")

        if (!pass) {

            snprintf(msg, (size_t)128, "flush with flags 0x%x failed in multi entry test #%d.", flush_flags,
                     test_num);
            failure_mssg = msg;
        }
    }

    u = 0;
    while (pass && (u < spec_size)) {
        base_addr = entries[spec[u].entry_type];
        entry_ptr = &(base_addr[spec[u].entry_index]);

        if ((entry_ptr->deserialized != spec[u].expected_deserialized) ||
            (entry_ptr->serialized != spec[u].expected_serialized) ||
            (entry_ptr->destroyed != spec[u].expected_destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Bad status on entry %u after flush in multi entry test #%d.", u,
                     test_num);
            failure_mssg = msg;
        }
        u++;
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != spec_size) || (cache_ptr->index_size != total_entry_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after flush in multi entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG, "dummy mssg.\n")

        if (!pass) {

            pass = false;
            snprintf(msg, (size_t)128, "Flush failed on cleanup in multi entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after cleanup in multi entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    u = 0;
    while (pass && (u < spec_size)) {

        base_addr = entries[spec[u].entry_type];
        entry_ptr = &(base_addr[spec[u].entry_index]);

        entry_ptr->deserialized = false;
        entry_ptr->serialized   = false;
        entry_ptr->destroyed    = false;

        u++;
    }

} /* check_flush_cache__multi_entry_test() */

/*-------------------------------------------------------------------------
 *
 * Function:    check_flush_cache__pe_multi_entry_test()
 *
 * Purpose:     Run a multi entry flush cache test.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__pe_multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                       unsigned int spec_size, struct pe_flush_cache_test_spec spec[])
{
    H5C_t        *cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    unsigned      u;
    int           j;
    size_t        total_entry_size = 0;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = false;

        snprintf(msg, (size_t)128, "cache not empty at beginning of pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = false;
        snprintf(msg, (size_t)128, "missing/bad test spec on entry to pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }

    u = 0;
    while (pass && (u < spec_size)) {

        if (((unsigned)spec[u].entry_num != u) || (spec[u].entry_type < 0) ||
            (spec[u].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[u].entry_index < 0) ||
            (spec[u].entry_index > max_indices[spec[u].entry_type]) || (spec[u].num_pins < 0) ||
            (spec[u].num_pins > MAX_PINS)) {

            pass = false;
            snprintf(msg, (size_t)128, "bad data in spec[%u] on entry to pe multi entry test #%d.", u,
                     test_num);
            failure_mssg = msg;
        }
        u++;
    }

    u = 0;
    while (pass && (u < spec_size)) {
        if (spec[u].insert_flag) {

            insert_entry(file_ptr, spec[u].entry_type, spec[u].entry_index, spec[u].flags);
        }
        else {

            protect_entry(file_ptr, spec[u].entry_type, spec[u].entry_index);

            unprotect_entry(file_ptr, spec[u].entry_type, spec[u].entry_index, spec[u].flags);
        }

        total_entry_size += entry_sizes[spec[u].entry_type];

        for (j = 0; j < spec[u].num_pins; j++) {

            create_pinned_entry_dependency(file_ptr, spec[u].entry_type, spec[u].entry_index,
                                           spec[u].pin_type[j], spec[u].pin_idx[j]);
        }

        u++;
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, flush_flags, "dummy failure message.\n")

        if (!pass) {

            snprintf(msg, (size_t)128, "flush with flags 0x%x failed in pe multi entry test #%d.",
                     flush_flags, test_num);
            failure_mssg = msg;
        }
    }

    u = 0;
    while (pass && (u < spec_size)) {

        base_addr = entries[spec[u].entry_type];
        entry_ptr = &(base_addr[spec[u].entry_index]);

        if ((entry_ptr->deserialized != spec[u].expected_deserialized) ||
            (entry_ptr->serialized != spec[u].expected_serialized) ||
            (entry_ptr->destroyed != spec[u].expected_destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Bad status on entry %u after flush in pe multi entry test #%d.", u,
                     test_num);
            failure_mssg = msg;
        }
        u++;
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != spec_size) || (cache_ptr->index_size != total_entry_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after flush in pe multi entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG, "dummy mssg.\n")

        if (!pass) {

            pass = false;
            snprintf(msg, (size_t)128, "Flush failed on cleanup in pe multi entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after cleanup in pe multi entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    u = 0;
    while (pass && (u < spec_size)) {

        base_addr = entries[spec[u].entry_type];
        entry_ptr = &(base_addr[spec[u].entry_index]);

        entry_ptr->deserialized = false;
        entry_ptr->serialized   = false;
        entry_ptr->destroyed    = false;

        u++;
    }

} /* check_flush_cache__pe_multi_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_ops()
 *
 * Purpose:    Run the flush ops cache tests.
 *
 *         These are tests that test the cache's ability to handle
 *         the case in which the flush callback dirties, resizes,
 *         and/or moves entries.
 *
 *         Do nothing if pass is false on entry.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_ops(H5F_t *file_ptr)
{
    const int                        max_num_spec  = 10;
    const int                        max_num_check = 4;
    struct fo_flush_cache_test_spec *spec          = NULL;
    struct fo_flush_entry_check     *checks        = NULL;
    H5C_t                           *cache_ptr     = file_ptr->shared->cache;

    /* Per-test variables. Each test sets these. */
    int          test_num;
    unsigned int flush_flags;
    int          spec_size;
    int          check_size;
    unsigned     init_expected_index_len;
    size_t       init_expected_index_size;
    unsigned     expected_index_len;
    size_t       expected_index_size;

    if (cache_ptr == NULL) {

        pass         = false;
        failure_mssg = "cache_ptr NULL on entry to flush ops test.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = false;
        failure_mssg = "cache not empty at beginning of flush ops test.";
    }

    spec = malloc((size_t)max_num_spec * sizeof(struct fo_flush_cache_test_spec));
    if (spec == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate flush ops test spec array";
    }

    checks = malloc((size_t)max_num_check * sizeof(struct fo_flush_entry_check));
    if (checks == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate flush ops test check array";
    }

    if (pass) /* test #1 */
    {
        /* start with a very simple test, in which there are two entries
         * resident in cache, and the second entry dirties the first in
         * the flush callback.  No size changes, and no flush flags.
         */
        test_num                 = 1;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 2;
        check_size               = 0;
        init_expected_index_len  = 2;
        init_expected_index_size = 2 * PICO_ENTRY_SIZE;
        expected_index_len       = 2;
        expected_index_size      = 2 * PICO_ENTRY_SIZE;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ 0,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ 0,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #2 */
    {
        /* Same as test 1, only this time set the flush invalidate flag.
         * Note that we must repeat all tests with the flush invalidate flag
         * as this triggers a different set of code to execute the flush.
         *
         * Create two entries resident in cache, and have the second entry
         * dirty the first in the flush callback.
         */
        test_num                 = 2;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 2;
        check_size               = 0;
        init_expected_index_len  = 2;
        init_expected_index_size = 2 * PICO_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = 0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:        idx:    flag:    size: order_ptr*/
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #3 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function resizes the entry for which it has
         * been called.
         */
        test_num                 = 3;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE / 4;
        expected_index_len       = 1;
        expected_index_size      = VARIABLE_ENTRY_SIZE / 2;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr:*/
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #4 */
    {
        /* Repeat test #4 with the flush invalidate flag.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function resizes the entry for which it has
         * been called.
         */
        test_num                 = 4;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE / 4;
        expected_index_len       = 0;
        expected_index_size      = 0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #5 & #6 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function first resizes and then moves the
         * entry for which it has been called.
         *
         * Run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         *
         * 10/8/07 -- JRM
         * Added a resize operation to this test to satisfy the new
         * requirement that any resize of an entry on flush will always
         * be accompanied by a resize.  Note that as a result, this
         * test becomes redundant with later tests.
         */
        test_num                 = 5; /* and 6 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE;
        expected_index_len       = 1;
        expected_index_size      = VARIABLE_ENTRY_SIZE / 2;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            spec[0].flush_ops[1].flag = true;
            test_num                  = 6;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #7 & #8 */
    {
        /* Run tests 5 & 6 again, using the flush invalidate flag on the
         * second test.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function moves the entry for which it has
         * been called.
         *
         * Run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         *
         * 10/8/07 -- JRM
         * Added a resize operation to this test to satisfy the new
         * requirement that any resize of an entry on flush will always
         * be accompanied by a resize.  Note that as a result, this
         * test becomes redundant with later tests.
         */
        test_num                 = 7; /* and 8 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE;
        expected_index_len       = 1;
        expected_index_size      = VARIABLE_ENTRY_SIZE / 2;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */

        if (pass) {

            test_num                   = 8;
            flush_flags                = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len         = 0;
            expected_index_size        = 0;
            spec[0].flush_ops[1].flag  = true;
            spec[0].expected_destroyed = true;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #9 & #10 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function both resizes and moves the entry
         * for which it has been called.
         *
         * Again, we run this entry twice, as the first run moves the entry
         * to its alternate address, and the second moves it back.
         */
        test_num                 = 9; /* and 10 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE / 2;
        expected_index_len       = 1;
        expected_index_size      = VARIABLE_ENTRY_SIZE / 4;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            spec[0].flush_ops[1].flag = true;
            test_num                  = 10;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #11 & #12 */
    {
        /* Repeat the previous test with the flush invalidate flag on the
         * second test.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function both resizes and moves the entry
         * for which it has been called.
         *
         * Again, we run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         */
        test_num                 = 11; /* and 12 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 0;
        init_expected_index_len  = 1;
        init_expected_index_size = VARIABLE_ENTRY_SIZE / 2;
        expected_index_len       = 1;
        expected_index_size      = VARIABLE_ENTRY_SIZE / 4;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            test_num                   = 12;
            flush_flags                = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len         = 0;
            expected_index_size        = 0;
            spec[0].flush_ops[1].flag  = true;
            spec[0].expected_destroyed = true;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #13 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * dirties two entries that are not in cache.  No size
         * changes.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 13;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * PICO_ENTRY_SIZE;
        expected_index_len       = 3;
        expected_index_size      = 3 * PICO_ENTRY_SIZE;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ 0,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, 0, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, 0, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #14 */
    {
        /* Repeat previous test with the flush invalidate flag.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * dirties two entries that are not in cache.  No size
         * changes.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 14;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * PICO_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = (size_t)0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ 0,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 2,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, 0, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, 0, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #15 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes and dirties two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 15;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 3;
        expected_index_size = VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:            idx:    flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #16 */
    {
        /* Repeat previous test with the flush invalidate flag.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes and dirties two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 16;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = (size_t)0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #17 & #18 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes, dirties, and moves two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 17; /* and 18 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 3;
        expected_index_size = VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the moves to move the target entries back to
         * their main address.  The first test moved them to their alternate
         * address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entries are moved forward in the slist.  In the second
         * they are moved backwards.
         */
        if (pass) {

            test_num                  = 18;
            spec[0].flush_ops[2].flag = true;
            spec[0].flush_ops[5].flag = true;
            checks[0].at_main_addr    = true;
            checks[1].at_main_addr    = true;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #19 & #20 */
    {
        /* Repeat the above test with the flush invalidate flag on the
         * second test.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes, dirties, and moves two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        test_num                 = 19; /* and 20 */
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 1;
        check_size               = 2;
        init_expected_index_len  = 1;
        init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 3;
        expected_index_size = VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the moves to move the target entries back to
         * their main address.  The first test moved them to their alternate
         * address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entries are moved forward in the slist.  In the second
         * they are moved backwards.
         */
        if (pass) {

            test_num                     = 20;
            flush_flags                  = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len           = 0;
            expected_index_size          = (size_t)0;
            spec[0].expected_destroyed   = true;
            spec[0].flush_ops[2].flag    = true;
            spec[0].flush_ops[5].flag    = true;
            checks[0].at_main_addr       = true;
            checks[0].in_cache           = false;
            checks[0].expected_destroyed = true;
            checks[1].at_main_addr       = true;
            checks[1].in_cache           = false;
            checks[1].expected_destroyed = true;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #21 */
    {
        /* Mix things up some more.
         *
         * Load lots of entries, some of which have flush functions that
         * resize, dirty, and move two entries that are not in the
         * cache.
         *
         * Also load entries that have flush ops on entries that are in
         * cache.
         */
        test_num                 = 21;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 6;
        check_size               = 4;
        init_expected_index_len  = 6;
        init_expected_index_size = (2 * VARIABLE_ENTRY_SIZE) + (4 * PICO_ENTRY_SIZE);
        expected_index_len       = 10;
        expected_index_size      = (2 * VARIABLE_ENTRY_SIZE) + (2 * (VARIABLE_ENTRY_SIZE / 4)) +
                              (2 * (VARIABLE_ENTRY_SIZE / 2)) + (4 * PICO_ENTRY_SIZE);

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 11,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 10, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 10, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 10, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 12, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 12, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 12, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ false,
            /* expected_destroyed = */ false};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 10,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[5] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 5,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 20,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[2] = (struct fo_flush_entry_check){/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 10,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[3] = (struct fo_flush_entry_check){/* entry_num          = */ 3,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 12,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
        reset_entries();
    }

    if (pass) /* test #22 */
    {
        /* Repeat test #21 with the flush invalidate flag set.
         *
         * Mix things up some more.
         *
         * Load lots of entries, some of which have flush functions that
         * resize, dirty, and move two entries that are not in the
         * cache.
         *
         * Also load entries that have flush ops on entries that are in
         * cache.
         */
        test_num                 = 22;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 6;
        check_size               = 4;
        init_expected_index_len  = 6;
        init_expected_index_size = (2 * VARIABLE_ENTRY_SIZE) + (4 * PICO_ENTRY_SIZE);
        expected_index_len       = 0;
        expected_index_size      = 0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 11,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 6,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 10, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 10, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 10, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 12, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 12, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 12, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 0,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 1,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ false,
            /* expected_destroyed = */ true};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 10,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[5] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 5,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 20,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[2] = (struct fo_flush_entry_check){/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 10,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[3] = (struct fo_flush_entry_check){/* entry_num          = */ 3,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 12,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
        reset_entries();
    }

    /* So much for tests involving only flush operations.
     *
     * Now create some tests mixing flush ops and pins.
     */
    if (pass) /* test #23 */
    {
        /* Pico entries 50 and 150 pin pico entry 100, and also dirty
         * pico entry 100 on flush.
         */
        test_num                 = 23;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 3;
        check_size               = 0;
        init_expected_index_len  = 3;
        init_expected_index_size = 3 * PICO_ENTRY_SIZE;
        expected_index_len       = 3;
        expected_index_size      = 3 * PICO_ENTRY_SIZE;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 50,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 1,
            /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 150,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 1,
            /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__DIRTY, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #24 */
    {
        /* Repeat the previous test with the flush invalidate flag.
         *
         * Pico entries 50 and 150 pin pico entry 100, and also dirty
         * pico entry 100 on flush.
         */
        test_num                 = 24;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 3;
        check_size               = 0;
        init_expected_index_len  = 3;
        init_expected_index_size = 3 * PICO_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = (size_t)0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 50,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 1,
            /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ PICO_ENTRY_TYPE,
            /* entry_index        = */ 150,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 1,
            /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 1,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__DIRTY, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #25 */
    {
        /* This one is complex.
         *
         * In the following overvies table, VET stands for
         * VARIABLE_ENTRY_TYPE.
         *
         * In trying to follow what happens when we flush the
         * set of entries constructed below, recall that each
         * flush operation is executed the first time the
         * entry is flushed, and then not executed again.
         * This may be a weakness in the tests, but that
         * is the way it is for now.
         *
         * After thinking about it for a while, I'm not sure that
         * the interaction between pins and flush operations needs
         * all that much testing, as the two are essentially
         * orthoginal.  Thus this is a bit of a smoke check to
         * verify that we get the expected results.
         *
         * (VET, 100)    initially not resident in cache
         *
         * (VET, 200)    initially clean and resident in cache
         *
         * (VET, 300)    initially not resident in cache
         *
         * (VET, 2100)    initially clean and resident in cache
         *
         * (VET, 2200)    initially not resident in cache
         *
         * (VET, 2300)    initially clean and resident in cache
         *
         * (VET, 1000)    initially clean, and in cache
         *         dirties (VET, 100)
         *         resizes (VET, 200)
         *         dirty    (VET, 300) -- dirty first to bring into cache.
         *         moves (VET, 300)
         *
         * (VET, 2000)    initially clean, and in cache
         *         dirties (VET, 2100)
         *         resizes (VET, 2200)
         *         moves (VET, 2300)
         *
         * (VET, 350)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 350)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 450)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties    (VET, 1000)
         *         moves (VET, 450)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 650)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 650)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 750)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 750)
         *         pins    (VET, 2000)
         *         dirties    (VET, 2000)
         *
         * (VET, 500)    initially dirty, and in cache
         *         dirties    (VET, 350)
         *         dirties    (VET, 450)
         *         dirties    (VET, 650)
         *         dirties (VET, 750)
         */
        test_num                 = 25;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 10;
        check_size               = 3;
        init_expected_index_len  = 10;
        init_expected_index_size = 10 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 13;
        expected_index_size      = 9 * VARIABLE_ENTRY_SIZE;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 200,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2300,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1000,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2000,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2200, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[5] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 5,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 350,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 350, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[6] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 6,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 450,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 450, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[7] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 7,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 650,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 650, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[8] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 8,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 750,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 750, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[9] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 9,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 500,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 350, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 450, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 650, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 750, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 100,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 300,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};
        checks[2] = (struct fo_flush_entry_check){/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2200,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ true,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #26 */
    {
        /* Repeat test #25 with the flush invalidate flag.
         *
         * In the following overview table, VET stands for
         * VARIABLE_ENTRY_TYPE.
         *
         * In trying to follow what happens when we flush the
         * set of entries constructed below, recall that each
         * flush operation is executed the first time the
         * entry is flushed, and then not executed again.
         * This may be a weakness in the tests, but that
         * is the way it is for now.
         *
         * After thinking about it for a while, I'm not sure that
         * the interaction between pins and flush operations needs
         * all that much testing, as the two are essentially
         * orthoginal.  The big thing is to verify that flushes of
         * pinned entries with flush ops result in the expected
         * updates of the cache.
         *
         * Thus this is a bit of a smoke check to * verify that we
         * get the expected results.
         *
         * (VET, 100)    initially not resident in cache
         *
         * (VET, 200)    initially clean and resident in cache
         *
         * (VET, 300)    initially not resident in cache
         *
         * (VET, 2100)    initially clean and resident in cache
         *
         * (VET, 2200)    initially not resident in cache
         *
         * (VET, 2300)    initially clean and resident in cache
         *
         * (VET, 1000)    initially clean, and in cache
         *         dirties (VET, 100)
         *         resizes (VET, 200)
         *         dirty    (VET, 300) -- dirty first to bring into cache.
         *         moves (VET, 300)
         *
         * (VET, 2000)    initially clean, and in cache
         *         dirties (VET, 2100)
         *         resizes (VET, 2200)
         *         moves (VET, 2300)
         *
         * (VET, 350)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 350)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 450)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties    (VET, 1000)
         *         moves (VET, 450)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 650)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 650)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 750)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 750)
         *         pins    (VET, 2000)
         *         dirties    (VET, 2000)
         *
         * (VET, 500)    initially dirty, and in cache
         *         dirties    (VET, 350)
         *         dirties    (VET, 450)
         *         dirties    (VET, 650)
         *         dirties (VET, 750)
         */
        test_num                 = 26;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 10;
        check_size               = 3;
        init_expected_index_len  = 10;
        init_expected_index_size = 10 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = (size_t)0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 200,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2300,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 1000,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 2000,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2200, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[5] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 5,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 350,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 350, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[6] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 6,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 450,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 450, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[7] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 7,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 650,
            /* insert_flag        = */ true,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 650, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ false,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[8] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 8,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 750,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 2,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 750, false, VARIABLE_ENTRY_SIZE / 4, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[9] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 9,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 500,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 4,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 350, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 450, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 650, false, 0, NULL},
             {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 750, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 100,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[1] = (struct fo_flush_entry_check){/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 300,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};
        checks[2] = (struct fo_flush_entry_check){/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2200,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ true,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ true,
                                                  /* expected_serialized = */ true,
                                                  /* expected_destroyed = */ true};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #27 */
    {
        /* Test the expected fheap case, in which an entry dirties
         * and resizes itself, and dirties an entry which it has
         * pinned.
         */
        test_num                 = 27;
        flush_flags              = H5C__NO_FLAGS_SET;
        spec_size                = 5;
        check_size               = 0;
        init_expected_index_len  = 5;
        init_expected_index_size = 3 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 5;
        expected_index_size      = 4 * VARIABLE_ENTRY_SIZE;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 200,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, false, VARIABLE_ENTRY_SIZE, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 200, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 300,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {400, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 400, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 300, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 400,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 500,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 500, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 500, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ false};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ 0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #28 */
    {
        /* Repeat test #27 with the flush invalidate flag.
         *
         * Test the expected fheap case, in which an entry dirties
         * and resizes itself, and dirties an entry which it has
         * pinned.
         */
        test_num                 = 28;
        flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        spec_size                = 5;
        check_size               = 0;
        init_expected_index_len  = 5;
        init_expected_index_size = 3 * VARIABLE_ENTRY_SIZE;
        expected_index_len       = 0;
        expected_index_size      = 0;

        assert(spec_size <= max_num_spec);
        assert(check_size <= max_num_check);

        spec[0] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 0,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 100,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[1] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 1,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 200,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, false, VARIABLE_ENTRY_SIZE, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 200, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[2] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 2,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 300,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {400, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 400, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 300, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[3] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 3,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 400,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__NO_FLAGS_SET,
            /* resize_flag        = */ false,
            /* new_size           = */ 0,
            /* num_pins           = */ 0,
            /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 0,
            /* flush_ops          = */
            /*    op_code:        type:    idx:    flag:    size: order_ptr: */
            {{FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};
        spec[4] = (struct fo_flush_cache_test_spec){
            /* entry_num          = */ 4,
            /* entry_type         = */ VARIABLE_ENTRY_TYPE,
            /* entry_index        = */ 500,
            /* insert_flag        = */ false,
            /* flags              = */ H5C__DIRTIED_FLAG,
            /* resize_flag        = */ true,
            /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
            /* num_pins           = */ 1,
            /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
            /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
            /* num_flush_ops      = */ 3,
            /* flush_ops          = */
            /*    op_code:        type:        idx:        flag:    size:    order_ptr: */
            {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, false, 0, NULL},
             {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 500, false, VARIABLE_ENTRY_SIZE / 2, NULL},
             {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 500, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL},
             {FLUSH_OP__NO_OP, 0, 0, false, 0, NULL}},
            /* expected_deserialized = */ true,
            /* expected_serialized = */ true,
            /* expected_destroyed = */ true};

        checks[0] = (struct fo_flush_entry_check){/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ 0,
                                                  /* in_cache           = */ false,
                                                  /* at_main_addr       = */ false,
                                                  /* is_dirty           = */ false,
                                                  /* is_protected       = */ false,
                                                  /* is_pinned          = */ false,
                                                  /* expected_deserialized = */ false,
                                                  /* expected_serialized = */ false,
                                                  /* expected_destroyed = */ false};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    free(checks);
    free(spec);

    /* finally finish up with the flush ops eviction test */
    check_flush_cache__flush_op_eviction_test(file_ptr);

} /* check_flush_cache__flush_ops() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_op_test()
 *
 * Purpose:     Run a flush op flush cache test.  Of the nature of
 *              flush operations, this is a multi-entry test.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_op_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags, int spec_size,
                                 const struct fo_flush_cache_test_spec spec[],
                                 unsigned init_expected_index_len, size_t init_expected_index_size,
                                 unsigned expected_index_len, size_t expected_index_size, int check_size,
                                 struct fo_flush_entry_check check[])
{
    H5C_t        *cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    int           i;
    int           j;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to flush op test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = false;

        snprintf(msg, (size_t)128, "cache not empty at beginning of flush op test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = false;
        snprintf(msg, (size_t)128, "missing/bad test spec on entry to flush op test #%d.", test_num);
        failure_mssg = msg;
    }

    i = 0;
    while (pass && (i < spec_size)) {

        if ((spec[i].entry_num != i) || (spec[i].entry_type < 0) ||
            (spec[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[i].entry_index < 0) ||
            (spec[i].entry_index > max_indices[spec[i].entry_type]) || (spec[i].num_pins < 0) ||
            (spec[i].num_pins > MAX_PINS) || (spec[i].num_flush_ops < 0) ||
            (spec[i].num_flush_ops > MAX_FLUSH_OPS)) {

            pass = false;
            snprintf(msg, (size_t)128, "bad data in spec[%d] on entry to flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    i = 0;
    while (pass && (i < check_size)) {

        if ((check[i].entry_num != i) || (check[i].entry_type < 0) ||
            (check[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (check[i].entry_index < 0) ||
            (check[i].entry_index > max_indices[check[i].entry_type]) ||
            (check[i].expected_size <= (size_t)0)) {

            pass = false;
            snprintf(msg, (size_t)128, "bad data in check[%d] on entry to flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    i = 0;
    while (pass && (i < spec_size)) {

        if (spec[i].insert_flag) {

            insert_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }
        else {

            protect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index);

            if (spec[i].resize_flag)
                resize_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].new_size, true);

            unprotect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }

        for (j = 0; j < spec[i].num_pins; j++) {
            create_pinned_entry_dependency(file_ptr, spec[i].entry_type, spec[i].entry_index,
                                           spec[i].pin_type[j], spec[i].pin_idx[j]);
        }

        for (j = 0; j < spec[i].num_flush_ops; j++) {

            add_flush_op(spec[i].entry_type, spec[i].entry_index, spec[i].flush_ops[j].op_code,
                         spec[i].flush_ops[j].type, spec[i].flush_ops[j].idx, spec[i].flush_ops[j].flag,
                         spec[i].flush_ops[j].size, spec[i].flush_ops[j].order_ptr);
        }

        i++;
    }

    if (pass) {

        if ((cache_ptr->index_len != init_expected_index_len) ||
            (cache_ptr->index_size != init_expected_index_size)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size before flush in flush op test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, flush_flags, "dummy failure message")

        if (!pass) {

            pass = false;
            snprintf(msg, (size_t)128, "flush with flags 0x%x failed in flush op test #%d.", flush_flags,
                     test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while (pass && (i < spec_size)) {

        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        if ((entry_ptr->deserialized != spec[i].expected_deserialized) ||
            (entry_ptr->serialized != spec[i].expected_serialized) ||
            (entry_ptr->destroyed != spec[i].expected_destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Bad status on entry %d after flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (pass) {

        i = 0;
        while (pass && (i < check_size)) {

            if (check[i].in_cache != entry_in_cache(cache_ptr, check[i].entry_type, check[i].entry_index)) {

                pass = false;
                snprintf(msg, (size_t)128, "Check1 failed on entry %d after flush op test #%d.", i, test_num);
                failure_mssg = msg;
            }

            base_addr = entries[check[i].entry_type];
            entry_ptr = &(base_addr[check[i].entry_index]);

            if ((entry_ptr->size != check[i].expected_size) ||
                ((!entry_ptr->header.destroy_in_progress) && (check[i].in_cache) &&
                 (entry_ptr->header.size != check[i].expected_size)) ||
                (entry_ptr->at_main_addr != check[i].at_main_addr) ||
                (entry_ptr->is_dirty != check[i].is_dirty) ||
                (entry_ptr->header.is_dirty != check[i].is_dirty) ||
                (entry_ptr->is_protected != check[i].is_protected) ||
                (entry_ptr->header.is_protected != check[i].is_protected) ||
                (entry_ptr->is_pinned != check[i].is_pinned) ||
                (entry_ptr->header.is_pinned != check[i].is_pinned) ||
                (entry_ptr->deserialized != check[i].expected_deserialized) ||
                (entry_ptr->serialized != check[i].expected_serialized) ||
                (entry_ptr->destroyed != check[i].expected_destroyed)) {

                pass = false;
                snprintf(msg, (size_t)128, "Check2 failed on entry %d after flush op test #%d.", i, test_num);
                failure_mssg = msg;
            }
            i++;
        }
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != expected_index_len) ||
              (cache_ptr->index_size != expected_index_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after flush in flush op test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG, "dummy mssg.")

        if (!pass) {

            snprintf(msg, (size_t)128, "Flush failed on cleanup in flush op test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
                 (cache_ptr->clean_index_size != 0) || (cache_ptr->dirty_index_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size/cs/ds after cleanup in flush op test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while (pass && (i < spec_size)) {

        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        entry_ptr->size = entry_sizes[spec[i].entry_type];

        entry_ptr->deserialized = false;
        entry_ptr->serialized   = false;
        entry_ptr->destroyed    = false;

        i++;
    }

    i = 0;
    while (pass && (i < check_size)) {

        base_addr = entries[check[i].entry_type];
        entry_ptr = &(base_addr[check[i].entry_index]);

        entry_ptr->size = entry_sizes[check[i].entry_type];

        entry_ptr->deserialized = false;
        entry_ptr->serialized   = false;
        entry_ptr->destroyed    = false;

        i++;
    }

} /* check_flush_cache__flush_op_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_op_eviction_test()
 *
 * Purpose:     Verify that flush operations work as expected when an
 *              entry is evicted.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_op_eviction_test(H5F_t *file_ptr)
{
    struct expected_entry_status *expected  = NULL;
    H5C_t                        *cache_ptr = file_ptr->shared->cache;
    int                           i;
    const int                     num_variable_entries = 10;
    const int                     num_monster_entries  = 31;
    int                           num_large_entries    = 14;
    const int     num_total_entries = num_variable_entries + num_monster_entries + num_large_entries;
    test_entry_t *entry_ptr;
    test_entry_t *base_addr;

    expected = malloc((size_t)num_total_entries * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* the expected array is used to maintain a table of the expected status of every
         * entry used in this test.  Note that since the function that processes this
         * array only processes as much of it as it is told to, we don't have to
         * worry about maintaining the status of entries that we haven't used yet.
         */
        for (i = 0; i < num_variable_entries; i++) {
            expected[i].entry_type   = VARIABLE_ENTRY_TYPE;
            expected[i].entry_index  = (int)(i);
            expected[i].size         = VARIABLE_ENTRY_SIZE;
            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = true;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            memset(expected[i].flush_dep_par_type, 0, sizeof(expected[i].flush_dep_par_type));
            memset(expected[i].flush_dep_par_idx, 0, sizeof(expected[i].flush_dep_par_idx));

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        /* NOTE: special cases for particular variable entries */
        expected[0].size      = VARIABLE_ENTRY_SIZE / 4;
        expected[0].is_pinned = true;

        expected[1].size = VARIABLE_ENTRY_SIZE / 4;

        expected[2].is_dirty = false;

        expected[3].size = VARIABLE_ENTRY_SIZE / 4;

        expected[4].is_dirty = false;

        expected[5].size = VARIABLE_ENTRY_SIZE / 4;

        expected[6].size = VARIABLE_ENTRY_SIZE / 2;

        expected[7].size = VARIABLE_ENTRY_SIZE / 2;

        expected[8].is_dirty = false;

        expected[9].is_dirty  = false;
        expected[9].is_pinned = true;

        for (; i < num_variable_entries + num_monster_entries; i++) {
            expected[i].entry_type   = MONSTER_ENTRY_TYPE;
            expected[i].entry_index  = (int)(i - num_variable_entries);
            expected[i].size         = MONSTER_ENTRY_SIZE;
            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = true;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            memset(expected[i].flush_dep_par_type, 0, sizeof(expected[i].flush_dep_par_type));
            memset(expected[i].flush_dep_par_idx, 0, sizeof(expected[i].flush_dep_par_idx));

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        for (; i < num_total_entries; i++) {
            expected[i].entry_type   = LARGE_ENTRY_TYPE;
            expected[i].entry_index  = (int)(i - num_monster_entries - num_variable_entries);
            expected[i].size         = LARGE_ENTRY_SIZE;
            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = true;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            memset(expected[i].flush_dep_par_type, 0, sizeof(expected[i].flush_dep_par_type));
            memset(expected[i].flush_dep_par_idx, 0, sizeof(expected[i].flush_dep_par_idx));

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        assert(i == num_total_entries);

        pass = true;
    }

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = false;
            failure_mssg = "cache_ptr NULL on entry to flush ops test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = false;
            failure_mssg = "cache not empty at start of flush ops eviction test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of flush op eviction test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    if (pass) {

        /* the basic idea in this test is to insert a bunch of entries
         * with flush operations associated with them, and then load
         * other entries into the cache until the cache is full.  At
         * that point, load yet more entries into the cache, and see
         * if the flush operations are performed as expected.
         *
         * To make things a bit more interesting, we also include a
         * couple of pins.
         */

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */
        H5C_stats__reset(cache_ptr);

        /* load a few entries with pin relationships and flush ops.
         * Start by just loading the entries.
         */

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0, (VARIABLE_ENTRY_SIZE / 4), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 1);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 1, (VARIABLE_ENTRY_SIZE / 4), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3, (VARIABLE_ENTRY_SIZE / 4), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 4);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 4, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5, (VARIABLE_ENTRY_SIZE / 4), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 6);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 6, (VARIABLE_ENTRY_SIZE / 2), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 6, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 7);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 7, (VARIABLE_ENTRY_SIZE / 2), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 7, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 8);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 8, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 9);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 9, H5C__NO_FLAGS_SET);

        if ((cache_ptr->index_len != 10) ||
            (cache_ptr->index_size !=
             (4 * (VARIABLE_ENTRY_SIZE / 4)) + (2 * (VARIABLE_ENTRY_SIZE / 2)) + (4 * VARIABLE_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 1.";
        }
    }

    if (pass) {

        /* Now set up the pinning relationships:
         *
         * Briefly, (VET, 0) is pinned by (VET, 1), (VET, 3), and (VET, 5)
         *          (VET, 9) is pinned by (VET, 5), and (VET, 7)
         */
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 1, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 3, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 5, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 5, VARIABLE_ENTRY_TYPE, 9);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 7, VARIABLE_ENTRY_TYPE, 9);

        /* Next, set up the flush operations:
         *
         * Briefly, (VET, 1) dirties (VET, 0)
         *                   resizes (VET, 0) to 3/4 VARIABLE_ENTRY_SIZE
         *
         *          (VET, 3) dirties (VET, 0)
         *                   resizes (VET, 0) to VARIABLE_ENTRY_SIZE
         *                   moves (VET, 0) to its alternate address
         *
         *          (VET, 5) dirties (VET, 0)
         *                   resizes itself to VARIABLE_ENTRY_SIZE / 2
         *
         *          (VET, 7) dirties (VET, 9)
         *
         *          (VET, 9) dirties (VET, 8)
         */
        add_flush_op(VARIABLE_ENTRY_TYPE, 1, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, (size_t)0, NULL);
        add_flush_op(VARIABLE_ENTRY_TYPE, 1, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, true,
                     3 * VARIABLE_ENTRY_SIZE / 4, NULL);

        add_flush_op(VARIABLE_ENTRY_TYPE, 3, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, (size_t)0, NULL);
        add_flush_op(VARIABLE_ENTRY_TYPE, 3, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, true,
                     VARIABLE_ENTRY_SIZE, NULL);
        add_flush_op(VARIABLE_ENTRY_TYPE, 3, FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, false, (size_t)0, NULL);

        add_flush_op(VARIABLE_ENTRY_TYPE, 5, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, false, (size_t)0, NULL);
        add_flush_op(VARIABLE_ENTRY_TYPE, 5, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 5, true,
                     VARIABLE_ENTRY_SIZE / 2, NULL);

        add_flush_op(VARIABLE_ENTRY_TYPE, 7, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 9, false, (size_t)0, NULL);

        add_flush_op(VARIABLE_ENTRY_TYPE, 9, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 8, false, (size_t)0, NULL);
    }

    if (pass) {

        /* to summarize, at present the following variable size entries
         * are in cache with the following characteristics:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    2.5 KB    Y    Y    -    -
         *
         * (VET, 1)    Y    2.5 KB    Y    N    0    dirty (VET, 0),
         *                             resize (VET, 0) to 7.5 KB
         *
         * (VET, 2)     Y    10 KB    N    N    -    -
         *
         *
         * (VET, 3)    Y    2.5 KB    N    N    0    dirty (VET, 0)
         *                             resize (VET, 0) to 10 KB
         *                             move (VET, 0) to its alternate address
         *
         * (VET, 4)     Y    10 KB    N    N    -    -
         *
         *
         * (VET, 5)    Y    2.5 KB    Y    N    0, 9    dirty (VET, 0)
         *                             resize (VET, 5) to 5 KB
         *
         * (VET, 6)    Y     5 KB    Y    N    -    -
         *
         * (VET, 7)    Y     5 KB    Y    N    9    dirty (VET, 9)
         *
         * (VET, 8)    Y    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    N    -    dirty (VET, 8)
         *
         * Recall that in this test bed, flush operations are executed the
         * first time the associated entry is flushed, and are then
         * deleted.
         */

        /* Now fill up the cache with other, unrelated entries */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 1; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* The cache should now be exactly full */
        if ((cache_ptr->index_len != 42) || (cache_ptr->index_size != 2 * 1024 * 1024) ||
            (cache_ptr->index_size !=
             ((4 * VARIABLE_ENTRY_SIZE / 4) + (2 * VARIABLE_ENTRY_SIZE / 2) + (4 * VARIABLE_ENTRY_SIZE) +
              (31 * MONSTER_ENTRY_SIZE) + (1 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 2.";
        }
        else {

            /* verify the expected status of all entries we have loaded to date: */
            num_large_entries = 1;
            verify_entry_status(cache_ptr, 0,
                                (num_variable_entries + num_monster_entries + num_large_entries), expected);
        }
    }

    if (pass) {

        /* Now load a large entry.  This should result in the eviction
         * of (VET,2), and the increase in the size of (VET, 0) from .25
         * VARIABLE_ENTRY_SIZE to .75 VARIABLE_ENTRY_SIZE.
         *
         * The following table illustrates the intended state of affairs
         * after the eviction:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    7.5 KB    Y    Y    -    -
         *
         * (VET, 1)    Y    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    Y    2.5 KB    Y    N    0    dirty (VET, 0)
         *                             resize (VET, 0) to 10 KB
         *                             move (VET, 0) to its alternate address
         *
         * (VET, 4)    Y    10 KB    N    N    -    -
         *
         * (VET, 5)    Y    2.5 KB    Y    N    0, 9    dirty (VET, 0)
         *                             resize (VET, 5) to 5 KB
         *
         * (VET, 6)    Y     5 KB    Y    N    -    -
         *
         * (VET, 7)    Y     5 KB    Y    N    9    dirty (VET, 9)
         *
         * (VET, 8)    Y    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    Y    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */
        expected[0].size       = 3 * VARIABLE_ENTRY_SIZE / 4;
        expected[1].is_dirty   = false;
        expected[1].serialized = true;
        expected[2].in_cache   = false;
        expected[2].destroyed  = true;

        num_large_entries = 2;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);

        if ((cache_ptr->index_len != 42) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (VARIABLE_ENTRY_SIZE) + (VARIABLE_ENTRY_SIZE / 2) + (LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((1 * (3 * VARIABLE_ENTRY_SIZE / 4)) + (3 * VARIABLE_ENTRY_SIZE / 4) +
                                       (2 * VARIABLE_ENTRY_SIZE / 2) + (3 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (2 * LARGE_ENTRY_SIZE)))) {
            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 3.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 1, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Now load another large entry.  This should result in the eviction
         * of (VET, 4), the increase in the size of (VET, 0) from .75
         * VARIABLE_ENTRY_SIZE to 1.0 VARIABLE_ENTRY_SIZE, and the renaming
         * of (VET, 0) to its alternate address.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    Y    -    -
         *
         * (VET, 1)    Y    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    Y    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    Y    2.5 KB    Y    N    0, 9    dirty (VET, 0)
         *                             resize (VET, 5) to 5 KB
         *
         * (VET, 6)    Y     5 KB    Y    N    -    -
         *
         * (VET, 7)    Y     5 KB    Y    N    9    dirty (VET, 9)
         *
         * (VET, 8)    Y    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    Y    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */
        expected[0].size         = VARIABLE_ENTRY_SIZE;
        expected[0].at_main_addr = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[4].in_cache     = false;
        expected[4].destroyed    = true;

        num_large_entries = 3;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__DIRTIED_FLAG);

        if ((cache_ptr->index_len != 42) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (2 * VARIABLE_ENTRY_SIZE) +
                                          (3 * VARIABLE_ENTRY_SIZE / 4) + (2 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((3 * VARIABLE_ENTRY_SIZE / 4) + (2 * VARIABLE_ENTRY_SIZE / 2) + (3 * VARIABLE_ENTRY_SIZE) +
              (31 * MONSTER_ENTRY_SIZE) + (3 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 4.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 2, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load two more large entries.  This should result in (VET, 5) being
         * flushed, and increasing its size from 1/4 VARIABLE_ENTRY_SIZE to
         * VARIABLE_ENTRY_SIZE.
         *
         * As a result of this size increase, the cache will have to look
         * for another entry to evict.  After flushing (VET, 6) and (VET, 7),
         * it should evict (VET, 8), yielding the needed memory and dirtying
         * (VET, 9).
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    Y    -    -
         *
         * (VET, 1)    Y    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    Y    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    Y     5 KB    N    N    0, 9    -
         *
         * (VET, 6)    Y     5 KB    N    N    -    -
         *
         * (VET, 7)    Y     5 KB    N    N    9    -
         *
         * (VET, 8)    N    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    Y    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[5].size       = VARIABLE_ENTRY_SIZE / 2;
        expected[5].is_dirty   = false;
        expected[5].serialized = true;
        expected[6].is_dirty   = false;
        expected[6].serialized = true;
        expected[7].is_dirty   = false;
        expected[7].serialized = true;
        expected[8].in_cache   = false;
        expected[8].destroyed  = true;
        expected[9].is_dirty   = true;

        num_large_entries = 5;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 4);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 4, H5C__DIRTIED_FLAG);

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) +
                                          (1 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 4) +
                                          (4 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
              (31 * MONSTER_ENTRY_SIZE) + (5 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 5.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 3, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* now touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to bring all the VARIABLE_ENTRY_TYPE entries to the
         * end of the LRU list.
         *
         * Note that we don't have to worry about (VET, 0) and (VET, 9)
         * as they are pinned and thus not in the LRU list to begin with.
         */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 5; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) +
                                          (1 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 4) +
                                          (4 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
              (31 * MONSTER_ENTRY_SIZE) + (5 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 6.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 4, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Now load three more large entries.  This should result
         * in the evictions of (VET, 1), (VET, 3), and (VET, 5), and the
         * unpinning of (VET, 0)
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    Y     5 KB    N    N    -    -
         *
         * (VET, 7)    Y     5 KB    N    N    9    -
         *
         * (VET, 8)    N    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    Y    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[0].is_pinned = false;
        expected[1].in_cache  = false;
        expected[1].destroyed = true;
        expected[3].in_cache  = false;
        expected[3].destroyed = true;
        expected[5].in_cache  = false;
        expected[5].destroyed = true;

        num_large_entries = 8;

        for (i = 5; i < 8; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (4 * VARIABLE_ENTRY_SIZE) +
                                          (1 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 4) +
                                          (7 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((2 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (8 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 7.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 5, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load another large entry.  (VET, 6) should be evicted.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N     5 KB    N    N    -    -
         *
         * (VET, 7)    Y     5 KB    N    N    9    -
         *
         * (VET, 8)    N    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    N    Y    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[6].in_cache  = false;
        expected[6].destroyed = true;

        num_large_entries = 9;

        for (i = 8; i < 9; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) -
                                          (VARIABLE_ENTRY_SIZE / 2) + (8 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((1 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 8.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 6, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Load another large entry.
         *
         * (VET, 7) should be evicted, and (VET, 9) should be unpinned.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N     5 KB    N    N    -    -
         *
         * (VET, 7)    N     5 KB    N    N    -    -
         *
         * (VET, 8)    N    10 KB    N    N    -    -
         *
         * (VET, 9)    Y    10 KB    Y    N    -    dirty (VET, 8)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[7].in_cache  = false;
        expected[7].destroyed = true;
        expected[9].is_pinned = false;

        num_large_entries = 10;

        for (i = 9; i < 10; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (4 * VARIABLE_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (10 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 9.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 7, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Again, touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to bring all the VARIABLE_ENTRY_TYPE entries to the
         * end of the LRU list.
         *
         * Both (VET, 0) and (VET, 7) have been unpinned, so they are
         * now in the LRU list.
         */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 10; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (4 * VARIABLE_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (10 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 10.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 8, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load two more large entries.  Things get a bit complicated here,
         * so I'll go through the operation step by step.
         *
         * Initially, the cache has 4 KB of empty space, so the first entry
         * (LET, 10) is loaded via calls to H5C_protect() H5C_unprotect()
         * without causing any evictions.
         *
         * However, this is not the case for the call of H5C_protect() on
         * (LET, 11).
         *
         * Before inserting (LET, 11), H5C_protect(LET, 11) must try to
         * free up at least 4  KB of space.  To do this, it starts scanning
         * up the LRU list to find entries to evict.
         *
         * (VET, 0) is at the bottom of the LRU list, and thus is the first
         * entry considered.  However, it is dirty, so it flushed to disk,
         * moved to the top of the LRU list, and marked clean.
         *
         * (VET, 9) is the next entry on the bottom of the LRU list. It is
         * dirty too, calls its serialize callback function to construct an
         * on disk image of the entry, and moves it to the top of the LRU
         * list after the serialize callback returns.
         *
         * However, (VET 9)'s serialize function needs to modify (VET, 8),
         * which is currently not in cache.  Thus it calls H5C_protect(VET, 8)
         * to gain access to it.  H5C_protect(VET, 8) loads (VET, 8), and
         * then attempts to evict entries to make space for it.
         *
         * However, H5C_make_space_in_cache() now exits without taking
         * any action on re-entrant calls.  Thus H5C_protect(VET, 8) simply
         * loads the entry into the cache -- resulting in a cache that is
         * 10 KB oversize.  The subsequent unprotect puts (VET, 8) at the
         * head of the LRU and marks it dirty.
         *
         * After (VET, 9) is serialized, it is flushed, and moved to the
         * head of the LRU.
         *
         * At this point, the H5C_make_space_in_cache() call made by
         * H5C_protect(LET, 11) now has 14 KB of space to make.
         *
         * The next entries on the LRU are (MET, 0) thru (MET, 30),
         * (LET, 0) thru (LET, 10), and (VET, 8) -- all of which are dirty,
         * and are therefore flushed and moved to the head of the LRU list.
         *
         * The next entry on the bottom of the LRU list is (VET, 0), which
         * is clean, and is therefore evicted, leaving H5C_make_space_in_cache()
         * with 4 KB of space to create.
         *
         * This space is sufficient, so H5C_protect(VET, 8) inserts
         * (VET, 8) into the cache's index, marks it as protected, and
         * returns to the serialize function for (VET, 9).
         *
         * When the serialize function for (VET, 9) is done with (VET, 8), it
         * calls H5C_unprotect(VET, 8), which marks (VET, 8) as dirty and
         * unprotected, and places it at the head of the LRU.
         *
         * (VET, 0) is the next item on the LRU -- it is clean and is therefore
         * evicted -- leaving 6 KB of free space after (LET, 11) is inserted
         * into the cache.
         *
         * H5C_unprotect(LET, 11) marks (LET, 11) as unprotected, and then
         * returns as well.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     N    10 KB    N    N    -    -
         *
         * (VET, 1)    N    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N     5 KB    N    N    -    -
         *
         * (VET, 7)    N     5 KB    N    N    -    -
         *
         * (VET, 8)    Y    10 KB    N    N    -    -
         *
         * (VET, 9)    N    10 KB    N    N    -    -
         *
         * Start by updating the expected table for the expected changes in
         * entry status:
         *
         * Note that we reset the loaded, flushed, and destroyed
         * fields of (VET,8) so we can track what is happening.
         */
        base_addr               = entries[VARIABLE_ENTRY_TYPE];
        entry_ptr               = &(base_addr[8]);
        entry_ptr->deserialized = false;
        entry_ptr->deserialized = false;
        entry_ptr->destroyed    = false;

        expected[0].in_cache     = false;
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].destroyed    = true;
        expected[8].in_cache     = true;
        expected[8].is_dirty     = false;
        expected[8].deserialized = true;
        expected[8].serialized   = true;
        expected[8].destroyed    = false;
        expected[9].in_cache     = false;
        expected[9].is_dirty     = false;
        expected[9].serialized   = true;
        expected[9].destroyed    = true;

        expected[10].in_cache   = true;
        expected[10].is_dirty   = false;
        expected[10].serialized = true;
        expected[10].destroyed  = false;

        num_large_entries = 12;

        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty   = false;
            expected[i].serialized = true;
        }

        for (i = 10; i < 12; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size  */
        if ((cache_ptr->index_len != 44) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (2 * 1024) - (1 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((1 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (12 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 11.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 9, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* protect and unprotect VET 9 to evict MET 0 */
        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 9);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 9, H5C__NO_FLAGS_SET);

        /* protect and unprotect VET 8 to dirty it and move it to the
         * top of the LRU.  Since we are dirtying it again, reset its
         * serialized flag.
         */
        base_addr             = entries[VARIABLE_ENTRY_TYPE];
        entry_ptr             = &(base_addr[8]);
        entry_ptr->serialized = false;

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 8);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 8, H5C__DIRTIED_FLAG);

        /* Again, touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to evict VET 9 and move VET 8 to the bottom of the LRU.
         *
         * Must do this twice to get the desired result.
         */

        /* skip MET 0 in first pass so that we evict VET 9 when we
         * reload MET 0
         *
         * Since we are reloading MET 0, reset its destroyed flag.
         */
        base_addr            = entries[MONSTER_ENTRY_TYPE];
        entry_ptr            = &(base_addr[0]);
        entry_ptr->destroyed = false;

        for (i = 1; i < num_monster_entries; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < num_large_entries; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < num_monster_entries; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < num_large_entries; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* update the expected array to mark all these entries dirty again. */
        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty = true;
        }

        /* update MET 0 to set its in cache flag, and reset
         * its destroyed flag
         */
        expected[10].in_cache = true;

        /* pass through non variable entries will flush VET 8, and evict VET 9.
         * Update accordingly.
         */
        expected[8].in_cache   = true;
        expected[8].is_dirty   = true;
        expected[8].serialized = false;
        expected[8].destroyed  = false;
        expected[9].in_cache   = false;
        expected[9].is_dirty   = false;
        expected[9].serialized = true;
        expected[9].destroyed  = true;

        /* verify cache size */
        if ((cache_ptr->index_len != 44) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (5 * VARIABLE_ENTRY_SIZE) + (11 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((1 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (12 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 12.";
        }

        /* modifications to the H5C__flush_single_entry() function have
         * changed the behavior of the cache slightly, causing
         * this test to fail.  Comment out for now -- come back and
         * fix if all goes well.
         */

        /* verify entry status */
        verify_entry_status(cache_ptr, 10, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Load two more large entries.
         *
         * Since (VET, 8) is dirty, at first this will just cause (VET, 8)
         * to be flushed.
         *
         * But all other entries in the cache are dirty, so the cache will
         * flush them all, and then evict (VET, 8) on the second pass.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     N    10 KB    N    N    -    -
         *
         * (VET, 1)    N    2.5 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    2.5 KB    N    N    -    -
         *
         * (VET, 4)    N    10 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N     5 KB    N    N    -    -
         *
         * (VET, 7)    N     5 KB    N    N    -    -
         *
         * (VET, 8)    N    10 KB    N    N    -    -
         *
         * (VET, 9)    N    10 KB    N    N    -    -
         *
         * Start by updating the expected table for the expected changes in
         * entry status:
         */

        expected[8].in_cache   = false;
        expected[8].is_dirty   = false;
        expected[8].serialized = true;
        expected[8].destroyed  = true;

        num_large_entries = 14;

        /* a newly loaded entry is not inserted in the cache until after
         * space has been made for it.  Thus (LET, 13) will not be flushed.
         */
        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty   = false;
            expected[i].serialized = true;
        }

        for (i = 12; i < 14; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size  */
        if ((cache_ptr->index_len != 45) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (6 * VARIABLE_ENTRY_SIZE) + (13 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((31 * MONSTER_ENTRY_SIZE) + (14 * LARGE_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in flush op eviction test 13.";
        }

        /* modifications to the H5C__flush_single_entry() function have
         * changed the behavior of the cache slightly, causing
         * this test to fail.  Comment out for now -- come back and
         * fix if all goes well.
         */

        /* verify entry status */
        verify_entry_status(cache_ptr, 11, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    /* at this point we have cycled all the variable size entries through
     * the cache.
     *
     * flush the cache and end the test.
     */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush invalidate failed after flush op eviction test")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after cleanup of flush op eviction test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     *
     * Testing the stats code is fairly new, but given the extent
     * to which I find myself depending on the stats, I've decided
     * to start testing the stats whenever it is convenient to do
     * so.
     */
    if (pass) {

        if ((cache_ptr->insertions[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[VARIABLE_ENTRY_TYPE] != 0) || (cache_ptr->flushes[VARIABLE_ENTRY_TYPE] != 9) ||
            (cache_ptr->evictions[VARIABLE_ENTRY_TYPE] != 12) ||
            (cache_ptr->take_ownerships[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[VARIABLE_ENTRY_TYPE] != 1) ||
            (cache_ptr->entry_flush_moves[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[VARIABLE_ENTRY_TYPE] != 2) || (cache_ptr->unpins[VARIABLE_ENTRY_TYPE] != 2) ||
            (cache_ptr->dirty_pins[VARIABLE_ENTRY_TYPE] != 2) ||
            (cache_ptr->pinned_flushes[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[VARIABLE_ENTRY_TYPE] != 3) ||
            (cache_ptr->size_decreases[VARIABLE_ENTRY_TYPE] != 6) ||
            (cache_ptr->entry_flush_size_changes[VARIABLE_ENTRY_TYPE] != 1) ||
            (cache_ptr->cache_flush_size_changes[VARIABLE_ENTRY_TYPE] != 0)) {

            pass = false;
            failure_mssg =
                "Unexpected variable size entry stats in check_flush_cache__flush_op_eviction_test().";
        }
    }

    if (pass) {

        if ((cache_ptr->insertions[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[LARGE_ENTRY_TYPE] != 0) || (cache_ptr->flushes[LARGE_ENTRY_TYPE] != 25) ||
            (cache_ptr->evictions[LARGE_ENTRY_TYPE] != 14) ||
            (cache_ptr->take_ownerships[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[LARGE_ENTRY_TYPE] != 0) || (cache_ptr->unpins[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[LARGE_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected large entry stats in check_flush_cache__flush_op_eviction_test().";
        }
    }

    if (pass) {

        if ((cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 62) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry stats in check_flush_cache__flush_op_eviction_test().";
        }
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {

        reset_entries();
    }

    free(expected);

} /* check_flush_cache__flush_op_eviction_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__single_entry()
 *
 * Purpose:    Verify that flush_cache behaves as expected when the cache
 *        contains only one element.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__single_entry(H5F_t *file_ptr)
{
    H5C_t *cache_ptr = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = false;
        failure_mssg = "cache_ptr NULL on entry to single entry case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = false;
        failure_mssg = "cache not empty at beginning of single entry case.";
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 1,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__NO_FLAGS_SET,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 2,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__DIRTIED_FLAG,
            /* flush_flags           */ H5C__NO_FLAGS_SET,
            /* expected_deserialized */ true,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 3,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 4,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__DIRTIED_FLAG,
            /* flush_flags           */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 5,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 6,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__DIRTIED_FLAG,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 7,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 8,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ false,
            /* flags                 */ H5C__DIRTIED_FLAG,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ true,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 9,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__NO_FLAGS_SET,
            /* expected_deserialized */ false,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 10,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__NO_FLAGS_SET,
            /* expected_deserialized */ false,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 11,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 12,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ false);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 13,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 14,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ true,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 15,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ true);
    }

    if (pass) {

        check_flush_cache__single_entry_test(
            /* file_ptr             */ file_ptr,
            /* test_num              */ 16,
            /* entry_type            */ PICO_ENTRY_TYPE,
            /* entry_idx             */ 0,
            /* insert_flag           */ true,
            /* flags                 */ H5C__NO_FLAGS_SET,
            /* flush_flags           */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_deserialized */ false,
            /* expected_serialized   */ false,
            /* expected_destroyed    */ true);
    }

    /* Now run single entry tests for pinned entries.  Test all combinations
     * of:
     *
     *     1) Unpin by unprotect vs. unpin by call to H5C_unpin_entry().
     *
     *     2) Marked dirty by unprotect or not.
     *
     *     3) Marked dirty by call to H5C_mark_entry_dirty() or not.
     *
     *  4) Marked dirty by call to H5C_mark_entry_dirty() while protected
     *     or not.
     *
     *  5) Marked dirty by call to H5C_mark_entry_dirty() while pinned or not.
     *
     *     6) Call flush with H5C__FLUSH_CLEAR_ONLY_FLAG or not.
     *
     * This yields a total of 64 tests.
     *
     * The tests and their expected results are given in the spec table
     * below.  The values assigned to the expected_serialized,
     * and expected_destroyed fields are somewhat arcane, so the following
     * overview may be useful.
     *
     * In addition to simply checking to see if the test case runs,
     * we also check to see if the desired operations take place on the
     * cache entry.  Thus expected_serialized is set to true if we
     * we expect the entry to be flushed, and expected_destroyed is set
     * to true if we expect the entry to be destroyed.
     *
     * In this test, we are working with pinned entries which can't be
     * evicted, so expected_destroyed is always false.  We could pull it
     * from the table, but it is a hold over from the code this test
     * was adapted from, and it doesn't do any particular harm.
     *
     * In general, we expect an entry to be flushed if it is dirty, and
     * flush in invoked WITHOUT the H5C__FLUSH_CLEAR_ONLY_FLAG.
     *
     * Similarly, we expect an entry to be cleared if it is dirty, and
     * flush is invoked WITH the H5C__FLUSH_CLEAR_ONLY_FLAG.
     */

    if (pass) {

        struct pinned_single_entry_test_spec *spec = NULL;
        size_t                                i;

        spec = malloc(64 * sizeof(struct pinned_single_entry_test_spec));
        if (spec == NULL) {

            pass         = false;
            failure_mssg = "couldn't allocated pinned single entry test spec array";
        }

        for (i = 0; i < 64; i++) {
            int          test_num;
            int          entry_type;
            int          entry_idx;
            bool         dirty_flag;
            bool         mark_dirty;
            bool         pop_mark_dirty_prot;
            bool         pop_mark_dirty_pinned;
            bool         unprotect_unpin;
            unsigned int flags;
            unsigned int flush_flags;
            bool         expected_serialized;
            bool         expected_destroyed;

            test_num   = (int)(i + 1);
            entry_type = PICO_ENTRY_TYPE;
            entry_idx  = 0;

            /* Generate alternating sequences of true/false */
            dirty_flag            = (i / 16) % 2;
            mark_dirty            = (i / 8) % 2;
            pop_mark_dirty_prot   = (i / 4) % 2;
            pop_mark_dirty_pinned = (i / 2) % 2;
            unprotect_unpin       = i % 2;

            /* Flags are not used for this test
             */
            flags = H5C__NO_FLAGS_SET;

            /*
             * Generate sequences of H5C__NO_FLAGS_SET, and H5C__FLUSH_CLEAR_ONLY_FLAG
             */
            switch (i / 32) {
                case 0:
                    flush_flags = H5C__NO_FLAGS_SET;
                    break;
                case 1:
                    flush_flags = H5C__FLUSH_CLEAR_ONLY_FLAG;
                    break;
                default:
                    flush_flags = H5C__NO_FLAGS_SET;
                    break;
            }

            expected_serialized = false;
            if (0 == (flush_flags & H5C__FLUSH_CLEAR_ONLY_FLAG)) {
                if (dirty_flag || mark_dirty || pop_mark_dirty_prot || pop_mark_dirty_pinned)
                    expected_serialized = true;
            }

            expected_destroyed = false;

            spec[i] = (struct pinned_single_entry_test_spec){
                test_num,
                entry_type,
                entry_idx,
                dirty_flag,
                mark_dirty,
                pop_mark_dirty_prot,
                pop_mark_dirty_pinned,
                unprotect_unpin,
                flags,
                flush_flags,
                expected_serialized,
                expected_destroyed,
            };
        }

        i = 0;
        while (pass && (i < 64)) {
            check_flush_cache__pinned_single_entry_test(
                /* file_ptr              */ file_ptr,
                /* test_num              */ spec[i].test_num,
                /* entry_type            */ spec[i].entry_type,
                /* entry_idx             */ spec[i].entry_idx,
                /* dirty_flag            */ spec[i].dirty_flag,
                /* mark_dirty            */ spec[i].mark_dirty,
                /* pop_mark_dirty_prot   */ spec[i].pop_mark_dirty_prot,
                /* pop_mark_dirty_pinned */ spec[i].pop_mark_dirty_pinned,
                /* unprotect_unpin       */ spec[i].unprotect_unpin,
                /* flags                 */ spec[i].flags,
                /* flush_flags           */ spec[i].flush_flags,
                /* expected_serialized   */ spec[i].expected_serialized,
                /* expected_destroyed    */ spec[i].expected_destroyed);
            i++;
        }

        free(spec);
    }

} /* check_flush_cache__single_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__single_entry_test()
 *
 * Purpose:     Run a single entry flush cache test.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                     bool insert_flag, unsigned int flags, unsigned int flush_flags,
                                     bool expected_deserialized, bool expected_serialized,
                                     bool expected_destroyed)
{
    H5C_t        *cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    test_entry_t *base_addr;
    test_entry_t *entry_ptr = NULL;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = false;
        snprintf(msg, (size_t)128, "cache not empty at beginning of single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((entry_type < 0) || (entry_type >= NUMBER_OF_ENTRY_TYPES) || (entry_idx < 0) ||
             (entry_idx > max_indices[entry_type])) {

        pass = false;
        snprintf(msg, (size_t)128, "Bad parameters on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }

    if (pass) {

        base_addr = entries[entry_type];
        entry_ptr = &(base_addr[entry_idx]);

        if (insert_flag) {

            insert_entry(file_ptr, entry_type, entry_idx, flags);
        }
        else {

            protect_entry(file_ptr, entry_type, entry_idx);

            unprotect_entry(file_ptr, entry_type, entry_idx, flags);
        }
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, flush_flags, "dummy failure mssg.")

        if (!pass) { /* construct and set actual failure message */

            snprintf(msg, (size_t)128, "flush with flags 0x%x failed in single entry test #%d.", flush_flags,
                     test_num);

            failure_mssg = msg;
        }
        else if ((entry_ptr->deserialized != expected_deserialized) ||
                 (entry_ptr->serialized != expected_serialized) ||
                 (entry_ptr->destroyed != expected_destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry status after flush in single entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
        else if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
                  ((cache_ptr->index_len != 1) || (cache_ptr->index_size != entry_sizes[entry_type]))) ||
                 (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
                  ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after flush in single entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG, "dummy failure mssg.")

        if (!pass) { /* construct and set actual failure message */

            snprintf(msg, (size_t)128, "Flush failed on cleanup in single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache len/size after cleanup in single entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
        else {

            entry_ptr->deserialized = false;
            entry_ptr->serialized   = false;
            entry_ptr->destroyed    = false;
        }
    }

} /* check_flush_cache__single_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__pinned_single_entry_test()
 *
 * Purpose:     Run a pinned single entry flush cache test.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__pinned_single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                            bool unprot_dirty_flag, bool mark_dirty, bool pop_mark_dirty_prot,
                                            bool pop_mark_dirty_pinned, bool unprotect_unpin,
                                            unsigned int flags, unsigned int flush_flags,
                                            bool expected_serialized, bool expected_destroyed)
{
    H5C_t        *cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    bool          expected_deserialized = true;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr = NULL;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to pinned single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = false;
        snprintf(msg, (size_t)128, "cache not empty at beginning of pinned single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((entry_type < 0) || (entry_type >= NUMBER_OF_ENTRY_TYPES) || (entry_idx < 0) ||
             (entry_idx > max_indices[entry_type])) {

        pass = false;
        snprintf(msg, (size_t)128, "Bad parameters on entry to pinned single entry test #%d.", test_num);
        failure_mssg = msg;
    }

    if (pass) {

        base_addr = entries[entry_type];
        entry_ptr = &(base_addr[entry_idx]);

        protect_entry(file_ptr, entry_type, entry_idx);

        if (pop_mark_dirty_prot) {

            mark_entry_dirty(entry_type, entry_idx);
        }

        unprotect_entry(file_ptr, entry_type, entry_idx,
                        (unprot_dirty_flag ? H5C__DIRTIED_FLAG : H5C__NO_FLAGS_SET) |
                            (flags | H5C__PIN_ENTRY_FLAG));

        if (mark_dirty) {

            mark_entry_dirty(entry_type, entry_idx);
        }

        if (pop_mark_dirty_pinned) {

            mark_entry_dirty(entry_type, entry_idx);
        }
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, flush_flags, "dummy failure message\n")

        if (!pass) { /* construct and set the correct failure message */

            snprintf(msg, (size_t)128, "flush with flags 0x%x failed in pinned single entry test #%d.",
                     flush_flags, test_num);
            failure_mssg = msg;
        }
        else if ((entry_ptr->deserialized != expected_deserialized) ||
                 (entry_ptr->serialized != expected_serialized) ||
                 (entry_ptr->destroyed != expected_destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry status after flush in pinned single entry test #%d.",
                     test_num);
            failure_mssg = msg;
        }
        else if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
                  ((cache_ptr->index_len != 1) || (cache_ptr->index_size != entry_sizes[entry_type]))) ||
                 (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
                  ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128,
                     "Unexpected cache len/size after flush in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        if (unprotect_unpin) {

            protect_entry(file_ptr, entry_type, entry_idx);

            unprotect_entry(file_ptr, entry_type, entry_idx,
                            (unprot_dirty_flag ? H5C__DIRTIED_FLAG : H5C__NO_FLAGS_SET) |
                                H5C__UNPIN_ENTRY_FLAG);
        }
        else {

            unpin_entry(entry_type, entry_idx);
        }
    }

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG, "dummy mssg\n")

        if (!pass) {

            snprintf(msg, (size_t)128, "Flush failed on cleanup in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128,
                     "Unexpected cache len/size after cleanup in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else {

            entry_ptr->deserialized = false;
            entry_ptr->serialized   = false;
            entry_ptr->destroyed    = false;
        }
    }

} /* check_flush_cache__pinned_single_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_get_entry_status()
 *
 * Purpose:    Verify that H5C_get_entry_status() behaves as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_get_entry_status(unsigned paged)
{
    static char   msg[128];
    herr_t        result;
    bool          in_cache;
    bool          is_dirty;
    bool          is_protected;
    bool          is_pinned;
    size_t        entry_size;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *base_addr = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("H5C_get_entry_status() functionality (paged aggregation)");
    else
        TESTING("H5C_get_entry_status() functionality");

    pass = true;

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {

            base_addr = entries[0];
            entry_ptr = &(base_addr[0]);
        }
    }

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || !is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        mark_entry_dirty(0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        unpin_entry(0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_get_entry_status() */

/*-------------------------------------------------------------------------
 * Function:    check_expunge_entry()
 *
 * Purpose:    Verify that H5C_expunge_entry() behaves as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_expunge_entry(unsigned paged)
{
    static char   msg[128];
    herr_t        result;
    bool          in_cache;
    bool          is_dirty;
    bool          is_protected;
    bool          is_pinned;
    size_t        entry_size;
    H5F_t        *file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("H5C_expunge_entry() functionality (paged aggregation)");
    else
        TESTING("H5C_expunge_entry() functionality");

    pass = true;

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);

        base_addr = entries[0];
        entry_ptr = &(base_addr[0]);
    }

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    /* protect an entry to force the cache to load it, and then unprotect
     * it without marking it dirty.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    /* Expunge the entry and then verify that it is no longer in the cache.
     * Also verify that the entry was loaded and destroyed, but
     * not flushed.
     */
    if (pass) {

        expunge_entry(file_ptr, 0, 0);
    }

    if (pass) {

        /* entry shouldn't be in cache -- only in_cache should be touched
         * by the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    /* now repeat the process with a different entry.  On unprotect
     * mark the entry as dirty.  Verify that it is not flushed.
     */

    base_addr = entries[0];
    entry_ptr = &(base_addr[1]);

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    /* protect the entry to force the cache to load it, and then unprotect
     * it with the dirty flag set.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 1);

        unprotect_entry(file_ptr, 0, 1, H5C__DIRTIED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    /* Expunge the entry and then verify that it is no longer in the cache.
     * Also verify that the entry was loaded and destroyed, but not
     * flushed.
     */
    if (pass) {

        expunge_entry(file_ptr, 0, 1);
    }

    if (pass) {

        /* entry shouldn't be in cache -- only in_cache should be touched
         * by the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_expunge_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_multiple_read_protect()
 *
 * Purpose:    Verify that multiple, simultaneous read protects of a
 *         single entry perform as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_multiple_read_protect(unsigned paged)
{
    H5F_t *file_ptr = NULL;
#if H5C_COLLECT_CACHE_STATS
    H5C_t *cache_ptr = NULL;
#endif /* H5C_COLLECT_CACHE_STATS */
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("multiple read only protects on a single entry (paged aggr)");
    else
        TESTING("multiple read only protects on a single entry");

    pass = true;

    /* allocate a cache.  Should succeed.
     *
     * Then to start with, proceed as follows:
     *
     * Read protect an entry.
     *
     * Then read protect the entry again.  Should succeed.
     *
     * Read protect yet again.  Should succeed.
     *
     * Unprotect with no changes, and then read protect twice again.
     * Should succeed.
     *
     * Now unprotect three times.  Should succeed.
     *
     * If stats are enabled, verify that correct stats are collected at
     * every step.
     *
     * Also, verify internal state of read protects at every step.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
#if H5C_COLLECT_CACHE_STATS
        cache_ptr = file_ptr->shared->cache;
#endif /* H5C_COLLECT_CACHE_STATS */

        entry_ptr = &((entries[0])[0]);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 1.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 0) ||
        (cache_ptr->max_read_protects[0] != 0)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 1.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 2.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 1) ||
        (cache_ptr->max_read_protects[0] != 1)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 2.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 3.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 2) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 3.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 4.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 2) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 4.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 5.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 3) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 5.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 3)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 6.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 6.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 7.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 7.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 8.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 8.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 9.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 9.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* If we get this far, do a write protect and unprotect to verify
     * that the stats are getting collected properly here as well.
     */

    if (pass) {
        protect_entry(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 10.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 1) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 10.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = false;
            failure_mssg = "Unexpected ro protected status 11.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 1) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 11.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* Finally, mix things up a little, using a mix of reads and
     * and writes on different entries.  Also include a pin to verify
     * that it works as well.
     *
     * Stats are looking OK, so we will only test them one more time
     * at the end to ensure that all is at it should be.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 2);    /* (0,2) write */
        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (1) */
        protect_entry(file_ptr, 0, 6);    /* (0,6) write */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) unprotect */
                        H5C__NO_FLAGS_SET);

        protect_entry_ro(file_ptr, 0, 2); /* (0,2) read only (1) */
        protect_entry(file_ptr, 0, 1);    /* (0,1) write */
        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (2) */
        protect_entry(file_ptr, 0, 0);    /* (0,0) write */
        protect_entry_ro(file_ptr, 0, 2); /* (0,2) read only (2) */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) read only (1) pin */
                        H5C__PIN_ENTRY_FLAG);
        unprotect_entry(file_ptr, 0, 6, /* (0,6) unprotect */
                        H5C__NO_FLAGS_SET);

        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (3) */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) unprotect */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 1, /* (0,1) unprotect */
                        H5C__NO_FLAGS_SET);

        if (pass) {

            entry_ptr = &((entries[0])[4]);

            if (H5C_pin_protected_entry((void *)entry_ptr) < 0) {

                pass         = false;
                failure_mssg = "H5C_pin_protected_entry() failed.\n";
            }
            else if (!(entry_ptr->header.is_pinned)) {

                pass         = false;
                failure_mssg = "entry (0,4) not pinned.\n";
            }
            else {

                /* keep test bed sanity checks happy */
                entry_ptr->is_pinned = true;
            }
        }

        unprotect_entry(file_ptr, 0, 4, /* (0,4) read only (2) */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 4, /* (0,4) read only (1) */
                        H5C__UNPIN_ENTRY_FLAG);

        if (pass && (entry_ptr->header.is_pinned)) {

            pass         = false;
            failure_mssg = "entry (0,4) still pinned.\n";
        }

        unprotect_entry(file_ptr, 0, 4, /* (0,4) unprotect */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 0, /* (0,0) unprotect */
                        H5C__NO_FLAGS_SET);

        unpin_entry(0, 2);
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 5) || (cache_ptr->read_protects[0] != 9) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = false;
        failure_mssg = "Unexpected protect stats 11.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_multiple_read_protect() */

/*-------------------------------------------------------------------------
 * Function:    check_move_entry()
 *
 * Purpose:    Verify that H5C_move_entry behaves as expected.  In
 *         particular, verify that it works correctly with pinned
 *         entries.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_move_entry(unsigned paged)
{
    unsigned                    u;
    H5F_t                      *file_ptr      = NULL;
    struct move_entry_test_spec test_specs[4] = {
        {/* int     entry_type      = */ PICO_ENTRY_TYPE,
         /* int     entry_index     = */ 10,
         /* bool is_pinned       = */ false,
         /* bool is_protected    = */ false},
        {/* int     entry_type      = */ PICO_ENTRY_TYPE,
         /* int     entry_index     = */ 20,
         /* bool is_pinned       = */ true,
         /* bool is_protected    = */ false},
        {/* int     entry_type      = */ PICO_ENTRY_TYPE,
         /* int     entry_index     = */ 30,
         /* bool is_pinned       = */ false,
         /* bool is_protected    = */ true},
        {/* int     entry_type      = */ PICO_ENTRY_TYPE,
         /* int     entry_index     = */ 40,
         /* bool is_pinned       = */ true,
         /* bool is_protected    = */ true},
    };

    if (paged)
        TESTING("H5C_move_entry() functionality (paged aggregation)");
    else
        TESTING("H5C_move_entry() functionality");

    pass = true;

    /* allocate a cache, load entries into it, and then move
     * them.  To the extent possible, verify that the desired
     * actions took place.
     *
     * At present, we should do the following tests:
     *
     * 1) Move an unprotected, unpinned entry.
     *
     * 2) Move an unprotected, pinned entry.
     *
     * 3) Move a protected, unpinned entry.
     *
     * 4) Move a protected, pinned entry.
     *
     * In all cases, the entry should have moved to its
     * new location, and have been marked dirty if it wasn't
     * already.
     *
     * Unpinned entries should have been moved to the head
     * of the LRU list.
     *
     * Pinned entries should remain untouched on the pinned entry
     * list.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);
    }

    u = 0;
    while (pass && (u < NELMTS(test_specs))) {
        check_move_entry__run_test(file_ptr, u, &(test_specs[u]));
        u++;
    }

    if (pass)
        takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else
        H5_FAILED();

    if (!pass)
        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);

    return (unsigned)!pass;
} /* check_move_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_move_entry__run_test()
 *
 * Purpose:     Run a move entry test.
 *
 *        Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
check_move_entry__run_test(H5F_t *file_ptr, unsigned test_num, struct move_entry_test_spec *spec_ptr)
{
    H5C_t             *cache_ptr = file_ptr->shared->cache;
    static char        msg[128];
    unsigned int       flags = H5C__NO_FLAGS_SET;
    test_entry_t      *base_addr;
    test_entry_t      *entry_ptr = NULL;
    H5C_cache_entry_t *test_ptr  = NULL;

    if (cache_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "cache_ptr NULL on entry to move test #%u.", test_num);
        failure_mssg = msg;
    }
    else if (spec_ptr == NULL) {

        pass = false;
        snprintf(msg, (size_t)128, "spec_ptr NULL on entry to move test #%u.", test_num);
        failure_mssg = msg;
    }

    if (pass) {

        base_addr = entries[spec_ptr->entry_type];
        entry_ptr = &(base_addr[spec_ptr->entry_index]);

        if ((entry_ptr->self != entry_ptr) ||
            ((entry_ptr->cache_ptr != cache_ptr) && (entry_ptr->cache_ptr != NULL)) ||
            (!(entry_ptr->at_main_addr)) || (entry_ptr->addr != entry_ptr->main_addr)) {

            pass = false;
            snprintf(msg, (size_t)128, "bad entry_ptr in move test #%u.", test_num);
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, spec_ptr->entry_type, spec_ptr->entry_index);

        if (spec_ptr->is_pinned)
            pin_entry(spec_ptr->entry_type, spec_ptr->entry_index);

        if (!spec_ptr->is_protected)
            unprotect_entry(file_ptr, spec_ptr->entry_type, spec_ptr->entry_index, flags);

        move_entry(cache_ptr, spec_ptr->entry_type, spec_ptr->entry_index, false);
    }

    if (pass) {

        /* verify that the move took place, and that the cache's internal
         * structures are as expected.  Note that some sanity checking is
         * done by move_entry(), so we don't have to repeat it here.
         */

        if (spec_ptr->is_pinned) {

            if (!(entry_ptr->header.is_pinned)) {

                pass = false;
                snprintf(msg, (size_t)128, "Pinned entry not pinned after move in test #%u.", test_num);
                failure_mssg = msg;
            }

            if (pass) {

                if (spec_ptr->is_protected) {
                } /* end if */
                else {
                    /* Scan through the pinned entry list, looking for the entry */
                    test_ptr = cache_ptr->pel_head_ptr;
                    while ((test_ptr != NULL) && (test_ptr != (H5C_cache_entry_t *)entry_ptr))
                        test_ptr = test_ptr->next;

                    if (test_ptr == NULL) {

                        pass = false;
                        snprintf(msg, (size_t)128, "Pinned entry not in pel after move in test #%u.",
                                 test_num);
                        failure_mssg = msg;
                    }
                } /* end else */
            }

            unpin_entry(spec_ptr->entry_type, spec_ptr->entry_index);
        }
        else {

            if (entry_ptr->header.is_pinned) {

                pass = false;
                snprintf(msg, (size_t)128, "Unpinned entry pinned after move in test #%u.", test_num);
                failure_mssg = msg;
            }

            if (spec_ptr->is_protected) {
            } /* end if */
            else {
                if ((entry_ptr->header.prev != NULL) ||
                    (cache_ptr->LRU_head_ptr != (H5C_cache_entry_t *)entry_ptr)) {
                    pass = false;
                    snprintf(msg, (size_t)128, "Entry not at head of LRU after move in test #%u.", test_num);
                    failure_mssg = msg;
                }
            } /* end else */
        }

        if (spec_ptr->is_protected) {
            if (!(entry_ptr->header.is_protected)) {

                pass = false;
                snprintf(msg, (size_t)128, "Protected entry not protected after move in test #%u.", test_num);
                failure_mssg = msg;
            }

            unprotect_entry(file_ptr, spec_ptr->entry_type, spec_ptr->entry_index, flags);

        } /* end if */
        else {
            if (entry_ptr->header.is_protected) {

                pass = false;
                snprintf(msg, (size_t)128, "Unprotected entry not unprotected after move in test #%u.",
                         test_num);
                failure_mssg = msg;
            }
        } /* end else */
    }

    /* put the entry back where it started from */
    move_entry(cache_ptr, spec_ptr->entry_type, spec_ptr->entry_index, true);

} /* check_move_entry__run_test() */

/*-------------------------------------------------------------------------
 * Function:    check_pin_protected_entry()
 *
 * Purpose:    Verify that H5C_pin_protected_entry behaves as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_pin_protected_entry(unsigned paged)
{
    static char   msg[128];
    herr_t        result;
    H5F_t        *file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (paged)
        TESTING("H5C_pin_protected_entry() functionality (paged aggregation)");
    else
        TESTING("H5C_pin_protected_entry() functionality");

    pass = true;

    /* Create a cache, protect an entry, and then use H5C_pin_protected_entry()
     * to pin it.  Verify that the entry is in fact pined.  Unprotect the entry
     * to unpin it, and then destroy the cache.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        base_addr = entries[0];
        entry_ptr = &(base_addr[0]);

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_pin_protected_entry() reports failure.");
            failure_mssg = msg;
        }
        else if (!(entry_ptr->header.is_pinned)) {

            pass = false;
            snprintf(msg, (size_t)128, "entry not pinned when it should be.");
            failure_mssg = msg;
        }
        else {

            entry_ptr->is_pinned = true;
        }
    }

    unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_pin_protected_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_resize_entry()
 *
 * Purpose:     Verify that H5C_resize_entry() and H5C_unprotect() resize
 *              entries as expected.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_resize_entry(unsigned paged)
{
    static char   msg[128];
    herr_t        result;
    bool          in_cache;
    bool          is_dirty;
    bool          is_protected;
    bool          is_pinned;
    size_t        entry_size;
    size_t        reported_entry_size;
    H5F_t        *file_ptr  = NULL;
    H5C_t        *cache_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("entry resize functionality (paged aggregation)");
    else
        TESTING("entry resize functionality");

    /* Setup a cache and verify that it is empty.
     *
     * Then force the load of an entry by protecting it, and verify that
     * the entry and cache have the expected sizes.
     *
     * Then unprotect the entry with the size changed flag and a reduced
     * size.  Verify that the entry and cache have the expected expected
     * sizes.
     *
     * Use a second protect/unprotect cycle to restore the entry to
     * its original size.  Verify that the entry and cache have the
     * expected sizes.
     *
     * Protect and unprotect the entry again to pin it.  Use
     * H5C_resize_entry to reduce its size.  Verify that the entry
     * and cache have the expected sizes.
     *
     * Use H5C_resize_entry again to restore the entry to its original
     * size.  Verify that the entry  and cache have the expected sizes.
     *
     * Use a protect / unprotect cycle to unpin and destroy the entry.
     * Verify that the entry  and cache have the expected sizes.
     *
     *
     * Obesrve that all the above tests have been done with only one
     * entry in the cache.  Repeat the tests with several entries in
     * the cache.
     */

    pass = true;

    /* tests with only one entry in the cache: */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {
            cache_ptr = file_ptr->shared->cache;

            base_addr  = entries[LARGE_ENTRY_TYPE];
            entry_ptr  = &(base_addr[0]);
            entry_size = LARGE_ENTRY_SIZE;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 2));

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = false;
                snprintf(msg, (size_t)128, "H5C_unprotect() reports failure 1.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = false;
                entry_ptr->is_dirty     = true;
                entry_ptr->size         = LARGE_ENTRY_SIZE / 2;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != (LARGE_ENTRY_SIZE / 2)) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != (LARGE_ENTRY_SIZE / 2))))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 2))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = false;
                snprintf(msg, (size_t)128, "H5C_unprotect() reports failure 2.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = false;
                entry_ptr->is_dirty     = true;
                entry_ptr->size         = LARGE_ENTRY_SIZE;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 4));

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != (LARGE_ENTRY_SIZE / 4)) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != (LARGE_ENTRY_SIZE / 4))))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 4))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__UNPIN_ENTRY_FLAG | H5C__DELETED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 7.");
            failure_mssg = msg;
        }
    }

    /* now repeat the above tests with several entries in the cache: */

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 8.");
            failure_mssg = msg;
        }

        base_addr  = entries[LARGE_ENTRY_TYPE];
        entry_ptr  = &(base_addr[3]);
        entry_size = LARGE_ENTRY_SIZE;
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        if ((cache_ptr->index_len != 3) || (cache_ptr->index_size != 3 * LARGE_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 9.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != 4 * LARGE_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 10.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 7.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 7.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 7.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 2));

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = false;
                snprintf(msg, (size_t)128, "H5C_unprotect() reports failure 3.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = false;
                entry_ptr->is_dirty     = true;
                entry_ptr->size         = LARGE_ENTRY_SIZE / 2;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) ||
            (cache_ptr->index_size != ((3 * LARGE_ENTRY_SIZE) + (LARGE_ENTRY_SIZE / 2))) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) ||
              (cache_ptr->slist_size != (LARGE_ENTRY_SIZE + (LARGE_ENTRY_SIZE / 2)))))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 11.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 8.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 2))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 8.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 8.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = false;
                snprintf(msg, (size_t)128, "H5C_unprotect() reports failure 4.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = false;
                entry_ptr->is_dirty     = true;
                entry_ptr->size         = LARGE_ENTRY_SIZE;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != 4 * LARGE_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 12.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 9.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 9.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 9.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 4));

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) ||
            (cache_ptr->index_size != ((3 * LARGE_ENTRY_SIZE) + (LARGE_ENTRY_SIZE / 4))) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) ||
              (cache_ptr->slist_size != (LARGE_ENTRY_SIZE + (LARGE_ENTRY_SIZE / 4)))))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 13.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 10.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 4))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 10.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 10.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != (4 * LARGE_ENTRY_SIZE)) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != (2 * LARGE_ENTRY_SIZE))))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 14.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 11.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 11.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 11.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__UNPIN_ENTRY_FLAG | H5C__DELETED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned, NULL, NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 12.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 12.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 12.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 3) || (cache_ptr->index_size != (3 * LARGE_ENTRY_SIZE)) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 15.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__DELETED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DELETED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__DELETED_FLAG);
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0)))) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 16.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_resize_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_evictions_enabled()
 *
 * Purpose:     Verify that H5C_get_evictions_enabled() and
 *              H5C_set_evictions_enabled() functions perform as expected.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_evictions_enabled(unsigned paged)
{
    static char   msg[128];
    herr_t        result;
    bool          show_progress = false;
    bool          evictions_enabled;
    bool          in_cache;
    int           i;
    int           mile_stone = 1;
    H5F_t        *file_ptr   = NULL;
    H5C_t        *cache_ptr  = NULL;
    test_entry_t *base_addr  = NULL;
    test_entry_t *entry_ptr;

    if (paged)
        TESTING("evictions enabled/disabled functionality (paged aggregation)");
    else
        TESTING("evictions enabled/disabled functionality");

    /* Setup a cache and verify that it is empty.
     *
     * Use H5C_get_evictions_enabled() to determine if evictions are
     * currently enabled -- they should be.
     *
     * Load entries until the cache is full.  Load one more.  Verify that
     * this caused an entry to be evicted.
     *
     * Insert an entry.  Verify that this cases and entry to be evicted.
     *
     * Used H5C_set_evictions_enabled() to disable evictions.  Verify
     * with a call to H5C_get_evictions_enabled().
     *
     * Load another entry -- verify that this does not cause an entry
     * to be evicted.
     *
     * Insert an entry -- verify that this does not cause an entry to
     * be evicted.
     *
     * Use H5C_set_evictions_enabled() to re-enable evictions.  Verify
     * with a call to H5C_get_evictions_enabled().
     *
     * Protect and unprotect some of the entries in the cache.  Verify
     * that there are no evictions (since we only try to make space
     * when we either insert or load a new entry).
     *
     * Protect an entry not in the cache.  Verify that this causes
     * two evictions.
     *
     * Used H5C_set_evictions_enabled() to disable evictions again.
     * Verify with a call to H5C_get_evictions_enabled().
     *
     * Now flush and discard the cache -- should succeed.
     */

    pass = true;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* create the cache */
    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(1 * 1024 * 1024), (size_t)(512 * 1024), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {
            cache_ptr = file_ptr->shared->cache;

            base_addr = entries[MONSTER_ENTRY_TYPE];
        }
    }

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that it is empty */
    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that H5C_get_evictions_enabled() returns the expected value */
    if (pass) {

        result = H5C_get_evictions_enabled(cache_ptr, &evictions_enabled);

        if ((result != SUCCEED) || (evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected evictions enabled 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* fill the cache */
        for (i = 0; i < 16; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        }
    }

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that the cache is full */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect another entry */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 16);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 16, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that an entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) && ((cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[0]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                      NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* insert an entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 17, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 10 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that another entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 4.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 11 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[1]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                      NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 12 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* disable evictions */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result != SUCCEED) {

            pass = false;
            snprintf(msg, (size_t)128, "can't disable evictions 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 13 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that evictions are disabled */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != false)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 5.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 14 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect another entry */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 18);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 18, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 15 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that no entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 17) || (cache_ptr->index_size != 17 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != false)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 6.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 16 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* insert another entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 19, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 17 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that no entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 18) || (cache_ptr->index_size != 18 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != false)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 7.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 18 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* re-enable evictions */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result != SUCCEED) {

            pass = false;
            snprintf(msg, (size_t)128, "can't enable evictions 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 19 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that is in the cache */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 19);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 19, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 20 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that no entries have been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 18) || (cache_ptr->index_size != 18 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 8.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 21 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that isn't in the cache */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 20);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 20, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 22 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that the entries have been evicted to bring the
     * cache back down to its normal size.
     */

    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 9.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 23 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[2]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                      NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 24 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[3]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                      NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 25 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* disable evictions again */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result != SUCCEED) {

            pass = false;
            snprintf(msg, (size_t)128, "can't disable evictions 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 26 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that isn't in the cache, forcing
         * the cache to grow.
         */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 21);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 21, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 27 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that the cache has grown */
    if (pass) {

        if ((cache_ptr->index_len != 17) || (cache_ptr->index_size != 17 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != false)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 10.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 28 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* re-enable evictions again */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result != SUCCEED) {

            pass = false;
            snprintf(msg, (size_t)128, "can't enable evictions 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 29 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* insert an entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 22, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 30 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* verify that the cache has returned to its maximum size */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->slist_len != 3) || (cache_ptr->slist_size != 3 * MONSTER_ENTRY_SIZE))) ||
            (cache_ptr->evictions_enabled != true)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected cache status 11.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 31 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[4]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                      NULL, NULL, NULL);

        if (result < 0) {

            pass = false;
            snprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->deserialized) || (entry_ptr->serialized) || (!entry_ptr->destroyed)) {

            pass = false;
            snprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 32 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* disable evictions one last time before we shut down */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, false);

        if (result != SUCCEED) {

            pass = false;
            snprintf(msg, (size_t)128, "can't disable evictions 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 33 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (show_progress) /* 34 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_evictions_enabled() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_protected_err()
 *
 * Purpose:     Verify that an attempt to flush the cache when it contains
 *              a protected entry will generate an error.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_protected_err(unsigned paged)
{
    H5F_t *file_ptr  = NULL;
    H5C_t *cache_ptr = NULL;

    if (paged)
        TESTING("flush cache with protected entry error (paged aggregation)");
    else
        TESTING("flush cache with protected entry error");

    pass = true;

    /* allocate a cache, protect an entry, and try to flush.  This
     * should fail.  Unprotect the entry and flush again -- should
     * succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        if (pass) {

            cache_ptr = file_ptr->shared->cache;
        }

        protect_entry(file_ptr, 0, 0);

        /* enable slist prior to flush */
        if ((pass) && (H5C_set_slist_enabled(cache_ptr, true, true) < 0)) {

            pass         = false;
            failure_mssg = "unable to enable slist prior to flush.\n";
        }

        if ((pass) && (H5C_flush_cache(file_ptr, H5C__NO_FLAGS_SET) >= 0)) {

            pass         = false;
            failure_mssg = "flush succeeded on cache with protected entry.\n";
        }

        /* disable the slist after the flush */
        if ((pass) && (H5C_set_slist_enabled(cache_ptr, false, false) < 0)) {

            pass         = false;
            failure_mssg = "unable to disable slist after  flush.\n";
        }

        unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);

        if (pass) {

            H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "flush failed after unprotect.\n")
        }

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_flush_protected_err() */

/*-------------------------------------------------------------------------
 * Function:    check_destroy_pinned_err()
 *
 * Purpose:    Verify that an attempt to destroy the cache when it contains
 *        a pinned entry that can't be unpined during the flush destroy
 *        will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_destroy_pinned_err(unsigned paged)
{
    H5F_t *file_ptr = NULL;

    if (paged)
        TESTING("destroy cache with permanently pinned entry error (pgd aggr)");
    else
        TESTING("destroy cache with permanently pinned entry error");

    pass = true;

    /* allocate a cache, pin an entry, and try to flush destroy.  This
     * should fail.  Unpin the entry and flush destroy again -- should
     * succeed.
     */
    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);
        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

        if (H5C_prep_for_file_close(file_ptr) < 0) {
            pass         = false;
            failure_mssg = "unexpected failure of prep for file close.\n";
        } /* end if */

        if (H5C_dest(file_ptr) >= 0) {
            pass         = false;
            failure_mssg = "destroy succeeded on cache with pinned entry.\n";
        } /* end if */
        else {
            unpin_entry(0, 0);

            if (H5C_dest(file_ptr) < 0) {
                pass         = false;
                failure_mssg = "destroy failed after unpin.\n";
            } /* end if */
            else
                file_ptr->shared->cache = NULL;
        } /* end else */

        if (saved_cache != NULL) {
            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        } /* end if */

        /* call takedown_cache() with a NULL file_ptr parameter.
         * This causes the function to close and delete the file,
         * while skipping the call to H5C_dest().
         */
        takedown_cache(NULL, false, false);
    } /* end if */

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass)
        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);

    return (unsigned)!pass;

} /* check_destroy_pinned_err() */

/*-------------------------------------------------------------------------
 * Function:    check_destroy_protected_err()
 *
 * Purpose:    Verify that an attempt to destroy the cache when it contains
 *        a protected entry will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_destroy_protected_err(unsigned paged)
{
    H5F_t *file_ptr = NULL;

    if (paged)
        TESTING("destroy cache with protected entry error (paged aggregation)");
    else
        TESTING("destroy cache with protected entry error");

    pass = true;

    /* allocate a cache, protect an entry, and try to flush.  This
     * should fail.  Unprotect the entry and flush again -- should
     * succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        /* Note: normally this call would go just before the series of
         * flushes prior to file close -- in particular, all entries
         * should be unprotected when this call is made.
         *
         * Thus H5C_prep_for_file_close() contains an assert to verify
         * this.  Since this assert would be triggered by the condition
         * we are trying to test, put the call to H5C_prep_for_file_close()
         * prior to the final protect call.
         */
        if (H5C_prep_for_file_close(file_ptr) < 0) {
            pass         = false;
            failure_mssg = "unexpected failure of prep for file close.\n";
        } /* end if */

        protect_entry(file_ptr, 0, 0);

        if (H5C_dest(file_ptr) >= 0) {
            pass         = false;
            failure_mssg = "destroy succeeded on cache with protected entry.\n";
        } /* end if */
        else {
            unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);
            if (H5C_dest(file_ptr) < 0) {
                pass         = false;
                failure_mssg = "destroy failed after unprotect.\n";
            } /* end if */
            else {
                file_ptr->shared->cache = NULL;
            } /* end else */
        }     /* end else */

        if (saved_cache != NULL) {
            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        } /* end if */

        /* call takedown_cache() with a NULL file_ptr parameter.
         * This causes the function to close and delete the file,
         * while skipping the call to H5C_dest().
         */
        takedown_cache(NULL, false, false);
    } /* end if */

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass)
        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);

    return (unsigned)!pass;

} /* check_destroy_protected_err() */

/*-------------------------------------------------------------------------
 * Function:    check_duplicate_insert_err()
 *
 * Purpose:    Verify that an attempt to insert and entry that is
 *        already in the cache will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_duplicate_insert_err(unsigned paged)
{
    herr_t        result   = -1;
    H5F_t        *file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (paged)
        TESTING("duplicate entry insertion error (paged aggregation)");
    else
        TESTING("duplicate entry insertion error");

    pass = true;

    /* allocate a cache, protect an entry, and then try to insert
     * the entry again.  This should fail.  Unprotect the entry and
     * destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        if (pass) {

            base_addr = entries[0];
            entry_ptr = &(base_addr[0]);

            result =
                H5C_insert_entry(file_ptr, types[0], entry_ptr->addr, (void *)entry_ptr, H5C__NO_FLAGS_SET);

            if (result >= 0) {

                pass         = false;
                failure_mssg = "insert of duplicate entry succeeded.\n";
            }
            else {

                unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);

                takedown_cache(file_ptr, false, false);
            }
        }
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_duplicate_insert_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_pin_err()
 *
 * Purpose:    Verify that an attempt to pin an entry that is already
 *        pinned will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_pin_err(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("pin a pinned entry error (paged aggregation)");
    else
        TESTING("pin a pinned entry error");

    pass = true;

    /* allocate a cache, protect an entry, unprotect it with the pin flag,
     * protect it again, and then try to unprotect it again with the pin
     * flag.  This should fail.  Unpin the entry and destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__PIN_ENTRY_FLAG);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to pin a pinned entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_pin_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_unpin_err()
 *
 * Purpose:    Verify that an attempt to unpin an unpinned entry will
 *         generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_unpin_err(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("unpin an unpinned entry error (paged aggregation)");
    else
        TESTING("unpin an unpinned entry error");

    pass = true;

    /* allocate a cache, protect an entry, unprotect it with the unpin flag.
     * -- This should fail.
     *
     * Try again with H5C_unpin_entry -- this should also fail.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__UNPIN_ENTRY_FLAG);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to unpin an unpinned entry succeeded 1.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        }
    }

    if (pass) {

        result = H5C_unpin_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to unpin an unpinned entry succeeded 2.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_unpin_err() */

/*-------------------------------------------------------------------------
 * Function:    check_pin_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_pin_protected_entry()
 *         generate errors as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_pin_entry_errs(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("pin entry related errors (paged aggregation)");
    else
        TESTING("pin entry related errors");

    pass = true;

    /* Allocate a cache, protect an entry, unprotect it with no flags,
     * and then call H5C_pin_protected_entry() to pin it -- This should fail.
     *
     * Protect the entry again, unprotect it with a pin flag, protect it
     * again, and then call H5C_pin_protected_entry() to pin it -- This
     * should fail also.
     *
     * Unprotect the entry with the unpin flag.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to pin an unprotected entry succeeded.\n";
        }
        else {

            protect_entry(file_ptr, 0, 0);

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

            protect_entry(file_ptr, 0, 0);
        }
    }

    if (pass) {

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to pin a pinned, protected entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_pin_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_double_protect_err()
 *
 * Purpose:    Verify that an attempt to protect an entry that is already
 *        protected will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_protect_err(unsigned paged)
{
    H5F_t             *file_ptr  = NULL;
    test_entry_t      *entry_ptr = NULL;
    H5C_cache_entry_t *cache_entry_ptr;

    if (paged)
        TESTING("protect a protected entry error (paged aggregation)");
    else
        TESTING("protect a protected entry error");

    pass = true;

    /* allocate a cache, protect an entry, and then try to protect
     * the entry again.  This should fail.  Unprotect the entry and
     * destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        cache_entry_ptr = (H5C_cache_entry_t *)H5C_protect(file_ptr, types[0], entry_ptr->addr,
                                                           &entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (cache_entry_ptr != NULL) {

            pass         = false;
            failure_mssg = "attempt to protect a protected entry succeeded.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_protect_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_unprotect_err()
 *
 * Purpose:    Verify that an attempt to unprotect an entry that is already
 *        unprotected will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_unprotect_err(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("unprotect an unprotected entry error (paged aggregation)");
    else
        TESTING("unprotect an unprotected entry error");

    pass = true;

    /* allocate a cache, protect an entry, unprotect it, and then try to
     * unprotect the entry again.  This should fail.  Destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to unprotect an unprotected entry succeeded 1.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_unprotect_err() */

/*-------------------------------------------------------------------------
 * Function:    check_mark_entry_dirty_errs()
 *
 * Purpose:    Verify that:
 *
 *        1) a call to H5C_mark_entry_dirty with
 *           and unpinned and unprotected entry will generate an
 *           error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_mark_entry_dirty_errs(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("mark entry dirty related errors (paged aggregation)");
    else
        TESTING("mark entry dirty related errors");

    pass = true;

    /* allocate a cache, protect an entry, unprotect the entry without
     * pinning it, and try to mark it dirty -- this should fail.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_mark_entry_dirty((void *)entry_ptr);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to dirty a unpinned and unprotected entry succeeded.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_mark_entry_dirty_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_expunge_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_expunge_entry()
 *         generate errors as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_expunge_entry_errs(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("expunge entry related errors (paged aggregation)");
    else
        TESTING("expunge entry related errors");

    pass = true;

    /* Allocate a cache, protect an entry, and then call H5C_expunge_entry()
     * to expunge it -- this should fail
     *
     * Unprotect the entry with the pinned flag, and then call
     * H5C_expunge_entry() again.  This should fail too.
     *
     * Finally, unpin the entry and call H5C_expunge_entry() yet again.
     * This should succeed.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        entry_ptr = &((entries[0])[0]);

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, types[0], entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to expunge a protected entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, types[0], entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to expunge a pinned entry succeeded.\n";
        }
        else {

            unpin_entry(0, 0);
        }
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, types[0], entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result < 0) {

            pass         = false;
            failure_mssg = "attempt to expunge an unpinned and unprotected entry failed.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_expunge_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_move_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_move_entry()
 *         generates errors as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_move_entry_errs(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr      = NULL;
    H5C_t        *cache_ptr     = NULL;
    test_entry_t *entry_ptr     = NULL;
    test_entry_t *entry_0_0_ptr = NULL;
    test_entry_t *entry_0_1_ptr = NULL;
    test_entry_t *entry_1_0_ptr = NULL;

    if (paged)
        TESTING("move entry related errors (paged aggregation)");
    else
        TESTING("move entry related errors");

    pass = true;

    /* allocate a cache, and insert several entries.  Try to move
     * entries to other entries resident in the cache.  This should
     * fail.  Destroy the cache -- should succeed.
     */

    if (pass) {
        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;

        insert_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, 0, 1, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, 1, 0, H5C__NO_FLAGS_SET);

        entry_0_0_ptr = &((entries[0])[0]);
        entry_0_1_ptr = &((entries[0])[1]);
        entry_1_0_ptr = &((entries[1])[0]);
    } /* end if */

    if (pass) {
        result = H5C_move_entry(cache_ptr, types[0], entry_0_0_ptr->addr, entry_0_1_ptr->addr);

        if (result >= 0) {
            pass         = false;
            failure_mssg = "move to addr of same type succeeded.\n";
        } /* end if */
    }     /* end if */

    if (pass) {
        result = H5C_move_entry(cache_ptr, types[0], entry_0_0_ptr->addr, entry_1_0_ptr->addr);

        if (result >= 0) {
            pass         = false;
            failure_mssg = "move to addr of different type succeeded.\n";
        } /* end if */
    }     /* end if */

    if (pass)
        takedown_cache(file_ptr, false, false);

    /* Allocate a cache, protect an entry R/O, and then call
     * H5C_move_entry() to move it -- this should fail.
     *
     * Finally, unprotect the entry and destroy the cache.
     * This should succeed.
     */

    if (pass) {
        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;

        insert_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    } /* end if */

    if (pass) {
        result = H5C_move_entry(cache_ptr, types[0], entry_ptr->header.addr, entry_ptr->header.addr + 10);

        if (result >= 0) {
            pass         = false;
            failure_mssg = "Call to H5C_move_entry on a R/O protected entry succeeded.\n";
        } /* end if */
        else
            unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    } /* end if */

    if (pass)
        takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else {
        H5_FAILED();

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    } /* end else */

    return (unsigned)!pass;
} /* check_move_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_resize_entry_errs()
 *
 * Purpose:     Verify that invalid calls to H5C_resize_entry()
 *              generates errors as expected.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_resize_entry_errs(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("resize entry related errors (paged aggregation)");
    else
        TESTING("resize entry related errors");

    pass = true;

    /* Allocate a cache, protect an entry, and then call
     * H5C_resize_entry() to resize it -- this should succeed.
     *
     * Unprotect the entry with the pinned flag, and then call
     * H5C_resize_entry() again with new size of zero.
     * This should fail.
     *
     * Finally, unpin the entry and destroy the cache.
     * This should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        entry_ptr = &((entries[0])[0]);

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (size_t)1);

        if (result < 0) {

            pass         = false;
            failure_mssg = "Call to H5C_resize_entry on a protected entry failed.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (size_t)0);

        if (result >= 0) {

            pass         = false;
            failure_mssg = "Call to H5C_resize_entry with 0 new size succeeded.\n";
        }
        else {

            unpin_entry(0, 0);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_resize_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_unprotect_ro_dirty_err()
 *
 * Purpose:    If an entry is protected read only, verify that unprotecting
 *         it dirty will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_unprotect_ro_dirty_err(unsigned paged)
{
    herr_t        result;
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;

    if (paged)
        TESTING("unprotect a read only entry dirty error (paged aggregation)");
    else
        TESTING("unprotect a read only entry dirty error");

    pass = true;

    /* allocate a cache, protect an entry read only, and then unprotect it
     * with the dirtied flag set.  This should fail.  Destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

        if (result >= 0) {

            pass         = false;
            failure_mssg = "attempt to unprotect a ro entry dirty succeeded 1.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    /* allocate a another cache, protect an entry read only twice, and
     * then unprotect it with the dirtied flag set.  This should fail.
     * Unprotect it with no flags set twice and then destroy the cache.
     * This should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry_ro(file_ptr, 0, 0);
        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

        if (result > 0) {

            pass         = false;
            failure_mssg = "attempt to unprotect a ro entry dirty succeeded 2.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_unprotect_ro_dirty_err() */

/*-------------------------------------------------------------------------
 * Function:    check_protect_ro_rw_err()
 *
 * Purpose:    If an entry is protected read only, verify that protecting
 *         it rw will generate an error.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_protect_ro_rw_err(unsigned paged)
{
    H5F_t        *file_ptr  = NULL;
    test_entry_t *entry_ptr = NULL;
    void         *thing_ptr = NULL;

    if (paged)
        TESTING("protect a read only entry rw error (paged aggregation)");
    else
        TESTING("protect a read only entry rw error");

    pass = true;

    /* allocate a cache, protect an entry read only, and then try to protect
     * it again rw.  This should fail.
     *
     * Unprotect the entry and destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        thing_ptr = (H5C_cache_entry_t *)H5C_protect(file_ptr, types[0], entry_ptr->addr, &entry_ptr->addr,
                                                     H5C__NO_FLAGS_SET);

        if (thing_ptr != NULL) {

            pass         = false;
            failure_mssg = "attempt to protect a ro entry rw succeeded.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_protect_ro_rw_err() */

/*-------------------------------------------------------------------------
 * Function:    check_protect_retries()
 *
 * Purpose:    To exercise checksum verification retries for an entry with
 *        a speculative load.
 *
 * Return:
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_protect_retries(unsigned paged)
{
    H5F_t             *file_ptr        = NULL;
    H5C_t             *cache_ptr       = NULL;
    test_entry_t      *base_addr       = NULL;
    test_entry_t      *entry_ptr       = NULL;
    H5C_cache_entry_t *cache_entry_ptr = NULL;
    int32_t            type;
    int32_t            idx;

    if (paged)
        TESTING("protect an entry to verify retries (paged aggregation)");
    else
        TESTING("protect an entry to verify retries");

    pass = true;

    /* Set up the cache */
    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        /* Set up read attempts for verifying checksum */
        file_ptr->shared->read_attempts = 10;
        file_ptr->shared->retries_nbins = 1;
    }

    /* Test only for this type which has a speculative load */
    type = VARIABLE_ENTRY_TYPE;
    idx  = 0;

    if (pass) {

        cache_ptr = file_ptr->shared->cache;
        base_addr = entries[type];
        entry_ptr = &(base_addr[idx]);

        /* test case (1):
         *     --actual_len is smaller the initial length from get_load_size()
         *    --verify_chksum() returns true after max_verify_ct is reached
         *
         */
        entry_ptr->actual_len    = entry_ptr->size / 2;
        entry_ptr->max_verify_ct = 3;
        entry_ptr->verify_ct     = 0;

        cache_entry_ptr = (H5C_cache_entry_t *)H5C_protect(file_ptr, types[type], entry_ptr->addr,
                                                           &entry_ptr->addr, H5C__READ_ONLY_FLAG);

        if ((cache_entry_ptr != (void *)entry_ptr) || (!(entry_ptr->header.is_protected)) ||
            (!(entry_ptr->header.is_read_only)) || (entry_ptr->header.ro_ref_count <= 0) ||
            (entry_ptr->header.type != types[type]) || (entry_ptr->size != entry_ptr->header.size) ||
            (entry_ptr->addr != entry_ptr->header.addr) ||
            (entry_ptr->verify_ct != entry_ptr->max_verify_ct)) {

            pass         = false;
            failure_mssg = "error from H5C_protect().";
        }
        else {

            assert((entry_ptr->cache_ptr == NULL) || (entry_ptr->cache_ptr == cache_ptr));

            entry_ptr->cache_ptr    = cache_ptr;
            entry_ptr->file_ptr     = file_ptr;
            entry_ptr->is_protected = true;
            entry_ptr->is_read_only = true;
            entry_ptr->ro_ref_count++;
        }

        assert(((entry_ptr->header).type)->id == type);
    }

    if (pass)
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, idx, H5C__NO_FLAGS_SET);

    if (pass) {
        entry_ptr = &(base_addr[++idx]);

        /* test case (2):
         *     --actual_len is greater the initial length from get_load_size()
         *    --verify_chksum() returns false even after all tries is reached
         *       (file_ptr->shared->read_attempts is smaller then max_verify_ct)
         */
        entry_ptr->actual_len    = entry_ptr->size * 2;
        entry_ptr->max_verify_ct = 11;
        entry_ptr->verify_ct     = 0;

        cache_entry_ptr = (H5C_cache_entry_t *)H5C_protect(file_ptr, types[type], entry_ptr->addr,
                                                           &entry_ptr->addr, H5C__READ_ONLY_FLAG);

        /* H5C_protect() should fail after all retries fail */
        if (cache_entry_ptr != NULL)
            pass = false;
    }

    takedown_cache(file_ptr, false, false);
    reset_entries();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_msg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_protect_retries() */

/*-------------------------------------------------------------------------
 * Function:    check_evictions_enabled_err()
 *
 * Purpose:    Verify that H5C_get_evictions_enabled() and
 *              H5C_set_evictions_enabled() generate errors as expected.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_check_evictions_enabled_err(unsigned paged)
{
    herr_t result;
    bool   evictions_enabled;
    H5F_t *file_ptr  = NULL;
    H5C_t *cache_ptr = NULL;

    if (paged)
        TESTING("get/set evictions enabled errors (paged aggregation)");
    else
        TESTING("get/set evictions enabled errors");

    pass = true;

    /* allocate a cache.
     *
     * Call H5C_get_evictions_enabled(), passing it a NULL cache_ptr,
     * should fail.
     *
     * Repeat with a NULL evictions_enabled_ptr, should fail as well.
     *
     * Configure the cache to use auto cache resize.  Call
     * H5C_set_evictions_enabled() to disable evictions.  Should fail.
     *
     * Unprotect the entry and destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_get_evictions_enabled(NULL, &evictions_enabled);

        if (result == SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_evictions_enabled(cache_ptr, NULL);

        if (result == SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 2.\n";
        }
    }

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, true);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_evictions_enabled failed().\n";
        }
    }

    if (pass) {

        (cache_ptr->resize_ctl).incr_mode = H5C_incr__threshold;

        result = H5C_get_evictions_enabled(cache_ptr, false);

        if (result == SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 1.\n";
        }
        else if (cache_ptr->evictions_enabled == true) {
        }

        (cache_ptr->resize_ctl).incr_mode = H5C_incr__off;
    }

    if (pass) {

        (cache_ptr->resize_ctl).decr_mode = H5C_decr__threshold;

        result = H5C_get_evictions_enabled(cache_ptr, false);

        if (result == SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 2.\n";
        }

        (cache_ptr->resize_ctl).decr_mode = H5C_decr__off;
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_evictions_enabled_err() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize()
 *
 * Purpose:    Exercise the automatic cache resizing functionality.
 *        The objective is to operate the auto-resize code in
 *        all possible modes.  Unfortunately, there are quite
 *        a few of them.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

bool                   rpt_fcn_called = false;
enum H5C_resize_status rpt_status;

static void
test_rpt_fcn(H5_ATTR_UNUSED H5C_t *cache_ptr, H5_ATTR_UNUSED int32_t version, H5_ATTR_UNUSED double hit_rate,
             enum H5C_resize_status status, H5_ATTR_UNUSED size_t old_max_cache_size,
             H5_ATTR_UNUSED size_t new_max_cache_size, H5_ATTR_UNUSED size_t old_min_clean_size,
             H5_ATTR_UNUSED size_t new_min_clean_size)
{
    rpt_fcn_called = true;
    rpt_status     = status;
}

static unsigned
check_auto_cache_resize(bool cork_ageout, unsigned paged)
{
    bool                show_progress = false;
    herr_t              result;
    int32_t             i;
    int32_t             checkpoint    = 0;
    H5F_t              *file_ptr      = NULL;
    H5C_t              *cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.1,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    if (paged)
        TESTING("automatic cache resizing (paged aggregation)");
    else
        TESTING("automatic cache resizing");

    pass = true;

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* allocate a cache, enable automatic cache resizing, and then force
     * the cache through all its operational modes.  Verify that all
     * performs as expected.
     */

    if (pass) {
        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {
        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {
        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache not full -- should result in not
     * full status.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != not_full) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should result in increase
     * of cache size from .5 to 1 meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache not full -- should result in not
     * full status.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 1 to 2 meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 4.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 2 to 4 meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 4 to 8 meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 6.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 8 to 12 meg.  Note that max increase reduced the
     * size of the increase.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (12 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 7.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 12 to 14 meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (14 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 8.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full and at maximum size -- should
     * in no change in size and a result of at_max_size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (14 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 9.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate with cache full and at maximum size -- should
     * result in a decrease from 14 to 13 Meg -- note that max decrease
     * reduced the size of the reduction
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (13 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 1024 * 1024 + 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 10.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* the current cache configuration is inconvenient for testing cache
     * size reduction, so lets change it some something easier to work
     * with.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1000 * 1000 + 10;

        auto_size_ctl.min_clean_fraction = 0.1;

        auto_size_ctl.max_size = 8 * 1000 * 1000;
        auto_size_ctl.min_size = 500 * 1000;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1000 * 1000);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1000);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (400 * 1000 + 1))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate  -- should result in a decrease from ~4 to ~3
     * M -- note that max decrease reduces the size of the reduction
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (300 * 1000 + 1))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 11.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~3
     * to ~2 M -- again note that max decrease reduces the size of the
     * reduction.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (200 * 1000 + 1))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 12.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~2
     * to ~1 M -- again note that max decrease reduces the size of the
     * reduction, but only by five bites.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (100 * 1000 + 1))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 13.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~1
     * to ~0.5 M -- max decrease is no longer a factor.  New size is five
     * bytes above the minimum.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (500 * 1000 + 5)) || (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 14.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease of five
     * bytes to the minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 15.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- Already at minimum size so no change in
     * cache size and result should be at_min_size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 16.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force in range hit rate  -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 900)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i + 1000);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i + 1000, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 17.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should
     * increase cache size from .5 to 1 M.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (1 * 1000 * 1000)) || (cache_ptr->min_clean_size != (100 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 18.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease to the
     * minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 19.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * now do some tests with the maximum increase and decrease sizes
     * disabled.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 4.0;

        auto_size_ctl.apply_max_increment = false;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.25;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease to the
     * minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 20.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should increase cache size
     * from 1 to 4 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 21.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again with cache full -- should increase cache
     * size from 4 to 16 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (16 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (8 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 22.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease cache size from
     * 16 to 4 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 23.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * We have tested the threshold increment and decrement modes.
     * must now test the ageout decrement mode.
     *
     * Reconfigure the cache for this testing.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (cork_ageout)
        cork_entry_type(file_ptr, MEDIUM_ENTRY_TYPE);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 24.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */
        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 25.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */
        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 26.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 27.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2001 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2001 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 28.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (1001 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1001 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 29.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force the hit rate to 100% again.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 30.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eighth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {
        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 31.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* ninth epoch */
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 32.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* tenth epoch */
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 33.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* eleventh epoch -- cache size reduction */
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 34.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* twelfth epoch -- at minimum size so no more ageouts */
        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 35.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (cork_ageout)
        uncork_entry_type(file_ptr, MEDIUM_ENTRY_TYPE);

    /* repeat the above test, but with max_decrement enabled to see
     * if that features works as it should.  Note that this will change
     * the structure of the test a bit.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 4.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 36.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 37.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 38.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 39.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (7 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 40.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 41.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- keep hit rate at 100%, and keep 2K entries active.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (5 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (5 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 42.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eighth epoch -- still 100% hit rate
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 43.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* ninth epoch --hit rate at 100%.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 44.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* tenth epoch -- still 100% hit rate
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 512 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 45.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eleventh epoch -- hit rate at 100% -- starting to stableize
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 46.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* twelfth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 47.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* thirteenth epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 48.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* fourteenth epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1001 * 1024 + MONSTER_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * 512 + MONSTER_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 49.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* fifteenth epoch -- cache size reduction */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 50.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* sixteenth epoch -- at minimum size so no more ageouts */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 51.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* repeat the test yet again, this time with empty reserve enabled.
     * Again, some structural changes in the test are necessary.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.5; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 52.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 53.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */

        rpt_fcn_called = false;
        i              = 2000;
        while (pass && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 54.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 55.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (4002 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(4002 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 56.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2002 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2002 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 57.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 58.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eighth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 3000;
        while (pass && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 59.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* ninth epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 60.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* tenth epoch */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (2000 * 512))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 61.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* eleventh epoch -- cache size reduction */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 62.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* twelfth epoch -- at minimum size so no more ageouts */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 63.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the test again, this time using the age out with threshold
     * mode.  To simplify the testing, set epochs to eviction to 1.
     *
     * Again, there are some minor structural changes in the test.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        /* NOTE: upper_hr_threshold MUST be type double (not float)
         * or the cache test will fail on 64-bit systems.
         */
        auto_size_ctl.upper_hr_threshold = 0.999; /* for ease of testing */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 7.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 6.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 4K byte entries -- increment mode is off,
     * so cache size reduction should kick in as soon as we get the
     * hit rate above .999.
     */
    if (pass) { /* first epoch -- hit rate 0 */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 64.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch -- hit rate 0 */

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 65.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch -- hit rate 1.0 -- should see decrease */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 66.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- load up the cache again -- hit rate 0 */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 67.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- still loading up the cache -- hit rate 0 */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 68.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force hit rate to .998 -- should be no reduction */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1002;
        while (pass && (i < 2002)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 69.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force hit rate to .999 -- should see reduction
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1003;
        while (pass && (i < 2003)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1000 * MEDIUM_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1000 * MEDIUM_ENTRY_SIZE / 2))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 70.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* We have now tested all the major ageout modes individually.
     * Lets try them all together to look for unexpected interactions
     * and/or bugs.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1000 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1000 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999; /* for ease of testing */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.5; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 8.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 7.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 4K byte entries -- increment mode is threshold,
     * so the decrease code will not be executed until the hit rate exceeds
     * .75.
     */
    if (pass) { /* first epoch -- hit rate 0 */

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 71.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch -- hit rate 0 */

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 72.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* third epoch -- force the hit rate to 1.0.  Should be no change
     * in the cache size due to the combination of the empty reserve
     * and the max decrease.  Max decrease will limit the evictions
     * in any one epoch, and the empty reserve will not permit cache
     * size reduction unless the specified empty reserve is maintained.
     *
     * In this epoch, all we should see is a reduction in the index size.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (7 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 73.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (6 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 74.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (5 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 75.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.  Note that the cache size is
     * now just on the edge of meeting the clean reserve.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 76.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- hit rate still 1.0.  No change in index size expected.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 77.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eighth epoch -- start loading 1 KB entries.  Hit rate 0 so
     * decrease code shouldn't be called.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (5 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 78.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* ninth epoch -- access the 1 KB entries again, driving the hit rate
     * to 1.0.  Decrease code should be triggered, but the max decrease
     * should prevent the empty reserve from being met in this epoch.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 79.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* tenth epoch -- access the 1 KB entries yet again, forcing hit rate
     * to 1.0.  Decrease code should be triggered, and the empty reserve
     * should finally be met.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (7 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (3 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 80.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* eleventh epoch -- access the 1 KB entries yet again, forcing hit rate
     * to 1.0.  Decrease code should be triggered, and the empty reserve
     * should be met again.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (6 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1000 * 1024)) ||
            (cache_ptr->index_size != (2 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 81.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* twelfth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (5 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (5 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 82.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* thirteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 83.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fourteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 84.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* fifteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 85.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* sixteenth  epoch -- hit rate 1.0 -- should be stable now
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 86.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now test the flash cache size increment code.  At least at present,
     * there should be no interaction between the regular auto-resize
     * code and the flash cache size increment code other than a reset
     * of the counter and stats collection used by the regular auto-resize
     * code.  Thus we do only limited tests of the two pieces of code
     * operating together.
     *
     * Start with simple test to verify that the flash cache increment
     * code increases the cache size when and as expected.
     */

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Place the cache in a known state via a flush-destroy on the cache
     * to clear out all entries, and then a reset on all the entries.
     * Then configure the cache for the flash cache size increase tests,
     * and force the flash size increase code through all its operational
     * modes.  Verify that all perform as expected.
     */

    if (pass) {
        flush_cache(file_ptr, true, false, false);
        reset_entries();
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now repeat the above tests using the add space flash cache size
     * increment algorithm.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 64 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 1024 * 1024;
        auto_size_ctl.min_size = 5 * 1024;

        auto_size_ctl.epoch_length = 100;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (32 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        auto_size_ctl.flash_multiple  = 1.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999; /* for ease of testing */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.5; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 12.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (64 * 1024)) || (cache_ptr->min_clean_size != (32 * 1024)) ||
            (cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache config (0).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a huge entry into the cache */
    if (pass) {

        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 0);

        if (pass)
            unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                      (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                      (cache_ptr->index_size != HUGE_ENTRY_SIZE) || (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (1).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now load a monster entry.  Since a monster entry is larger than
     * half the size of the cache, and there is not sufficient space
     * for a monster entry in the cache, we will add space to the
     * cache to make room for the entry.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

        if (pass)
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (80 * 1024)) ||
                      (cache_ptr->min_clean_size != (40 * 1024)) || (cache_ptr->index_len != 2) ||
                      (cache_ptr->index_size != (HUGE_ENTRY_SIZE + MONSTER_ENTRY_SIZE)) ||
                      (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (2).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a second monster entry.  Since the monster entry is larger
     * than half the size of the cache yet again, and there is not
     * sufficient space for the monster entry in the cache, we again
     * add space to the cache to make space for the entry.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (144 * 1024)) ||
                      (cache_ptr->min_clean_size != (72 * 1024)) || (cache_ptr->index_len != 3) ||
                      (cache_ptr->index_size != ((2 * MONSTER_ENTRY_SIZE) + HUGE_ENTRY_SIZE)) ||
                      (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (3).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a third moster entry.  Should be no cache size increase this
     * time.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 2);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);

        if (pass &&
            (((cache_ptr->max_cache_size != (144 * 1024)) || (cache_ptr->min_clean_size != (72 * 1024)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != (2 * MONSTER_ENTRY_SIZE)) ||
              (cache_ptr->cache_accesses != 2)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (4).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* delete existing entries to prepare for next test, and reset
     * the size of the cache.
     */
    if (pass) {

        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 1);
        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 2);

        if (pass) {

            result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
            if (result != SUCCEED) {
                pass         = false;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
            }
        }

        if (pass && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                      (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 0) ||
                      (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (5).\n";
        }
    }

    /* repeat the above basic test, only this time, use inserts to add
     * entries to the cache, not protects.
     */

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* insert a huge entry into the cache */
    if (pass) {

        insert_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        /* protect and unprotect a couple times to increment cache_accesses */
        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);
        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                      (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                      (cache_ptr->index_size != HUGE_ENTRY_SIZE) || (cache_ptr->cache_accesses != 2)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (6).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now insert a monster entry.  Since a monster entry is larger than
     * half the size of the cache, and there is not sufficient space
     * for a monster entry in the cache, we will add space to the
     * cache to make room for the entry.
     */
    if (pass) {

        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 4, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (80 * 1024)) ||
                      (cache_ptr->min_clean_size != (40 * 1024)) || (cache_ptr->index_len != 2) ||
                      (cache_ptr->index_size != HUGE_ENTRY_SIZE + MONSTER_ENTRY_SIZE) ||
                      (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (7).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Insert a second monster entry.  Cache size should increase again.
     */
    if (pass) {

        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 5, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (144 * 1024)) ||
                      (cache_ptr->min_clean_size != (72 * 1024)) || (cache_ptr->index_len != 3) ||
                      (cache_ptr->index_size != 2 * MONSTER_ENTRY_SIZE + HUGE_ENTRY_SIZE) ||
                      (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (8).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Insert a third monster entry.  Should be no cache size increase this
     * time.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 6);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 6, H5C__NO_FLAGS_SET);

        if (pass &&
            (((cache_ptr->max_cache_size != (144 * 1024)) || (cache_ptr->min_clean_size != (72 * 1024)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != (2 * MONSTER_ENTRY_SIZE)) ||
              (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (9).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* delete existing entries to prepare for next test, and reset
     * the size of the cache.  We must also change the size of the needed
     * variable entries before we run the test, so will protect and
     * unprotect them now so as to get the correct initial size.
     */
    if (pass) {

        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 5);
        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 6);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 1024, true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 1024, true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 1024, true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, 1024, true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, H5C__DIRTIED_FLAG);

        flush_cache(file_ptr, true, false, false);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = false;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
            }
        }

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                      (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 0) ||
                      (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (10).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now load the variable entries into the cache */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                      (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (11).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a variable entry, and re-size it to 3K.  Should be
     * no effect on the size of the cache.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (3 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                      (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 6 * 1024) || (cache_ptr->cache_accesses != 5)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (12).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect the variable entry again, and re-size it to 10K.  Should
     * resize the cache to 13 KB.  Note that cache_accesses will be 0
     * in this case, since cache_accesses is incremented on the protect.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (10 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                      (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (13).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a second variable entry, and re-size it to 10K.  Should
     * resize to 22 KB.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (10 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (14).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a third variable entry, and re-size it to 10K.  Should
     * be no change in cache size.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (10 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (15).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* re-size the variable entries back down to their initial size, and
     * restore the cache to its initial size as well, in preparation
     * for the next test.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = false;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 14.\n";
            }
        }

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                      (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (16).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now test flash cache resizes with pinned entries...
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 2 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) || (cache_ptr->min_clean_size != (6 * 512)) ||
                      (cache_ptr->index_len != 4) || (cache_ptr->index_size != 5 * 1024) ||
                      (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (17).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                      (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (18).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (19).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (20).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Unpin the entries.  Note that no entries are evicted as we don't
     * load any entries.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__UNPIN_ENTRY_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (21).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* re-size the variable entries back down to their initial size, and
     * restore the cache to its initial size as well, in preparation
     * for the next test.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (1 * 1024), true);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = false;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
            }
        }

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                      (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (22).\n";
        }
    }

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 2 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (6 * 1024)) || (cache_ptr->min_clean_size != (6 * 512)) ||
                      (cache_ptr->index_len != 4) || (cache_ptr->index_size != 5 * 1024) ||
                      (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (23).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                      (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (24).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (25).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 10 * 1024, true);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (26).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Unpin the entries.  Note that no entries are evicted as we don't
     * load any entries.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__UNPIN_ENTRY_FLAG);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                      (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (27).\n";
        }
    }

    /* We have finished a basic check of the flash cache size increment
     * code.  Tidy up for a more extensive test...
     */
    if (pass) {

        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);

        if (pass && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                      (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 0) ||
                      (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 4)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (28).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* ...and then reconfigure.   Note that we change the flash_multiple
     * and flash_threshold just to make sure that such changed perform
     * as expected.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 20 * 1024;
        auto_size_ctl.min_size = 4 * 1024;

        auto_size_ctl.epoch_length = 100;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.4;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999; /* for ease of testing */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (2 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.5; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);
        if (result != SUCCEED) {
            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024)) || (cache_ptr->min_clean_size != (4 * 512)) ||
            (cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)) {

            pass         = false;
            failure_mssg = "bad cache after initialization 15.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect a large entry -- no change in cache size since
     * a large entry will just fill the available space in the cache.
     */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (4 * 1024)) || (cache_ptr->min_clean_size != (4 * 512)) ||
                      (cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
                      (cache_ptr->cache_accesses != 1) || (rpt_fcn_called == true)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (29).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect another a large entry -- should trigger a
     * flash cache size increase to 12 KB (remember that flash_multiple is
     * set to 2.0).
     */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if (pass &&
            (((cache_ptr->max_cache_size != (12 * 1024)) || (cache_ptr->min_clean_size != (12 * 512)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != 2 * LARGE_ENTRY_SIZE) ||
              (cache_ptr->cache_accesses != 1) || (rpt_fcn_called != true)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (30).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect two more large entries -- shouldn't trigger a
     * flash cache size increase.
     */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);
        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__NO_FLAGS_SET);

        if (pass &&
            (((cache_ptr->max_cache_size != (12 * 1024)) || (cache_ptr->min_clean_size != (12 * 512)) ||
              (cache_ptr->index_len != 3) || (cache_ptr->index_size != 3 * LARGE_ENTRY_SIZE) ||
              (cache_ptr->cache_accesses != 3) || (rpt_fcn_called != false)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (31).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* do many accesses of a single entry to talk the cache into reducing
     * its size to the minimum.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, TINY_ENTRY_TYPE, 0);

            if (pass)
                unprotect_entry(file_ptr, TINY_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->max_cache_size != (4 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024)) || (cache_ptr->index_size != (1 * TINY_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (32).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Force another flash increase */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (4 * 1024 + 128)) ||
                      (cache_ptr->min_clean_size != (2 * 1024 + 64)) || (cache_ptr->index_len != 2) ||
                      (cache_ptr->index_size != LARGE_ENTRY_SIZE + TINY_ENTRY_SIZE) ||
                      (cache_ptr->cache_accesses != 1) || (rpt_fcn_called == false) ||
                      (rpt_status != flash_increase)))) {

            pass         = false;
            failure_mssg = "Unexpected cache config (33).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force regular size increase up to maximum */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 500)) {
            protect_entry(file_ptr, TINY_ENTRY_TYPE, i);

            if (pass)
                unprotect_entry(file_ptr, TINY_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            i++;
        }

        if ((cache_ptr->max_cache_size != (20 * 1024)) || (cache_ptr->min_clean_size != (10 * 1024)) ||
            (rpt_fcn_called == false) || (rpt_status != at_max_size)) {

            pass         = false;
            failure_mssg = "Unexpected cache config (34).\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    } /* end if */
    else {
        H5_FAILED();
    } /* end else */

    if (!pass)
        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);

    return (unsigned)!pass;
} /* check_auto_cache_resize() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_disable()
 *
 * Purpose:    Test the various ways in which the resize code can
 *        be disabled.  Unfortunately, there are quite a few of them.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_disable(unsigned paged)
{
    bool                show_progress = false;
    herr_t              result;
    int32_t             i;
    int32_t             checkpoint    = 0;
    H5F_t              *file_ptr      = NULL;
    H5C_t              *cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 1.0,
        /* double      flash_threshold        = */ 0.25,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.1,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    if (paged)
        TESTING("automatic cache resize disable (paged aggregation)");
    else
        TESTING("automatic cache resize disable");

    pass = true;

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* allocate a cache, enable automatic cache resizing, and then force
     * the cache through all its operational modes.  Verify that all
     * performs as expected.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {

            cache_ptr = file_ptr->shared->cache;
        }
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * So far, we have forced the auto cache resize through all modes
     * other than increase_disabled and decrease_disabled.  Force these
     * modes now.  Note that there are several ways we can reach these
     * modes.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 1.0; /* disable size increases */

        auto_size_ctl.apply_max_increment = false;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != increase_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != increase_disabled) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling increase through the lower
     * threshold instead of the increment.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0; /* disable size increases */

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = false;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;
        auto_size_ctl.decrement          = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 4.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 6.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests yet again, disabling increase through the
     * incr_mode.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = false;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 7.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 8.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 9.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now, disable size decreases, and repeat the above tests.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 1.0; /* disable size decreases */

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 4.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 10.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 11.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 12.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling decrease through the upper
     * threshold instead of the decrement.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0; /* disable size decreases */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 13.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 14.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 15.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling decrease through the decr_mode.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 7.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 6.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 16.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 17.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 18.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now do tests disabling size decrement in age out mode.
     *
     * Start by disabling size decrement by setting max_decrement to zero.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = 0; /* disable decrement */

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 8.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 7.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, true, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 19.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 20.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 21.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 22.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This will see to it that there are
     * many entries that could be aged out were decreases enabled.
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 23.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now disable size decrement in age out mode via the empty reserve.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 1.0; /* disable decrement */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 9.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 8.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, true, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 24.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 25.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 26.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 27.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This will see to it that there are
     * many entries that could be aged out were decreases enabled.
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 28.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now work with age out with threshold.  One can argue that we should
     * repeat the above age out tests with age out with threshold, but the
     * same code is executed in both cases so I don't see the point.  If
     * that ever changes, this test should be updated.
     *
     * There is only one way of disabling decrements that is peculiar
     * to age out with threshold, which is to set the upper threshold
     * to 1.0.  Test this now.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 1.0;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 10.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 9.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, true, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 29.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 1000;
        while (pass && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 30.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible, but the upper threshold cannot be met, so no decrease.
     *
     * rpt_status should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024)) || (cache_ptr->index_len != 2000) ||
            (cache_ptr->index_size != 2000 * SMALL_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 31.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 32.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This keeps the hit rate high, and sees
     * to it that there are many entries that could be aged out were
     * decreases enabled.
     *
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 999);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 999, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 33.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /*********************************************************************
     * Finally, use the auto cache resize code to set the size of the
     * cache and keep it there.  Again, due to the complexity of the
     * interface, there are lots of ways of doing this.  We have to
     * check them all.
     *********************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 2 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0; /* disable size increases */

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0; /* disable size decreases */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 11.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 10.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 34.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 35.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.25;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 1.0; /* disable size increment */

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 1.0; /* disable size decrement */

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 12.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 11.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 36.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 37.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = false;
        auto_size_ctl.initial_size     = 2 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 6 * 1024 * 1024; /* no resize */
        auto_size_ctl.min_size = 6 * 1024 * 1024; /* no resize */

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 12.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 38.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 39.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.25;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 1.0; /* disable size increment */

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0; /* disable size decrement */

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 14.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 13.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 40.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 41.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0; /* disable size increment */

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 1.0; /* disable size decrement */

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 14.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 42.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 43.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 16.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 15.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 44.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 45.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now test the flash cache size increment code to verify that it
     * is disabled when it should be.
     *
     * Since the flash size increase code doesn't look at hit rate, or
     * use epochs (other than to start a new epoch if a flash cache size
     * increase is triggered), we go about these tests somewhat differently
     * than the rest of the tests in this function.
     *
     * As of this writing, there is only one flash cache size increment
     * mode (add space), which is triggered whenever the size of a newly
     * loaded or inserted entry, or the delta between old and new entry
     * sizes exceeds some fraction of the current maximum cache size, and
     * the cache doesn't have enough free space to accommodate the new/
     * resize entry without performing evictions.  The range of permissible
     * values for the flash_threshold (0.1 to 1.0 as of this writing), and
     * for the flash_multiple (0.1 to 10.0) do not permit the facility to
     * be turned off by configuration.  Thus, flash cache size increases
     * can be disabled only via the flash_incr_mode, and by setting the
     * current max_cache_size equal to max_size.
     *
     * We have already tested the latter in check_auto_cache_resize(), so
     * we need only test the former here.  Do this by disabling flash
     * cache size increments via the flash_incr_mode, and then creating
     * situations that would trigger flash cache size increases were that
     * code enabled.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 64 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 256 * 1024;
        auto_size_ctl.min_size = 32 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (2 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 1.0;
        auto_size_ctl.flash_threshold = 0.25;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = true;
        auto_size_ctl.max_decrement       = (1 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = true;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 17.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (64 * 1024)) || (cache_ptr->min_clean_size != (32 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 16.\n";
        }
    }

    /* We have reduced the max cache size to well below the current index
     * size.  Protect and unprotect an entry to allow the cache to evict
     * entries and get within bounds
     */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                      (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                      (cache_ptr->index_size != LARGE_ENTRY_SIZE) || (rpt_fcn_called != false)))) {

            fprintf(stdout, "\nmax_cache_size = %ld.\n", (long)(cache_ptr->max_cache_size));
            fprintf(stdout, "min_clean_size = %ld.\n", (long)(cache_ptr->min_clean_size));
            fprintf(stdout, "index_len = %ld.\n", (long)(cache_ptr->index_len));
            fprintf(stdout, "index_size = %ld.\n", (long)(cache_ptr->index_size));
            fprintf(stdout, "rpt_fcn_called = %ld.\n", (long)(rpt_fcn_called));

            pass         = false;
            failure_mssg = "Unexpected cache size change results 46.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now protect and unprotect a monster entry.  If the flash cache
     * size increment code was active, this would trigger an increase.
     * Verify that it doesn't.
     *
     * This finishes the additional tests needed for the flash cache
     * size increase code.
     */
    if (pass) {

        rpt_fcn_called = false;

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if (pass && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                      (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                      (cache_ptr->index_size != MONSTER_ENTRY_SIZE) || (rpt_fcn_called != false)))) {

            fprintf(stdout, "\nmax_cache_size = %ld.\n", (long)(cache_ptr->max_cache_size));
            fprintf(stdout, "min_clean_size = %ld.\n", (long)(cache_ptr->min_clean_size));
            fprintf(stdout, "index_len = %ld.\n", (long)(cache_ptr->index_len));
            fprintf(stdout, "index_size = %ld.\n", (long)(cache_ptr->index_size));
            fprintf(stdout, "rpt_fcn_called = %ld.\n", (long)(rpt_fcn_called));

            pass         = false;
            failure_mssg = "Unexpected cache size change results 47.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_disable() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_epoch_markers()
 *
 * Purpose:    Verify that the auto-resize code manages epoch markers
 *        correctly.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_epoch_markers(unsigned paged)
{
    bool                show_progress = false;
    herr_t              result;
    int32_t             i;
    int32_t             j;
    int32_t             checkpoint    = 0;
    H5F_t              *file_ptr      = NULL;
    H5C_t              *cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.1,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    if (paged)
        TESTING("automatic cache resize epoch marker management (paged aggr)");
    else
        TESTING("automatic cache resize epoch marker management");

    pass = true;

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Now make sure that we are managing the epoch markers correctly.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Since we just created the cache, there should be no epoch markers
     * active.  Verify that this is true.
     */

    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 1.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * MEDIUM_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 0.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        j = 2;
        while (pass && (j <= 10)) {

            rpt_fcn_called = false;
            i              = (j - 2) * 1000;
            while (pass && (i < (j - 1) * 1000)) {
                protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

                if (pass) {
                    unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
                }
                i++;
            }

            if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->epoch_markers_active != j)) {

                pass         = false;
                failure_mssg = "Unexpected # of epoch markers 2.\n";
            }

            j++;
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* we now have a full complement of epoch markers -- see if
     * we get the expected reduction.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 9000;
        while (pass && (i < 10000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != ((10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE) / 2)) ||
            (cache_ptr->index_size != (10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* now reduce the epochs before eviction, and see if the cache
     * deletes the extra markers
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* There should be exactly one active epoch marker at present.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 1) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 3.\n";
        }
    }

    /* Now do an epochs worth of accesses, and verify that everything
     * not accessed in this epoch gets evicted, and the cache size
     * is reduced.
     */
    if (pass) {

        rpt_fcn_called = false;
        i              = 9000;
        while (pass && (i < 10000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * SMALL_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* There should be exactly one active epoch marker at present...
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 1) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 4.\n";
        }
    }

    /* shift the decrement mode to threshold, and verify that we remove
     * all epoch markers.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    /* ... and now there should be none.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 5.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* shift the decrement mode to age out with threshold.  Set epochs
     * before eviction to 10 again.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    /* Verify that there are no active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 6.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* build up a full set of epoch markers. */
    if (pass) {

        j = 1;
        while (pass && (j <= 10)) {

            rpt_fcn_called = false;
            i              = (j - 1) * 1000;
            while (pass && (i < j * 1000)) {
                protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

                if (pass) {
                    unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
                }
                i++;
            }

            if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->epoch_markers_active != j)) {

                pass         = false;
                failure_mssg = "Unexpected # of epoch markers 7.\n";
            }

            j++;
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* Verify that there are now 10 active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 10) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 8.\n";
        }
    }

    /* shift the decrement mode to off.  This should cause all epoch
     * markers to be removed.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = true;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75;

        auto_size_ctl.increment = 2.0;

        auto_size_ctl.apply_max_increment = true;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0;
        auto_size_ctl.flash_threshold = 0.5;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995;

        auto_size_ctl.decrement = 0.5;

        auto_size_ctl.apply_max_decrement = false;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = false;
        auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    /* Verify that there are now no active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = false;
            failure_mssg = "Unexpected # of epoch markers 9.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    /* verify that we still have the expected number of entries in the cache,
     * and that the cache is of the expected size.
     */
    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024)) ||
            (cache_ptr->index_size != (10 * 1000 * SMALL_ENTRY_SIZE)) || (cache_ptr->index_len != 10000)) {

            pass         = false;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (show_progress)
        fprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_epoch_markers() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_input_errs()
 *
 * Purpose:    Verify that H5C_set_cache_auto_resize_config() detects
 *        and rejects invalid input.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_input_errs(unsigned paged)
{
    herr_t              result;
    H5F_t              *file_ptr          = NULL;
    H5C_t              *cache_ptr         = NULL;
    H5C_auto_size_ctl_t ref_auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (16 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.1,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    H5C_auto_size_ctl_t invalid_auto_size_ctl;
    H5C_auto_size_ctl_t test_auto_size_ctl;

    if (paged)
        TESTING("automatic cache resize input errors (paged aggregation)");
    else
        TESTING("automatic cache resize input errors");

    pass = true;

    /* allocate a cache, and set a reference automatic cache control
     * configuration.  Then feed H5C_set_cache_auto_resize_config()
     * invalid input, and verify that the correct error is returned,
     * and that the configuration is not modified.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &ref_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 1.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 1.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(NULL, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 2.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 2.";
        }
    }

    /* check bad version rejection. */

    if (pass) {

        invalid_auto_size_ctl.version = -1; /* INVALID */
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad version.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 3.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 3.";
        }
    }

    /* check bad initial size rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 16 * 1024 * 1024 + 1;
        /* INVALID */

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad init size 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 4.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 4.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 1 * 1024 * 1024 - 1;
        /* INVALID */

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad init size 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 5.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 5.";
        }
    }

    /* test for invalid min clean fraction rejection. */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 1.00001; /* INVALID */

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min clean frac 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 6.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 6.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = -0.00001; /* INVALID */

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min clean frac 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 7.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 7.";
        }
    }

    /* test for invalid max_size and/or min_size rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = H5C__MAX_MAX_CACHE_SIZE + 1;
        /* INVALID */
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad max_size.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 8.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 8.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 1 * 1024 * 1024;     /* INVALID */
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024 + 1; /*PAIR */

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad size pair.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 9.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 9.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = H5C__MIN_MAX_CACHE_SIZE - 1;
        /* INVALID */
        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min_size.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 10.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 10.";
        }
    }

    /* test for invalid epoch_length rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = H5C__MAX_AR_EPOCH_LENGTH + 1;
        /* INVALID */

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epoch len 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 11.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 11.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = H5C__MIN_AR_EPOCH_LENGTH - 1;
        /* INVALID */

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epoch len 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 12.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 12.";
        }
    }

    /* test for bad incr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = (enum H5C_cache_incr_mode) - 1; /* INVALID */

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad incr_mode 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 13.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 13.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = (enum H5C_cache_incr_mode)2; /* INVALID */

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad incr_mode 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 14.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 14.";
        }
    }

    /* check for bad upper and/or lower threshold rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 1.01; /* INVALID */

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad upper threshold.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 15.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 15.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.8; /* INVALID */

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.7; /* INVALID */

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad threshold pair.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 16.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 16.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = -0.0001; /* INVALID */

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad lower threshold.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 17.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 17.";
        }
    }

    /* test for bad increment rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 0.99999; /* INVALID */

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.5;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad increment.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 18.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 18.";
        }
    }

    /* test for bad flash_incr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = (enum H5C_cache_flash_incr_mode) - 1; /* INVALID */
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_incr_mode.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 19.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 19.";
        }
    }

    /* test for bad flash_multiple rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 0.09; /* INVALID */
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_multiple(1).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 20.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 20.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 10.01; /* INVALID */
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_multiple(2).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 21.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 21.";
        }
    }

    /* test for bad flash_threshold rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 1.0;
        invalid_auto_size_ctl.flash_threshold = 0.09; /* INVALID */

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_threshold(1).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 22.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 22.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 1.0;
        invalid_auto_size_ctl.flash_threshold = 1.001; /* INVALID */

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_threshold(2).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 23.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 23.";
        }
    }

    /* test for bad decr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = (enum H5C_cache_decr_mode) - 1; /* INVALID */

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decr_mode 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 24.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 24.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = (enum H5C_cache_decr_mode)4; /* INVALID */

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decr_mode 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 25.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 25.";
        }
    }

    /* check for bad decrement rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 1.000001; /* INVALID */

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decrement 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 26.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 26.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = -0.000001; /* INVALID */

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decrement 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 27.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 27.";
        }
    }

    /* check for rejection of bad epochs_before_eviction */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 0; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epochs_before_eviction 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 28.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 28.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = H5C__MAX_EPOCH_MARKERS + 1; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epochs_before_eviction 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 29.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 29.";
        }
    }

    /* Check for bad apply_empty_reserve rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = -0.0000001; /* INVALID */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad empty_reserve 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 30.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 30.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = true;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75;

        invalid_auto_size_ctl.increment = 2.0;

        invalid_auto_size_ctl.apply_max_increment = true;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0;
        invalid_auto_size_ctl.flash_threshold = 0.5;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999;

        invalid_auto_size_ctl.decrement = 0.9;

        invalid_auto_size_ctl.apply_max_decrement = true;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = H5C__MAX_EPOCH_MARKERS + 1; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = true;
        invalid_auto_size_ctl.empty_reserve       = 0.05;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad empty_reserve 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 31.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, false)) {

            pass         = false;
            failure_mssg = "Unexpected auto resize config 31.";
        }
    }

    /* finally, before we finish, try feeding
     * H5C_get_cache_auto_resize_config invalid data.
     */

    if (pass) {

        result = H5C_get_cache_auto_resize_config(NULL, &test_auto_size_ctl);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, NULL);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config accepted NULL config ptr.\n";
        }
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_input_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_aux_fcns()
 *
 * Purpose:    Verify that the auxiliary functions associated with
 *        the automatic cache resize capability are operating
 *        correctly.  These functions are:
 *
 *            H5C_get_cache_size()
 *            H5C_get_cache_hit_rate()
 *            H5C_reset_cache_hit_rate_stats()
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_aux_fcns(unsigned paged)
{
    herr_t              result;
    int32_t             i;
    H5F_t              *file_ptr  = NULL;
    H5C_t              *cache_ptr = NULL;
    double              hit_rate;
    size_t              max_size;
    size_t              min_clean_size;
    size_t              cur_size;
    uint32_t            cur_num_entries;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (1 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (16 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__off,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__off,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.9,

        /* bool     apply_max_decrement    = */ true,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.5};

    if (paged)
        TESTING("automatic cache resize auxiliary functions (paged aggregation)");
    else
        TESTING("automatic cache resize auxiliary functions");

    pass = true;

    /* allocate a cache, and then test the various auxiliary functions.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = false;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    /* lets start with the H5C_get_cache_hit_rate(),
     * H5C_reset_cache_hit_rate_stats() pair.
     */

    if (pass) {

        if ((H5C_get_cache_hit_rate(NULL, &hit_rate) != FAIL) ||
            (H5C_get_cache_hit_rate(cache_ptr, NULL) != FAIL)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate accepts bad params.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!H5_DBL_ABS_EQUAL(hit_rate, 0.0)) { /* i.e. hit_rate != 0.0 */

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 1.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!H5_DBL_ABS_EQUAL(hit_rate, 0.0)) { /* i.e. hit_rate != 0.0 */

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 2.\n";
        }
        else if ((cache_ptr->cache_accesses != 1000) || (cache_ptr->cache_hits != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = false;
            failure_mssg = "Report function called?.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, 0);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!H5_DBL_ABS_EQUAL(hit_rate, 0.5)) { /* i.e. hit_rate != 0.5 */

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 3.\n";
        }
        else if ((cache_ptr->cache_accesses != 2000) || (cache_ptr->cache_hits != 1000)) {

            pass         = false;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = false;
            failure_mssg = "Report function called?.\n";
        }
    }

    if (pass) {

        result = H5C_reset_cache_hit_rate_stats(NULL);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_reset_cache_hit_rate_stats accepted NULL cache_ptr.\n";
        }
        else if ((cache_ptr->cache_accesses != 2000) || (cache_ptr->cache_hits != 1000)) {

            pass         = false;
            failure_mssg = "Failed call to H5C_reset_cache_hit_rate_stats altered stats?\n";
        }
    }

    if (pass) {

        result = H5C_reset_cache_hit_rate_stats(cache_ptr);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_reset_cache_hit_rate_stats failed.\n";
        }
        else if ((cache_ptr->cache_accesses != 0) || (cache_ptr->cache_hits != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = false;
        i              = 0;
        while (pass && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i + 500);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i + 500, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!H5_DBL_ABS_EQUAL(hit_rate, 0.5)) { /* i.e. hit_rate != 0.5 */

            pass         = false;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 4.\n";
        }
        else if ((cache_ptr->cache_accesses != 1000) || (cache_ptr->cache_hits != 500)) {

            pass         = false;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = false;
            failure_mssg = "Report function called?.\n";
        }
    }

    /***************************************************
     * So much for testing H5C_get_cache_hit_rate() and
     * H5C_reset_cache_hit_rate_stats().  Now on to
     * H5C_get_cache_size().
     ***************************************************/

    if (pass) {

        result = H5C_get_cache_size(NULL, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != FAIL) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        max_size        = 0;
        min_clean_size  = 0;
        cur_size        = 0;
        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 1.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 1.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 1.\n";
        }
        else if (cur_size != (1500 * PICO_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 1.\n";
        }
        else if (cur_num_entries != 1500) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 1.\n";
        }
    }

    /* read a larger entry so that cur_size and cur_num_entries will be
     * different.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
    }

    if (pass) {
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        max_size        = 0;
        min_clean_size  = 0;
        cur_size        = 0;
        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 2.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 2.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 2.\n";
        }
        else if (cur_size != ((1500 * PICO_ENTRY_SIZE) + MONSTER_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 2.\n";
        }
        else if (cur_num_entries != 1501) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 2.\n";
        }
    }

    if (pass) {

        max_size = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, NULL, NULL, NULL);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 3.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 3.\n";
        }
    }

    if (pass) {

        min_clean_size = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, &min_clean_size, NULL, NULL);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 4.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 4.\n";
        }
    }

    if (pass) {

        cur_size = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, NULL, &cur_size, NULL);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 5.\n";
        }
        else if (cur_size != ((1500 * PICO_ENTRY_SIZE) + MONSTER_ENTRY_SIZE)) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 5.\n";
        }
    }

    if (pass) {

        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, NULL, NULL, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size failed 6.\n";
        }
        else if (cur_num_entries != 1501) {

            pass         = false;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 2.\n";
        }
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s: failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_aux_fcns() */

/*-------------------------------------------------------------------------
 * Function:    check_metadata_blizzard_absence()
 *
 * Purpose:    Test to verify that a 'metadata blizzard' can not occur
 *              upon insertion into the cache.
 *
 *              A 'metadata blizzard' in this context occurs when the cache
 *              gets completely filled with all dirty entries. Upon needing
 *              to make space in the cache, the cache then has no clean
 *              entries ready to evict, and must clean every dirty entry
 *              in the cache first, due to the second chance replacement
 *              policy. (i.e. after cleaning an entry, it is bumped to the
 *              top of the LRU to make a second pass before eviction).
 *              The massive amount of sequential writes to disk while
 *              flushing the entire cache is what constitutes a 'metadata
 *              blizzard'.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_metadata_blizzard_absence(bool fill_via_insertion, unsigned paged)
{
    struct expected_entry_status *expected      = NULL;
    int                           entry_type    = HUGE_ENTRY_TYPE;
    size_t                        entry_size    = HUGE_ENTRY_SIZE; /* 16 KB */
    H5F_t                        *file_ptr      = NULL;
    H5C_t                        *cache_ptr     = NULL;
    bool                          show_progress = false;
    int32_t                       checkpoint    = 0;
    int32_t                       entry_idx     = 0;
    int32_t                       i;

    /* Expected deserialized status of entries depends on how they get into
     * the cache. Insertions = not deserialized, protect/unprotect = deserialized.
     */
    bool deserialized = (bool)!(fill_via_insertion);

    expected = malloc(150 * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* Set up the expected array. This is used to maintain a table of the
         * expected status of every entry used in this test.
         */
        for (i = 0; i < 150; i++) {
            expected[i].entry_type   = HUGE_ENTRY_TYPE;
            expected[i].entry_index  = (int)i;
            expected[i].size         = HUGE_ENTRY_SIZE;
            expected[i].in_cache     = false;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = false;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = false;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            memset(expected[i].flush_dep_par_type, 0, sizeof(expected[i].flush_dep_par_type));
            memset(expected[i].flush_dep_par_idx, 0, sizeof(expected[i].flush_dep_par_idx));

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        pass = true;
    }

    reset_entries();

    if (fill_via_insertion) {
        if (paged)
            TESTING("to ensure metadata blizzard absence when inserting (pgd aggr)");
        else
            TESTING("to ensure metadata blizzard absence when inserting");
    } /* end if */
    else {
        if (paged)
            TESTING("to ensure metadata blizzard absence on protect/unprotect (pa)");
        else
            TESTING("to ensure metadata blizzard absence on protect/unprotect");
    } /* end else */

    if (show_progress) /* 0 */
        fprintf(stdout, "\n%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Set up the cache.
         *
         * The max_cache_size should have room for 50 entries.
         * The min_clean_size is half of that, or 25 entries.
         */
        file_ptr = setup_cache((size_t)(50 * entry_size), (size_t)(25 * entry_size), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "bad return from cache initialization.\n";
        }
        else
            cache_ptr = file_ptr->shared->cache;
    }

    if (show_progress) /* 1 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 1:
     *
     *    Inserting dirty entries into an empty cache, until the cache
     *    violates the min_clean_size requirement. The expected result is
     *    that none of the inserted entries during this phase will get
     *    flushed or evicted.
     *
     *    This verifies that while maintaining min_clean_size, we don't go
     *    overboard and flush entries that we don't need to flush.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert 26 entries (indexes 0 through 25) into the cache.
         *
         * Note that we are inserting 26 entries, and not 25, because the cache
         * will only try to adhere to the min_clean_size if it's currently
         * being violated. Thus, on insertion of the 26th entry, since the
         * min_clean_size will not be violated, it will accept the insertion
         * without having to make clean space.
         */

        for (entry_idx = 0; entry_idx < 26; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* Change expected values, and verify the status of the entries
             * after each insertion
             */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;

            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 2 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 2:
     *
     *    Inserting entries into a cache that violates the min_clean_size,
     *    until the cache is full. The expected result is that each insertion
     *    will result in the flushing of a dirty entry in the cache.
     *
     *    This verifies that we maintain the min_clean_size. By doing so, we
     *    prevent building the situation in which a 'metadata blizzard' would
     *    occur (i.e., the cache being completely filled with dirty entries).
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert the 27th entry (index = 26) into the cache.
         *
         * This should cause the cache to flush its least recently used entry
         * before the insertion because it doesn't satisfy the min_clean_size
         * constraint.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 27 entries in the cache, and
         * entry number 0 has been cleaned.
         *
         * Changes from last entry verification:
         *   - entry w/ index 0 has now been flushed and is now clean.
         *   - entry w/ index 26 is now in the cache and dirty.
         */

        /* entry w/ index 0 has now been flushed and is now clean. */
        expected[0].is_dirty   = false;
        expected[0].serialized = true;

        /* entry w/ index 26 is now in the cache and dirty. */
        expected[26].in_cache     = true;
        expected[26].is_dirty     = true;
        expected[26].deserialized = (unsigned char)deserialized;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            26,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Insert the 28th entry (index = 27) into the cache.
         *
         * This should, once again, cause the cache to flush its least
         * recently used entry before the insertion as it again does not
         * satisfy the min_clean_size constraint.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 28 entries in the cache, and
         * entry numbers 0 and 1 have been cleaned.
         *
         * Changes from last entry verification:
         *   - entry w/ index 1 has now been flushed and is now clean.
         *   - entry w/ index 27 is now in the cache and dirty.
         */

        /* entry w/ index 1 has now been flushed and is now clean. */
        expected[1].is_dirty   = false;
        expected[1].serialized = true;

        /* entry w/ index 27 is now in the cache and dirty. */
        expected[27].in_cache     = true;
        expected[27].is_dirty     = true;
        expected[27].deserialized = (unsigned char)deserialized;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            27,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 4 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Fill out the rest of the cache with entries */
        /* Verify expected status of entries after each insertion */
        for (; entry_idx < 50; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* Expected status is that after each insertion, the entry
             * inserted 26 insertions ago has been flushed, and the
             * entry currently getting inserted is now in the cache and
             * dirty.
             */
            expected[entry_idx - 26].is_dirty   = false;
            expected[entry_idx - 26].serialized = true;

            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }

        /* Verify that the cache is now full */
        if (cache_ptr->cache_full != true) {

            pass         = false;
            failure_mssg = "cache not completely filled.\n";
        }
    }

    if (show_progress) /* 5 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 3:
     *
     *    Inserting entries into a cache that is completely full. Insertions
     *    of new entries will force evictions of old entries, but since the
     *    min_clean_size has been maintained, doing so will not result in
     *    the entire cache getting flushed in order to evict a single entry,
     *    as a clean entry will be available to flush reasonably close to
     *    the bottom of the LRU.
     *
     *    This verifies that with a maintained min_clean_size, a metadata
     *    blizzard does not occur on insertion.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert the 51st entry (index = 50) into the cache.
         *
         * The cache is full prior to the insertion, so it will
         * have to evict in order to make room for the new entry.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entry w/ index 0 has been evicted.
         *   - entries w/ indices 24,25 have now been flushed and are clean.
         *   - entry w/ index 50 is now in the cache and dirty.
         */

        /* entry w/ index 0 has been evicted. */
        expected[0].in_cache  = false;
        expected[0].destroyed = true;

        /* entries w/ indices 24,25 have now been flushed and are clean. */
        expected[24].is_dirty   = false;
        expected[24].serialized = true;
        expected[25].is_dirty   = false;
        expected[25].serialized = true;

        /* entry w/ index 50 is now in the cache and dirty */
        expected[50].in_cache     = true;
        expected[50].is_dirty     = true;
        expected[50].deserialized = (unsigned char)deserialized;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            50,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 6 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Insert 49 more entries (indices 51-99) into the cache.
         *
         * The cache will be flushing an entry on each insertion, and
         * evicting an entry on each insertion.
         *
         * After each insertion, verify the expected status of the
         * entries in the cache.
         */
        for (; entry_idx < 100; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;

            /* The entry inserted 50 insertions ago has been evicted */
            expected[entry_idx - 50].in_cache  = false;
            expected[entry_idx - 50].destroyed = true;

            /* If the newly inserted entry is among the first 24
             * insertions in this loop, then the insertion will
             * have resulted in a flush of the entry inserted
             * 25 insertions ago. */
            if (entry_idx < 75) {

                expected[entry_idx - 25].is_dirty   = false;
                expected[entry_idx - 25].serialized = true;
            }
            /* If the newly inserted entry is among the last
             * 25 insertions in this loop, then the insertion will
             * have resulted in a flush of the entry inserted 26
             * insertions ago. This switch is because there was two
             * consecutive clean entries in the cache (due to 51/49
             * dirty/clean ratio when full), so instead of
             * flush-then-evict, it switches to evict-then-flush. */
            else {

                expected[entry_idx - 26].is_dirty   = false;
                expected[entry_idx - 26].serialized = true;
            }

            /* Verify this expected status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }
    }

    if (show_progress) /* 7 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 4:
     *
     *    Flushing the entire cache, and then inserting entries into a cache
     *    that is completely full, but all clean.
     *
     *    Phases 1 and 2 are then repeated. Rather than inserting dirty entries
     *    into an empty cache, we're inserting into a full cache that's all
     *    clean, thus an eviction occurs before each insertion.
     *
     *    When the cache finally hits the point of violating the
     *    min_clean_size, the bottom half of the LRU will be filled with
     *    clean entries and the top half will be filled with recently inserted
     *    dirty entries. We'll then verify that an insertion will only evict
     *    one entry and flush one entry, and no more.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Flush the cache.
         *
         * We're doing this so we can repeat the above insertions, but
         * starting from a cache filled with clean entries as opposed
         * to an empty cache.
         */

        flush_cache(file_ptr, /* H5F_t * file_ptr */
                    false,    /* bool destory_entries */
                    false,    /* bool dump_stats */
                    false);   /* bool dump_detailed_stats */

        /* Verify that the cache is clean */
        verify_clean();

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entries w/ indices 74-99 have been flushed.
         */

        /* entries w/ indices 74-99 have been flushed. */
        for (i = 74; i < 100; i++) {

            expected[i].is_dirty   = false;
            expected[i].serialized = true;
        }
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            0,         /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 8 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Insert 26 entries (indexes 100 through 125) into the cache.
         *
         * The cache will evict 26 entries since it's currently full with
         * all clean entries. None of the entries we're inserting now
         * will get cleaned, however.
         */

        for (entry_idx = 100; entry_idx < 126; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;

            /* The entry with ID minus 50 will have been evicted */
            expected[entry_idx - 50].in_cache  = false;
            expected[entry_idx - 50].destroyed = true;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 9 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Insert the 127th entry (index = 126) into the cache. */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entry w/ index 76 is evicted.
         *   - entry w/ index 100 is cleaned.
         *   - entry w/ index 126 is now in the cache and dirty.
         */

        /* entry w/ index 76 has been evicted. */
        expected[76].in_cache  = false;
        expected[76].destroyed = true;

        /* entry w/ index 100 has now been flushed and is now clean. */
        expected[100].is_dirty   = false;
        expected[100].serialized = true;

        /* entry w/ index 26 is now in the cache and dirty. */
        expected[126].in_cache     = true;
        expected[126].is_dirty     = true;
        expected[126].deserialized = (unsigned char)deserialized;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            126,       /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 10 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (pass) {

        /* Insert entries w/ indices 127 through 149 into the cache */
        for (entry_idx = 127; entry_idx < 150; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;

            /* The entry with ID minus 50 will have been evicted */
            expected[entry_idx - 50].in_cache  = false;
            expected[entry_idx - 50].destroyed = true;

            /* The entry with ID minus 26 will now be clean */
            expected[entry_idx - 26].is_dirty   = false;
            expected[entry_idx - 26].serialized = true;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 11 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    if (cache_ptr) {

        /* We're done with testing. We can take down the cache. */
        takedown_cache(file_ptr, false, false);
        reset_entries();
    }

    if (show_progress) /* 12 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", __func__, checkpoint++, pass);

    free(expected);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    return (unsigned)!pass;

} /* check_metadata_blizzard_absence() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_deps()
 *
 * Purpose:    Exercise the flush dependency routines.
 *
 * Return:    0 on success, non-zero on failure
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_deps(unsigned paged)
{
    H5F_t        *file_ptr  = NULL;        /* File for this test */
    H5C_t        *cache_ptr = NULL;        /* Metadata cache for this test */
    test_entry_t *base_addr;               /* Base address of entries for test */
    int      entry_type = PICO_ENTRY_TYPE; /* Use very small entry size (size of entries doesn't matter) */
    unsigned u;                            /* Local index variable */

    /* clang-format off */
    struct expected_entry_status expected[5] =
    {
      /* entry        entry     in              at main   flush    dep       flush     dep       child     flush     flush       flush */
      /* type:        index:   size:            cache:    addr:    dirty:    prot:     pinned:   dsrlzd:   srlzd:    dest:  par type[]: par idx[]: dep npart: dep nchd: dep ndirty chd:       order: corked: */
      { PICO_ENTRY_TYPE, 0,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 1,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 2,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 3,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 4,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false}
    };
    /* clang-format on */

    if (paged)
        TESTING("flush dependencies (paged aggregation)");
    else
        TESTING("flush dependencies");

    pass = true;

    /* allocate a cache, build up flush dependency hierarchy and tear it down.
     * Verify that all performs as expected.
     */

    reset_entries();
    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;
    base_addr = entries[entry_type];

    if (!pass)
        CACHE_ERROR("setup_cache failed")

    /* Insert entries to work with into the cache */
    for (u = 0; u < 5; u++) {
        insert_entry(file_ptr, entry_type, (int32_t)u, H5C__NO_FLAGS_SET);
        if (!pass)
            CACHE_ERROR("insert_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each insertion
         */
        expected[u].in_cache = true;
        expected[u].is_dirty = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    } /* end for */

    /* Test Case #1 - Single flush dependency relationship */

    /* Create flush dependency between entries 0 (child) & 1 (parent) */
    {
        bool          in_cache, is_flush_dep_parent, is_flush_dep_child;
        test_entry_t *entry_ptr;

        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        /* Check the parent's entry status */
        entry_ptr = &(base_addr[1]);
        if (H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                 &is_flush_dep_parent, &is_flush_dep_child, NULL) < 0)
            CACHE_ERROR("H5C_get_entry_status() failed")
        if (!in_cache || is_flush_dep_parent || is_flush_dep_child)
            CACHE_ERROR("invalid entry status")

        /* Check the child's entry status */
        entry_ptr = &(base_addr[0]);
        if (H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                 &is_flush_dep_parent, &is_flush_dep_child, NULL) < 0)
            CACHE_ERROR("H5C_get_entry_status() failed")
        if (!in_cache || is_flush_dep_parent || is_flush_dep_child)
            CACHE_ERROR("invalid entry status")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Check the parent's entry status */
        entry_ptr = &(base_addr[1]);
        if (H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                 &is_flush_dep_parent, &is_flush_dep_child, NULL) < 0)
            CACHE_ERROR("H5C_get_entry_status() failed")
        if (!in_cache || !is_flush_dep_parent || is_flush_dep_child)
            CACHE_ERROR("invalid entry status")

        /* Check the child's entry status */
        entry_ptr = &(base_addr[0]);
        if (H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL, NULL,
                                 &is_flush_dep_parent, &is_flush_dep_child, NULL) < 0)
            CACHE_ERROR("H5C_get_entry_status() failed")
        if (!in_cache || is_flush_dep_parent || !is_flush_dep_child)
            CACHE_ERROR("invalid entry status")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 0 (child) & 1 (parent) */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #2 - Multiple children for one parent flush dependency relationship */

    /* Create flush dependency between entries 0, 1 (children) & 2 (parent) */
    {
        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 2;
        expected[0].flush_dep_npar        = 1;
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 2;
        expected[2].flush_dep_ndirty_chd  = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 0, 1 (children) & 2 (parent) */
    {
        destroy_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3a1 - Single chain of flush dependencies, 4 entries tall
     *      created from the "bottom up" and destroyed from the "top down"
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;
        expected[3].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "top down" */
    {
        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar       = 0;
        expected[3].is_protected         = false;
        expected[3].is_pinned            = false;
        expected[3].flush_dep_nchd       = 0;
        expected[3].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3a2 - Single chain of flush dependencies, 4 entries tall
     *      created from the "bottom up" and destroyed from the "bottom up"
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;
        expected[3].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "bottom up" */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar       = 0;
        expected[3].is_protected         = false;
        expected[3].is_pinned            = false;
        expected[3].flush_dep_nchd       = 0;
        expected[3].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3b1 - Single chain of flush dependencies, 4 entries tall
     *      created from the "top down" and destroyed from the "top down"
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;
        expected[3].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "top down" */
    {
        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar       = 0;
        expected[3].is_protected         = false;
        expected[3].is_pinned            = false;
        expected[3].flush_dep_nchd       = 0;
        expected[3].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3b2 - Single chain of flush dependencies, 4 entries tall
     *      created from the "top down" and destroyed from the "bottom up"
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;
        expected[3].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "bottom up" */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar       = 0;
        expected[3].is_protected         = false;
        expected[3].is_pinned            = false;
        expected[3].flush_dep_nchd       = 0;
        expected[3].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #4 - Multiple children for a single parent */

    /* Create flush dependency between entries (child) 0,1,2,3->4 (parent) */
    {
        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        for (u = 0; u < 4; u++) {
            create_flush_dependency(entry_type, 4, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("create_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after creating flush dependency
             */
            expected[u].flush_dep_par_type[0] = entry_type;
            expected[u].flush_dep_par_idx[0]  = 4;
            expected[u].flush_dep_npar        = 1;
            expected[4].is_protected          = true;
            expected[4].is_pinned             = true;
            expected[4].flush_dep_nchd++;
            expected[4].flush_dep_ndirty_chd++;

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Destroy flush dependency between entries */
    {
        for (u = 0; u < 4; u++) {
            destroy_flush_dependency(entry_type, 4, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("destroy_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after destroying flush dependency
             */
            expected[u].flush_dep_npar = 0;
            expected[4].flush_dep_nchd--;
            expected[4].flush_dep_ndirty_chd--;

            /* Check for destroying flush dependency on last entry */
            if (3 == u) {
                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                4,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")

                /* Change expected values, and verify the status of the entries
                 * after destroying flush dependency
                 */
                expected[4].is_protected = false;
                expected[4].is_pinned    = false;
            } /* end if */

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Test Case #5a - Join two flush dependency chains together, creating a single
     *      un-forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1 and 3->4 (parent)
     *  then add entry 4 as a child of 0
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;
        expected[4].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 0;
        expected[4].flush_dep_npar        = 1;
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 1;
        expected[0].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 0 first */
    {
        destroy_flush_dependency(entry_type, 0, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar       = 0;
        expected[0].is_protected         = false;
        expected[0].is_pinned            = false;
        expected[0].flush_dep_nchd       = 0;
        expected[0].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar       = 0;
        expected[4].is_protected         = false;
        expected[4].is_pinned            = false;
        expected[4].flush_dep_nchd       = 0;
        expected[4].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #5b - Join two flush dependency chains together, creating a
     *      forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1->2 and 3->4 (parent)
     *  then add entry 4 as a child of 1
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5F_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;
        expected[4].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 1, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 1;
        expected[4].flush_dep_npar        = 1;
        expected[1].flush_dep_nchd        = 2;
        expected[1].flush_dep_ndirty_chd  = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 1 first */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar       = 0;
        expected[1].flush_dep_nchd       = 1;
        expected[1].flush_dep_ndirty_chd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar       = 0;
        expected[4].is_protected         = false;
        expected[4].is_pinned            = false;
        expected[4].flush_dep_nchd       = 0;
        expected[4].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #5c - Join two flush dependency chains together, creating a
     *      forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1->2 and 3->4 (parent)
     *  then add entry 4 as a child of 2
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;
        expected[4].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 2, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 2;
        expected[4].flush_dep_npar        = 1;
        expected[2].flush_dep_nchd        = 2;
        expected[2].flush_dep_ndirty_chd  = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 2 first */
    {
        destroy_flush_dependency(entry_type, 2, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar       = 0;
        expected[2].flush_dep_nchd       = 1;
        expected[2].flush_dep_ndirty_chd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar       = 0;
        expected[4].is_protected         = false;
        expected[4].is_pinned            = false;
        expected[4].flush_dep_nchd       = 0;
        expected[4].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #6a - Make certain that flush dependency relationship with parent
     *      already pinned works (unpin ater destroying flush dependency)
     */

    /* Create flush dependency between entries 0 (child) & 1 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        pin_entry(entry_type, 1);
        if (!pass)
            CACHE_ERROR("pin_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Unpin entry & destroy flush dependency between entries 0 (child) & 1 (parent) */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unpin_entry(entry_type, 1);
        if (!pass)
            CACHE_ERROR("unpin_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #6b - Make certain that flush dependency relationship with parent
     *      already pinned works (unpin before destroying flush dependency)
     */

    /* Create flush dependency between entries 0 (child) & 1 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        pin_entry(entry_type, 1);
        if (!pass)
            CACHE_ERROR("pin_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Unpin entry & destroy flush dependency between entries 0 (child) & 1 (parent) */
    {
        unpin_entry(entry_type, 1);
        if (!pass)
            CACHE_ERROR("unpin_entry failed")

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[1].is_protected         = false;
        expected[1].is_pinned            = false;
        expected[1].flush_dep_nchd       = 0;
        expected[1].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #7 - Simple multiple parents
     */

    /* Create flush dependency between entries (child) 0 and 1, 2 (parents)
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[1] = entry_type;
        expected[0].flush_dep_par_idx[1]  = 2;
        expected[0].flush_dep_npar        = 2;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[2].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 2;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = false;
        expected[1].is_pinned             = false;
        expected[1].flush_dep_nchd        = 0;
        expected[1].flush_dep_ndirty_chd  = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar       = 0;
        expected[2].is_protected         = false;
        expected[2].is_pinned            = false;
        expected[2].flush_dep_nchd       = 0;
        expected[2].flush_dep_ndirty_chd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

done:
    if (file_ptr)
        takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else {
        H5_FAILED();
        fprintf(stdout, "%s.\n", failure_mssg);
    } /* end else */

    return (unsigned)!pass;
} /* check_flush_deps() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_deps_err()
 *
 * Purpose:    Check  the flush dependency routines for error conditions.
 *
 * Return:    0 on success, non-zero on failure
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_deps_err(unsigned paged)
{
    H5F_t   *file_ptr   = NULL;            /* File for this test */
    int      entry_type = PICO_ENTRY_TYPE; /* Use very small entry size (size of entries doesn't matter) */
    unsigned test_count;                   /* Test iteration variable */

    if (paged)
        TESTING("flush dependency errors (paged aggregation)");
    else
        TESTING("flush dependency errors");

    pass = true;

    /* Loop over test cases, check for various errors in configuring flush
     *  dependencies.  Verify that all performs as expected.
     */
    for (test_count = 0; test_count < 7; test_count++) {
        unsigned u;      /* Local index variable */
        herr_t   result; /* Generic return value */

        /* Allocate a cache */
        reset_entries();
        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
        if (!pass)
            CACHE_ERROR("setup_cache failed")

        /* Insert entries to work with into the cache */
        for (u = 0; u < 10; u++) {
            insert_entry(file_ptr, entry_type, (int32_t)u, H5C__NO_FLAGS_SET);
            if (!pass)
                CACHE_ERROR("insert_entry failed")
        } /* end for */

        /* Various test cases */
        switch (test_count) {
            /* Verify that parent entry in flush dependency must be protected */
            case 0:
                result =
                    H5C_create_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[1]));
                if (result != FAIL)
                    CACHE_ERROR("Creating flush dependency with unprotected entry succeeded")
                break;

            /* Verify that entry can't have flush dependency on itself */
            case 1:
                protect_entry(file_ptr, entry_type, 0);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                result =
                    H5C_create_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[0]));
                if (result != FAIL)
                    CACHE_ERROR("Creating flush dependency with parent == child")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                0,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")
                break;

            /* Verify that parent entry must be protected */
            case 2:
                result =
                    H5C_destroy_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[1]));
                if (result != FAIL)
                    CACHE_ERROR("Destroying [non-existent] dependency when parent isn't protected")
                break;

            /* Verify that parent entry has flush dependency */
            case 3:
                protect_entry(file_ptr, entry_type, 0);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                result =
                    H5C_destroy_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[1]));
                if (result != FAIL)
                    CACHE_ERROR("Destroying dependency when parent isn't in relationship")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                0,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")
                break;

            /* Verify that child entry is in flush dependency relationship */
            case 4:
                protect_entry(file_ptr, entry_type, 0);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                result =
                    H5C_destroy_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[2]));
                if (result != FAIL)
                    CACHE_ERROR("Destroying dependency when child isn't in relationship")

                destroy_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                0,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")
                break;

            /* Verify that parent has child as direct descendant */
            case 5:
                protect_entry(file_ptr, entry_type, 0);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                protect_entry(file_ptr, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 1, entry_type, 2);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                protect_entry(file_ptr, entry_type, 3);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 3, entry_type, 4);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                result =
                    H5C_destroy_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[4]));
                if (result != FAIL)
                    CACHE_ERROR("Destroying dependency when child is not a direct descendant has no children "
                                "at child's height")

                destroy_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                0,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")

                destroy_flush_dependency(entry_type, 1, entry_type, 2);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                1,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")

                destroy_flush_dependency(entry_type, 3, entry_type, 4);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                3,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")
                break;

            /* Verify that child entry is child of parent */
            case 6:
                protect_entry(file_ptr, entry_type, 0);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                protect_entry(file_ptr, entry_type, 2);
                if (!pass)
                    CACHE_ERROR("protect_entry failed")

                create_flush_dependency(entry_type, 2, entry_type, 3);
                if (!pass)
                    CACHE_ERROR("create_flush_dependency failed")

                result =
                    H5C_destroy_flush_dependency(&((entries[entry_type])[0]), &((entries[entry_type])[3]));
                if (result != FAIL)
                    CACHE_ERROR("Destroying dependency when child isn't in relationship")

                destroy_flush_dependency(entry_type, 0, entry_type, 1);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                0,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")

                destroy_flush_dependency(entry_type, 2, entry_type, 3);
                if (!pass)
                    CACHE_ERROR("destroy_flush_dependency failed")

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                2,                  /* int32_t idx */
                                H5C__NO_FLAGS_SET); /* unsigned int flags */
                if (!pass)
                    CACHE_ERROR("unprotect_entry failed")
                break;

            default:
                CACHE_ERROR("Unknown test case!")
        } /* end switch */

        takedown_cache(file_ptr, false, false);
        if (!pass)
            CACHE_ERROR("takedown_cache failed")
        file_ptr = NULL;
    } /* end for */

done:
    if (file_ptr)
        takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else {
        H5_FAILED();
        fprintf(stdout, "%s.\n", failure_mssg);
    } /* end else */

    return (unsigned)!pass;
} /* check_flush_deps_err() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_deps_order()
 *
 * Purpose:     Verify that the order that entries with flush dependencies
 *              is correct
 *
 * Return:      0 on success, non-zero on failure
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_deps_order(unsigned paged)
{
    H5F_t   *file_ptr   = NULL;            /* File for this test */
    H5C_t   *cache_ptr  = NULL;            /* Metadata cache for this test */
    int      entry_type = PICO_ENTRY_TYPE; /* Use very small entry size (size of entries doesn't matter) */
    unsigned u;                            /* Local index variable */
    unsigned flush_order;                  /* Index for tracking flush order */
    /* clang-format off */
    struct expected_entry_status expected[5] =
    {
      /* entry            entry        in    at main                                                        flush dep flush dep child flush   flush       flush */
      /* type:        index:    size:        cache:    addr:    dirty:    prot:    pinned:    dsrlzd:    srlzd:    dest:  par type[]: par idx[]: dep npart: dep nchd: dep ndirty chd: order:    corked: */
      { PICO_ENTRY_TYPE, 0,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 1,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 2,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 3,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { PICO_ENTRY_TYPE, 4,    PICO_ENTRY_SIZE, false,    true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false}
    };
    /* clang-format on */

    if (paged)
        TESTING("flush dependencies flush order (paged aggregation)");
    else
        TESTING("flush dependencies flush order");

    pass = true;

    /* allocate a cache, build up flush dependency hierarchy and tear it down.
     * Verify that all performs as expected.
     */

    reset_entries();
    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    cache_ptr = file_ptr->shared->cache;

    if (!pass)
        CACHE_ERROR("setup_cache failed")

    /* Insert entries to work with into the cache */
    for (u = 0; u < 5; u++) {
        insert_entry(file_ptr, entry_type, (int32_t)u, H5C__NO_FLAGS_SET);
        if (!pass)
            CACHE_ERROR("insert_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each insertion
         */
        expected[u].in_cache = true;
        expected[u].is_dirty = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    } /* end for */

    /* Test Case #1a - Single flush dependency relationship, increasing addr order */

    /* Create flush dependency between entries 0 (child) & 1 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[1].flush_dep_ndirty_chd  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty             = false;
        expected[0].serialized           = true;
        expected[0].flush_order          = 0;
        expected[1].is_dirty             = false;
        expected[1].serialized           = true;
        expected[1].flush_order          = 1;
        expected[1].is_protected         = false;
        expected[1].flush_dep_ndirty_chd = 0;
        expected[2].is_dirty             = false;
        expected[2].serialized           = true;
        expected[3].is_dirty             = false;
        expected[3].serialized           = true;
        expected[4].is_dirty             = false;
        expected[4].serialized           = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 0 (child) & 1 (parent) */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #1b - Single flush dependency relationship, decreasing addr order */

    /* Create flush dependency between entries 0 (child) & 1 (parent) */
    {
        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 1;
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 0;
        expected[1].flush_dep_npar        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0 & 1 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, true);
        dirty_entry(file_ptr, entry_type, 1, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 1;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 0 (child) & 1 (parent) */
    {
        destroy_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_pinned      = false;
        expected[0].flush_dep_nchd = 0;
        expected[1].flush_dep_npar = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #2a - Multiple children for one parent flush dependency relationship
     *      increasing addr order
     */

    /* Create flush dependency between entries 0, 1 (children) & 2 (parent) */
    {
        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 2;
        expected[0].flush_dep_npar        = 1;
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0, 1 & 2 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, false);
        dirty_entry(file_ptr, entry_type, 2, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 1;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 2;
        expected[2].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 0, 1 (children) & 2 (parent) */
    {
        destroy_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].flush_dep_npar = 0;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #2b - Multiple children for one parent flush dependency relationship
     *      decreasing addr order
     */

    /* Create flush dependency between entries 1, 2 (children) & 0 (parent) */
    {
        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        create_flush_dependency(entry_type, 0, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 2;
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 0;
        expected[1].flush_dep_npar        = 1;
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 0;
        expected[2].flush_dep_npar        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0, 1 & 2 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, true);
        dirty_entry(file_ptr, entry_type, 1, false);
        dirty_entry(file_ptr, entry_type, 2, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 2;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 0;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries 1, 2 (children) & 0 (parent) */
    {
        destroy_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        destroy_flush_dependency(entry_type, 0, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_pinned      = false;
        expected[0].flush_dep_nchd = 0;
        expected[1].flush_dep_npar = 0;
        expected[2].flush_dep_npar = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3a - Single chain of flush dependencies, 4 entries tall,
     *      increasing addr order
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-3 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 1;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 2;
        expected[2].is_protected = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 3;
        expected[3].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "top down" */
    {
        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar = 0;
        expected[3].is_pinned      = false;
        expected[3].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 0;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #3b - Single chain of flush dependencies, 4 entries tall
     *      decreasing addr order
     */

    /* Create flush dependency between entries (child) 0->1->2->3 (parent) */
    {
        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 1;
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 0;
        expected[1].flush_dep_npar        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 1;
        expected[2].flush_dep_npar        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 2;
        expected[3].flush_dep_npar        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-3 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, true);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 3;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 2;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 1;
        expected[2].is_protected = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, from the "bottom up" */
    {
        destroy_flush_dependency(entry_type, 2, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;
        expected[3].flush_dep_npar = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;
        expected[2].flush_dep_npar = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].is_pinned      = false;
        expected[0].flush_dep_nchd = 0;
        expected[1].flush_dep_npar = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #4a - Multiple children for a single parent, increasing addr order  */

    /* Create flush dependency between entries (child) 0,1,2,3->4 (parent) */
    {
        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        for (u = 0; u < 4; u++) {
            create_flush_dependency(entry_type, 4, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("create_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after creating flush dependency
             */
            expected[u].flush_dep_par_type[0] = entry_type;
            expected[u].flush_dep_par_idx[0]  = 4;
            expected[u].flush_dep_npar        = 1;
            expected[4].is_protected          = true;
            expected[4].is_pinned             = true;
            expected[4].flush_dep_nchd        = u + 1;

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 4, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-4 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, false);
        dirty_entry(file_ptr, entry_type, 2, false);
        dirty_entry(file_ptr, entry_type, 3, false);
        dirty_entry(file_ptr, entry_type, 4, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;
        expected[4].serialized  = false;
        expected[4].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 1;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 2;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 3;
        expected[4].is_dirty     = false;
        expected[4].serialized   = true;
        expected[4].flush_order  = 4;
        expected[4].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries */
    {
        for (u = 0; u < 4; u++) {
            destroy_flush_dependency(entry_type, 4, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("destroy_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after destroying flush dependency
             */
            expected[u].flush_dep_npar = 0;
            expected[4].flush_dep_nchd = 3 - u;

            /* Check for destroying flush dependency on last entry */
            if (3 == u) {
                /* Change expected values, and verify the status of the entries
                 * after destroying flush dependency
                 */
                expected[4].is_pinned = false;
            } /* end if */

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Test Case #4b - Multiple children for a single parent, decreasing addr order  */

    /* Create flush dependency between entries (child) 0,1,2,3->4 (parent) */
    {
        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        for (u = 1; u < 5; u++) {
            create_flush_dependency(entry_type, 0, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("create_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after creating flush dependency
             */
            expected[u].flush_dep_par_type[0] = entry_type;
            expected[u].flush_dep_par_idx[0]  = 0;
            expected[u].flush_dep_npar        = 1;
            expected[0].is_protected          = true;
            expected[0].is_pinned             = true;
            expected[0].flush_dep_nchd        = u;

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 4, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-4 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, true);
        dirty_entry(file_ptr, entry_type, 1, false);
        dirty_entry(file_ptr, entry_type, 2, false);
        dirty_entry(file_ptr, entry_type, 3, false);
        dirty_entry(file_ptr, entry_type, 4, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;
        expected[4].serialized  = false;
        expected[4].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 4;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 0;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 1;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 2;
        expected[4].is_dirty     = false;
        expected[4].serialized   = true;
        expected[4].flush_order  = 3;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries */
    {
        for (u = 1; u < 5; u++) {
            destroy_flush_dependency(entry_type, 0, entry_type, (int32_t)u);
            if (!pass)
                CACHE_ERROR("destroy_flush_dependency failed")

            /* Change expected values, and verify the status of the entries
             * after destroying flush dependency
             */
            expected[u].flush_dep_npar = 0;
            expected[0].flush_dep_nchd = 4 - u;

            /* Check for destroying flush dependency on last entry */
            if (4 == u) {
                /* Change expected values, and verify the status of the entries
                 * after destroying flush dependency
                 */
                expected[0].is_pinned = false;
            } /* end if */

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                (int)0,    /* int tag */
                                (int)5,    /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
            if (!pass)
                CACHE_ERROR("verify_entry_status failed")
        } /* end for */
    }

    /* Test Case #5a - Join two flush dependency chains together, creating a single
     *      un-forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1 and 3->4 (parent)
     *  then add entry 4 as a child of 0
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 0;
        expected[4].flush_dep_npar        = 1;
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 4, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0 & 1, 3 & 4 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, true);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        dirty_entry(file_ptr, entry_type, 4, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;
        expected[4].serialized  = false;
        expected[4].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 2;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 3;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 0;
        expected[4].is_dirty     = false;
        expected[4].serialized   = true;
        expected[4].flush_order  = 1;
        expected[4].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 0 first */
    {
        destroy_flush_dependency(entry_type, 0, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar = 0;
        expected[0].is_pinned      = false;
        expected[0].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 0;
        expected[4].is_pinned      = false;
        expected[4].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #5b - Join two flush dependency chains together, creating a
     *      forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1->2 and 3->4 (parent)
     *  then add entry 4 as a child of 1
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 1, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 1;
        expected[4].flush_dep_npar        = 1;
        expected[1].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 4, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-4 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        dirty_entry(file_ptr, entry_type, 4, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;
        expected[4].serialized  = false;
        expected[4].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 3;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 4;
        expected[2].is_protected = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 1;
        expected[4].is_dirty     = false;
        expected[4].serialized   = true;
        expected[4].flush_order  = 2;
        expected[4].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 1 first */
    {
        destroy_flush_dependency(entry_type, 1, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar = 0;
        expected[1].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 0;
        expected[4].is_pinned      = false;
        expected[4].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 0;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #5c - Join two flush dependency chains together, creating a
     *      forked dependency chain
     */

    /* Create flush dependency between entries (child) 0->1->2 and 3->4 (parent)
     *  then add entry 4 as a child of 2
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 4);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 4;
        expected[3].flush_dep_npar        = 1;
        expected[4].is_protected          = true;
        expected[4].is_pinned             = true;
        expected[4].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 2, entry_type, 4);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[4].flush_dep_par_type[0] = entry_type;
        expected[4].flush_dep_par_idx[0]  = 2;
        expected[4].flush_dep_npar        = 1;
        expected[2].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 4, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        4,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-4 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        dirty_entry(file_ptr, entry_type, 4, true);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'serialized' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;
        expected[4].serialized  = false;
        expected[4].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 1;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 4;
        expected[2].is_protected = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 2;
        expected[4].is_dirty     = false;
        expected[4].serialized   = true;
        expected[4].flush_order  = 3;
        expected[4].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, detaching 3->4 from 2 first */
    {
        destroy_flush_dependency(entry_type, 2, entry_type, 4);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[4].flush_dep_npar = 0;
        expected[2].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 4, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 0;
        expected[4].is_pinned      = false;
        expected[4].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 0;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #6a - Interlocked multiple parents, increasing addr order
     */

    /* Create flush dependencies between entries 0-3, with each entry a child
     * of every entry with a higher number.
     */
    {
        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[0] = entry_type;
        expected[0].flush_dep_par_idx[0]  = 1;
        expected[0].flush_dep_npar        = 1;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[1] = entry_type;
        expected[0].flush_dep_par_idx[1]  = 2;
        expected[0].flush_dep_npar        = 2;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 2;
        expected[1].flush_dep_npar        = 1;
        expected[2].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 3);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 3, entry_type, 0);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[0].flush_dep_par_type[2] = entry_type;
        expected[0].flush_dep_par_idx[2]  = 3;
        expected[0].flush_dep_npar        = 3;
        expected[3].is_protected          = true;
        expected[3].is_pinned             = true;
        expected[3].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 3, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[1] = entry_type;
        expected[1].flush_dep_par_idx[1]  = 3;
        expected[1].flush_dep_npar        = 2;
        expected[3].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 3;
        expected[2].flush_dep_npar        = 1;
        expected[3].flush_dep_nchd        = 3;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        3,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-3 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'flushed' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 0;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 1;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 2;
        expected[2].is_protected = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 3;
        expected[3].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, in reverse order */
    {
        destroy_flush_dependency(entry_type, 3, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar = 0;
        expected[3].flush_dep_nchd = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 3, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 1;
        expected[3].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 3, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 2;
        expected[3].is_pinned      = false;
        expected[3].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 0;
        expected[2].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 1;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 0);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[0].flush_dep_npar = 0;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Test Case #6b - Interlocked multiple parents, decreasing addr order
     */

    /* Create flush dependencies between entries 0-3, with each entry a parent
     * of every entry with a higher number.
     */
    {
        protect_entry(file_ptr, entry_type, 2);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 2, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[0] = entry_type;
        expected[3].flush_dep_par_idx[0]  = 2;
        expected[3].flush_dep_npar        = 1;
        expected[2].is_protected          = true;
        expected[2].is_pinned             = true;
        expected[2].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 1);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 1, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[1] = entry_type;
        expected[3].flush_dep_par_idx[1]  = 1;
        expected[3].flush_dep_npar        = 2;
        expected[1].is_protected          = true;
        expected[1].is_pinned             = true;
        expected[1].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 1, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[0] = entry_type;
        expected[2].flush_dep_par_idx[0]  = 1;
        expected[2].flush_dep_npar        = 1;
        expected[1].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        protect_entry(file_ptr, entry_type, 0);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        create_flush_dependency(entry_type, 0, entry_type, 3);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[3].flush_dep_par_type[2] = entry_type;
        expected[3].flush_dep_par_idx[2]  = 0;
        expected[3].flush_dep_npar        = 3;
        expected[0].is_protected          = true;
        expected[0].is_pinned             = true;
        expected[0].flush_dep_nchd        = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 0, entry_type, 2);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[2].flush_dep_par_type[1] = entry_type;
        expected[2].flush_dep_par_idx[1]  = 0;
        expected[2].flush_dep_npar        = 2;
        expected[0].flush_dep_nchd        = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        create_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("create_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after creating flush dependency
         */
        expected[1].flush_dep_par_type[0] = entry_type;
        expected[1].flush_dep_par_idx[0]  = 0;
        expected[1].flush_dep_npar        = 1;
        expected[0].flush_dep_nchd        = 3;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Flush the cache and verify that the entries were flushed in correct order */
    {
        add_flush_op(entry_type, 0, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 1, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 2, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);
        add_flush_op(entry_type, 3, FLUSH_OP__ORDER, entry_type, 0, false, (size_t)0, &flush_order);

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        0,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        1,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                        entry_type,         /* int32_t type */
                        2,                  /* int32_t idx */
                        H5C__NO_FLAGS_SET); /* unsigned int flags */
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Mark entries 0-3 dirty, so they are flushed */
        dirty_entry(file_ptr, entry_type, 0, false);
        dirty_entry(file_ptr, entry_type, 1, true);
        dirty_entry(file_ptr, entry_type, 2, true);
        dirty_entry(file_ptr, entry_type, 3, false);
        if (!pass)
            CACHE_ERROR("dirty_entry failed")

        /* Reset 'flushed' flag & 'flush_order' value in expected array */
        expected[0].serialized  = false;
        expected[0].flush_order = -1;
        expected[1].serialized  = false;
        expected[1].flush_order = -1;
        expected[2].serialized  = false;
        expected[2].flush_order = -1;
        expected[3].serialized  = false;
        expected[3].flush_order = -1;

        /* Reset index for tracking flush order */
        flush_order = 0;

        H5C_FLUSH_CACHE(file_ptr, H5C__NO_FLAGS_SET, "dummy mssg")
        if (!pass)
            CACHE_ERROR("flushing entries with flush dependendices")

        /* Change expected values, and verify the status of the entries
         * after destroy flush dependency
         */
        expected[0].is_dirty     = false;
        expected[0].serialized   = true;
        expected[0].flush_order  = 3;
        expected[0].is_protected = false;
        expected[1].is_dirty     = false;
        expected[1].serialized   = true;
        expected[1].flush_order  = 2;
        expected[1].is_protected = false;
        expected[2].is_dirty     = false;
        expected[2].serialized   = true;
        expected[2].flush_order  = 1;
        expected[2].is_protected = false;
        expected[3].is_dirty     = false;
        expected[3].serialized   = true;
        expected[3].flush_order  = 0;
        expected[3].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

    /* Destroy flush dependency between entries, in reverse order */
    {
        destroy_flush_dependency(entry_type, 0, entry_type, 1);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[1].flush_dep_npar = 0;
        expected[0].flush_dep_nchd = 2;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 0, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar = 1;
        expected[0].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 0, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 2;
        expected[0].is_pinned      = false;
        expected[0].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 2);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[2].flush_dep_npar = 0;
        expected[1].flush_dep_nchd = 1;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 1, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 1;
        expected[1].is_pinned      = false;
        expected[1].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        destroy_flush_dependency(entry_type, 2, entry_type, 3);
        if (!pass)
            CACHE_ERROR("destroy_flush_dependency failed")

        /* Change expected values, and verify the status of the entries
         * after destroying flush dependency
         */
        expected[3].flush_dep_npar = 0;
        expected[2].is_pinned      = false;
        expected[2].flush_dep_nchd = 0;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)0,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")
    }

done:
    if (file_ptr)
        takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else {
        H5_FAILED();
        fprintf(stdout, "%s.\n", failure_mssg);
    } /* end else */

    return (unsigned)!pass;
} /* check_flush_deps_order() */

/*-------------------------------------------------------------------------
 * Function:    check_notify_cb()
 *
 * Purpose:    Exercise the client 'notify' callback.
 *
 * Return:    0 on success, non-zero on failure
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_notify_cb(unsigned paged)
{
    H5F_t        *file_ptr  = NULL;     /* File for this test */
    H5C_t        *cache_ptr = NULL;     /* Metadata cache for this test */
    test_entry_t *base_addr;            /* Base address of entries for test */
    test_entry_t *entry_ptr;            /* Cache entry to examine/manipulate */
    int entry_type = NOTIFY_ENTRY_TYPE; /* Use entry w/notify callback (size of entries doesn't matter) */
    unsigned u;                         /* Local index variable */
    /* clang-format off */
    struct expected_entry_status expected[5] =
    {
      /* entry            entry           in     at main                                               flush dep flush dep child flush   flush       flush */
      /* type:        index:    size:           cache: addr:    dirty:    prot:    pinned:    dsrlzd:    srlzd:    dest:  par type[]: par idx[]: dep npart: dep nchd: dep ndirty chd: order:    corked: */
      { NOTIFY_ENTRY_TYPE, 0,    NOTIFY_ENTRY_SIZE, false, true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { NOTIFY_ENTRY_TYPE, 1,    NOTIFY_ENTRY_SIZE, false, true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { NOTIFY_ENTRY_TYPE, 2,    NOTIFY_ENTRY_SIZE, false, true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { NOTIFY_ENTRY_TYPE, 3,    NOTIFY_ENTRY_SIZE, false, true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false},
      { NOTIFY_ENTRY_TYPE, 4,    NOTIFY_ENTRY_SIZE, false, true,    false,    false,    false,    false,    false,    false, {0,0,0,0,0,0,0,0},       {0,0,0,0,0,0,0,0},      0, 0, 0,          -1, false}
    };
    /* clang-format on */

    if (paged)
        TESTING("'notify' callback (paged)");
    else
        TESTING("'notify' callback");

    pass = true;

    /* Allocate a cache, insert & remove entries, triggering 'notify' callback.
     * Verify that all performs as expected.
     */

    reset_entries();
    file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024), paged);
    if (!file_ptr)
        CACHE_ERROR("setup_cache returned NULL")
    cache_ptr = file_ptr->shared->cache;
    base_addr = entries[entry_type];

    if (!pass)
        CACHE_ERROR("setup_cache failed")

    /* Insert entries to work with into the cache */
    for (u = 0; u < 5; u++) {
        insert_entry(file_ptr, entry_type, (int32_t)u, H5C__NO_FLAGS_SET);
        if (!pass)
            CACHE_ERROR("insert_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each insertion
         */
        expected[u].in_cache = true;
        expected[u].is_dirty = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        /* Check the entry's 'after insert' count */
        entry_ptr = &(base_addr[u]);
        if (1 != entry_ptr->notify_after_insert_count)
            CACHE_ERROR("invalid notify after insert count")
        if (0 != entry_ptr->notify_before_evict_count)
            CACHE_ERROR("invalid notify before evict count")
    } /* end for */

    /* Remove entries from the cache */
    for (u = 0; u < 5; u++) {
        expunge_entry(file_ptr, entry_type, (int32_t)u);
        if (!pass)
            CACHE_ERROR("expunge_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each expunge
         */
        expected[u].in_cache   = false;
        expected[u].is_dirty   = true;
        expected[u].serialized = false;
        expected[u].destroyed  = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        /* Check the entry's 'before evict' count */
        entry_ptr = &(base_addr[u]);
        if (1 != entry_ptr->notify_after_insert_count)
            CACHE_ERROR("invalid notify after insert count")
        if (1 != entry_ptr->notify_before_evict_count)
            CACHE_ERROR("invalid notify before evict count")
    } /* end for */

    /* Protect entries to bring them into the cache */
    for (u = 0; u < 5; u++) {
        protect_entry(file_ptr, entry_type, (int32_t)u);
        if (!pass)
            CACHE_ERROR("protect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each insertion
         */
        expected[u].in_cache     = true;
        expected[u].is_dirty     = false;
        expected[u].is_protected = true;
        expected[u].deserialized = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        /* Check the entry's 'after insert' count */
        entry_ptr = &(base_addr[u]);
        if (2 != entry_ptr->notify_after_insert_count)
            CACHE_ERROR("invalid notify after insert count")
        if (1 != entry_ptr->notify_before_evict_count)
            CACHE_ERROR("invalid notify before evict count")
    } /* end for */

    /* Unprotect entries, evicting them from the cache */
    for (u = 0; u < 5; u++) {
        unprotect_entry(file_ptr, entry_type, (int32_t)u, H5C__DIRTIED_FLAG);
        if (!pass)
            CACHE_ERROR("unprotect_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each insertion
         */
        expected[u].in_cache     = true;
        expected[u].is_dirty     = true;
        expected[u].is_protected = false;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        /* Check the entry's 'after insert' count */
        entry_ptr = &(base_addr[u]);
        if (2 != entry_ptr->notify_after_insert_count)
            CACHE_ERROR("invalid notify after insert count")
        if (1 != entry_ptr->notify_before_evict_count)
            CACHE_ERROR("invalid notify before evict count")
    } /* end for */

    /* Remove entries from the cache */
    for (u = 0; u < 5; u++) {
        expunge_entry(file_ptr, entry_type, (int32_t)u);
        if (!pass)
            CACHE_ERROR("expunge_entry failed")

        /* Change expected values, and verify the status of the entries
         * after each expunge
         */
        expected[u].in_cache   = false;
        expected[u].is_dirty   = true;
        expected[u].serialized = false;
        expected[u].destroyed  = true;

        /* Verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            (int)u,    /* int tag */
                            (int)5,    /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
        if (!pass)
            CACHE_ERROR("verify_entry_status failed")

        /* Check the entry's 'before evict' count */
        entry_ptr = &(base_addr[u]);
        if (2 != entry_ptr->notify_after_insert_count)
            CACHE_ERROR("invalid notify after insert count")
        if (2 != entry_ptr->notify_before_evict_count)
            CACHE_ERROR("invalid notify before evict count")
    } /* end for */

done:
    takedown_cache(file_ptr, false, false);

    if (pass)
        PASSED();
    else {
        H5_FAILED();
        fprintf(stdout, "%s.\n", failure_mssg);
    } /* end else */

    return (unsigned)!pass;
} /* check_notify_cb() */

/*-------------------------------------------------------------------------
 * Function:    check_metadata_cork
 *
 * Purpose:    To verify that dirty corked entries are not evicted from the cache
 *        but clean corked entries can be evicted from the cache.
 *        The min_clean_size does not have effect.
 *        NOTE: This is a modification of check_metadata_blizzard_absence().
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_metadata_cork(bool fill_via_insertion, unsigned paged)
{
    struct expected_entry_status *expected      = NULL;
    const char                   *fcn_name      = "check_metadata_cork";
    int                           entry_type    = HUGE_ENTRY_TYPE;
    size_t                        entry_size    = HUGE_ENTRY_SIZE; /* 16 KB */
    H5F_t                        *file_ptr      = NULL;
    H5C_t                        *cache_ptr     = NULL;
    bool                          show_progress = false;
    int32_t                       checkpoint    = 0;
    int32_t                       entry_idx     = 0;
    int32_t                       i;

    /* Expected deserialized status of entries depends on how they get into
     * the cache. Insertions = not deserialized, protect/unprotect = deserialized.
     */
    bool deserialized = (bool)!(fill_via_insertion);

    expected = malloc(150 * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* Set up the expected array. This is used to maintain a table of the
         * expected status of every entry used in this test.
         */
        for (i = 0; i < 150; i++) {
            expected[i].entry_type   = HUGE_ENTRY_TYPE;
            expected[i].entry_index  = (int)i;
            expected[i].size         = HUGE_ENTRY_SIZE;
            expected[i].in_cache     = false;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = false;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = false;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            memset(expected[i].flush_dep_par_type, 0, sizeof(expected[i].flush_dep_par_type));
            memset(expected[i].flush_dep_par_idx, 0, sizeof(expected[i].flush_dep_par_idx));

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        pass = true;
    }

    reset_entries();

    if (fill_via_insertion)
        TESTING("to ensure cork/uncork metadata when inserting");
    else
        TESTING("to ensure cork/uncork metadata on protect/unprotect");

    if (show_progress) /* 0 */
        fprintf(stdout, "\n%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Set up the cache.
         *
         * The max_cache_size should have room for 50 entries.
         * The min_clean_size is half of that, or 25 entries.
         */
        file_ptr = setup_cache((size_t)(50 * entry_size), (size_t)(25 * entry_size), paged);

        if (file_ptr == NULL) {

            pass         = false;
            failure_mssg = "bad return from cache initialization.\n";
        }
        else
            cache_ptr = file_ptr->shared->cache;
    }

    /* Cork the cache entry type */
    cork_entry_type(file_ptr, entry_type);

    if (show_progress) /* 1 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 1:
     *
     *    Inserting dirty corked entries into an empty cache, until the cache
     *    violates the min_clean_size requirement.
     *      Since entries are all dirty and corked, no entry will get flushed or
     *      evicted.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert 26 entries (indexes 0 through 25) into the cache.  */
        for (entry_idx = 0; entry_idx < 26; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* Change expected values, and verify the status of the entries
             * after each insertion
             */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;
            expected[entry_idx].is_corked    = true;

            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 2 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 2:
     *
     *    Inserting entries into a cache that violates the min_clean_size,
     *    until the cache is full.
     *      Since entries are all dirty and corked, no entry during this phase
     *      will get flushed or evicted.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert the 27th entry (index = 26) into the cache.  */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 27 entries in the cache, and
         * all entries remain the same as before since they are all corked
         * and dirty
         */

        /* entry w/ index 26 is now in the cache and dirty. */
        expected[26].in_cache     = true;
        expected[26].is_dirty     = true;
        expected[26].deserialized = (unsigned char)deserialized;
        expected[26].is_corked    = true;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            26,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert the 28th entry (index = 27) into the cache.  */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 28 entries in the cache, and
         * all entries are dirty corked entries.
         *
         */
        expected[27].in_cache     = true;
        expected[27].is_dirty     = true;
        expected[27].deserialized = (unsigned char)deserialized;
        expected[27].is_corked    = true;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            27,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 4 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Fill out the rest of the cache with entries */
        /* Verify expected status of entries after each insertion */
        for (; entry_idx < 50; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /*
             * Expected status: all entries are dirty corked entries.
             */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;
            expected[entry_idx].is_corked    = true;

            /* Verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }

        /* Verify that the cache is now full */
        if (cache_ptr->cache_full != true) {

            pass         = false;
            failure_mssg = "cache not completely filled.\n";
        }
    }

    if (show_progress) /* 5 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 3:
     *    Inserting entries into a cache that is completely full.
     *      No entry is flushed or evicted because all entries are dirty & corked.
     *
     * ========================================================================
     * ========================================================================
     */

    if (show_progress) /* 6 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert 50 more entries (indices 50-99) into the cache.  */
        for (; entry_idx < 100; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache: dirty and corked */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;
            expected[entry_idx].is_corked    = true;

            /* Verify this expected status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }
    }

    if (show_progress) /* 7 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 4:
     *
     *    Flushing the entire cache, and then inserting entries into a cache
     *    that is completely full, but all clean.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Flush the cache.
         *
         * We're doing this so we can repeat the above insertions, but
         * starting from a cache filled with clean entries as opposed
         * to an empty cache.
         */

        flush_cache(file_ptr, /* H5F_t * file_ptr */
                    false,    /* bool destory_entries */
                    false,    /* bool dump_stats */
                    false);   /* bool dump_detailed_stats */

        /* Verify that the cache is clean */
        verify_clean();

        /* Verify the status of the entries.  */
        /* All entries are flushed, clean but still corked */
        for (i = 0; i < 100; i++) {
            expected[i].serialized = true;
            expected[i].is_dirty   = false;
            expected[i].is_corked  = true;
        }
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            0,         /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 8 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Will evict 50 clean "corked" entries all at once when inserting the 100th entry */
        for (i = 0; i < 51; i++) {
            expected[i].in_cache  = false;
            expected[i].destroyed = true;
            expected[i].is_corked = true;
        }

        /* Insert the 100th entry */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         100,                /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          100);       /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            100,                /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* The 100th inserted entry is now in the cache and dirty */
        expected[100].in_cache     = true;
        expected[100].is_dirty     = true;
        expected[100].deserialized = (unsigned char)deserialized;
        expected[100].is_corked    = true;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            100,       /* int tag */
                            150,       /* int num_entries */
                            expected); /* struct expected_entry_staus[] */
    }

    if (show_progress) /* 9 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert 25 more corked entries (indexes 101 through 125) into the cache. */
        /* Clean entry will be evicted one a time */
        for (entry_idx = 101; entry_idx < 126; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* The inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;
            expected[entry_idx].is_corked    = true;

            expected[entry_idx - 50].in_cache  = false;
            expected[entry_idx - 50].destroyed = true;
            expected[entry_idx - 50].is_corked = true;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }                                  /* end for */
    }

    if (show_progress) /* 10 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert the 127th entry (index = 126) into the cache. */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         126,                /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          126);       /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            126,                /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.  */
        expected[126].in_cache     = true;
        expected[126].is_dirty     = true;
        expected[126].deserialized = (unsigned char)deserialized;
        expected[126].is_corked    = true;

        expected[126 - 50].in_cache  = false;
        expected[126 - 50].destroyed = true;
        expected[126 - 50].is_corked = true;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            126,       /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 11 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert entries w/ indices 127 through 149 into the cache */
        for (entry_idx = 127; entry_idx < 150; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache, dirty and corked */
            expected[entry_idx].in_cache     = true;
            expected[entry_idx].is_dirty     = true;
            expected[entry_idx].deserialized = (unsigned char)deserialized;
            expected[entry_idx].is_corked    = true;

            /* Entry that is 50 entries away will be evicted since it is clean even though corked */
            expected[entry_idx - 50].in_cache  = false;
            expected[entry_idx - 50].destroyed = true;
            expected[entry_idx - 50].is_corked = true;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 12 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* We're done with testing. We can take down the cache. */
    takedown_cache(file_ptr, false, false);
    reset_entries();

    if (show_progress) /* 13 */
        fprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    free(expected);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    return (unsigned)!pass;

} /* check_metadata_cork() */

/*-------------------------------------------------------------------------
 * Function:    check_entry_deletions_during_scans()
 *
 * Purpose:    With the addition of the H5C__TAKE_OWNERSHIP_FLAG, it is
 *        possible for an entry to be removed from the cache as a
 *        side effect of flushing an entry.
 *
 *        For the most part, this doesn't cause problems.  However,
 *        during the scans of lists, it is possible that the entry
 *        removed will be the next entry in the scan -- which if not
 *        detected, will typeically cause the cache to attempt to flush
 *        an entry that is no longer in the cache, and which may have
 *        been deleted.
 *
 *        This function contains tests for correct handling on this
 *        situation.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_entry_deletions_during_scans(unsigned paged)
{
    H5F_t *file_ptr = NULL;

    if (paged)
        TESTING("entry deletion during list scan detection and adaption (par)");
    else
        TESTING("entry deletion during list scan detection and adaption");

    pass = true;

    /* allocate a cache, and flush it under various circumstances.
     * To the extent possible, verify that the desired actions took
     * place.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);
    }

    /* run the tests.  This set of tests is somewhat eclectic, as
     * we are trying to test all locations where the deletion of
     * an entry from the cache as a side effect of the fluch of
     * a different entry could cause problems.
     */

    if (pass) {

        cedds__expunge_dirty_entry_in_flush_test(file_ptr);
    }

    if (pass) {

        cedds__H5C_make_space_in_cache(file_ptr);
    }

    if (pass) {

        cedds__H5C__autoadjust__ageout__evict_aged_out_entries(file_ptr);
    }

    if (pass) {

        cedds__H5C_flush_invalidate_cache__bucket_scan(file_ptr);
    }

    takedown_cache(file_ptr, false, false);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_entry_deletions_during_scans() */

/*-------------------------------------------------------------------------
 *
 * Function:    cedds__expunge_dirty_entry_in_flush_test()
 *
 * Purpose:     Verify that H5C_flush_cache() can handle the removal of
 *              a dirty entry from the cache during its scan of the
 *              skip list.
 *
 *              Do this by setting up a full cache, with the last entry
 *              on the LRU being both dirty and having a flush operation
 *              that deletes the second to last entry on the LRU.  Then
 *              flush the cache, triggering the flush of the last
 *              item, and thereby the deletion of the second to last item.
 *
 *              H5C_flush_cache() should handle this deletion gracefully.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
cedds__expunge_dirty_entry_in_flush_test(H5F_t *file_ptr)
{
    struct expected_entry_status *expected  = NULL;
    H5C_t                        *cache_ptr = file_ptr->shared->cache;
    int                           i;

    expected = malloc(36 * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* the expected array is used to maintain a table of the expected status of every
         * entry used in this test.  Note that since the function that processes this
         * array only processes as much of it as it is told to, we don't have to
         * worry about maintaining the status of entries that we haven't used yet.
         */
        for (i = 0; i < 36; i++) {
            expected[i].entry_type   = HUGE_ENTRY_TYPE;
            expected[i].entry_index  = (int)i;
            expected[i].size         = HUGE_ENTRY_SIZE;
            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = true;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            for (size_t j = 0; j < MAX_FLUSH_DEP_PARS; j++) {
                expected[i].flush_dep_par_type[j] = -1;
                expected[i].flush_dep_par_idx[j]  = -1;
            }

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        pass = true;
    }

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = false;
            failure_mssg = "cache_ptr NULL on entry to cedds expunge dirty entry in flush test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = false;
            failure_mssg = "cache not empty on entry to cedds expunge dirty entry in flush test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of cedds expunge dirty entry in flush test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    if (pass) {

        /* The basic idea of this test is to setup the cache such
         * that:
         *
         * 1) the cache contains several dirty entries.
         *
         * 2) the first entry on the slist is dirty, and has a flush
         *    operation that will remove the second entry on the
         *    slist.
         *
         * Then load flush the cache.  Cache should handle the
         * removal of the next entry in the slist scan gracefully.
         */

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */
        H5C_stats__reset(cache_ptr);

        /* Load four huge entries into the cache.  Recall that huge entries
         * are one fourth the size of monster entries (16 KB vs. 64 KB).
         */
        for (i = 0; i < 4; i++) {

            protect_entry(file_ptr, HUGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != (4 * HUGE_ENTRY_SIZE))) {

            pass = false;

            failure_mssg = "unexpected size/len in cedds expunge dirty entry in flush test (1)";
        }
    }

    if (pass) {

        /* Next, set up the flush operation:
         *
         *     (HET, 0) expunges (HET, 1)
         *
         */
        add_flush_op(HUGE_ENTRY_TYPE, 0, FLUSH_OP__EXPUNGE, HUGE_ENTRY_TYPE, 1, false, (size_t)0, NULL);
    }

    if (pass) {

        /* to summarize, at present the following entries
         * are in cache with the following characteristics:
         *
         *         in
         * entry:  cache?   size:  dirty?  pinned?    pins:    flush operations:
         *
         * (HET, 0)    Y    16 KB    Y       N          -      expunge (HET 1)
         *
         * (HET, 1)    Y    16 KB    Y       N          -      -
         *
         * (HET, 2)    Y    16 KB    Y       N          -      -
         *
         * (HET, 3)    Y    16 KB    Y       N          -      -
         *
         * Recall that in this test bed, flush operations are executed the
         * first time the associated entry is flushed, and are then
         * deleted.
         */

        /* verify the expected status of all entries we have loaded to date: */
        verify_entry_status(cache_ptr, 0, 4, expected);
    }

    /* flush the cache to run the test.  In the process, clean up after test. */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush inval failed in cedds expunge dirty entry in flush test")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after cedds expunge dirty entry in flush test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     */
    if (pass)
        if ((cache_ptr->insertions[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[HUGE_ENTRY_TYPE] != 1) || (cache_ptr->flushes[HUGE_ENTRY_TYPE] != 3) ||
            (cache_ptr->evictions[HUGE_ENTRY_TYPE] != 4) ||
            (cache_ptr->take_ownerships[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->moves[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->pins[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->unpins[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->dirty_pins[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[HUGE_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected huge size entry stats in cedds__expunge_dirty_entry_in_flush_test().";
        } /* end if */

    if (pass)
        if ((cache_ptr->slist_scan_restarts != 1) || (cache_ptr->LRU_scan_restarts != 0) ||
            (cache_ptr->index_scan_restarts != 0)) {
            pass         = false;
            failure_mssg = "unexpected scan restart stats in cedds__expunge_dirty_entry_in_flush_test().";
        } /* end if */
#endif    /* H5C_COLLECT_CACHE_STATS */

    if (pass)
        reset_entries();

    if (pass)
        /* reset cache min clean size to its expected value */
        cache_ptr->min_clean_size = (1 * 1024 * 1024);

    free(expected);

} /* cedds__expunge_dirty_entry_in_flush_test() */

/*-------------------------------------------------------------------------
 * Function:    cedds__H5C_make_space_in_cache()
 *
 * Purpose:     Verify that H5C__make_space_in_cache() can handle the
 *              removal from the cache of the next item in its reverse scan
 *              of the LRU list.
 *
 *              Do this by setting up a full cache, with the last entry
 *              on the LRU being both dirty and having a flush operation
 *              that deleted the second to last entry on the LRU.  Then
 *              load an additional entry, triggering the flush of the last
 *              item, and thereby the deletion of the second to last item.
 *
 *              H5C__make_space_in_cache() should detect this deletion, and
 *              restart its scan of the LRU from the tail, instead of
 *              examining the now deleted next item up on the LRU.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
cedds__H5C_make_space_in_cache(H5F_t *file_ptr)
{
    struct expected_entry_status *expected  = NULL;
    H5C_t                        *cache_ptr = file_ptr->shared->cache;
    int                           i;
    const int                     num_huge_entries    = 4;
    const int                     num_monster_entries = 32;

    expected = malloc(36 * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* the expected array is used to maintain a table of the expected status of every
         * entry used in this test.  Note that since the function that processes this
         * array only processes as much of it as it is told to, we don't have to
         * worry about maintaining the status of entries that we haven't used yet.
         */
        for (i = 0; i < 36; i++) {
            if (i < num_huge_entries) {
                expected[i].entry_type  = HUGE_ENTRY_TYPE;
                expected[i].entry_index = (int)i;
                expected[i].size        = HUGE_ENTRY_SIZE;
            }
            else {
                expected[i].entry_type  = MONSTER_ENTRY_TYPE;
                expected[i].entry_index = (int)(i - num_huge_entries);
                expected[i].size        = MONSTER_ENTRY_SIZE;
            }

            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;
            expected[i].is_dirty     = true;
            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            for (size_t j = 0; j < MAX_FLUSH_DEP_PARS; j++) {
                expected[i].flush_dep_par_type[j] = -1;
                expected[i].flush_dep_par_idx[j]  = -1;
            }

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        pass = true;
    }

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = false;
            failure_mssg = "cache_ptr NULL on entry to cedds for H5C__make_space_in_cache() test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = false;
            failure_mssg = "cache not empty at start of flush ops eviction test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of cedds H5C__make_space_in_cache() test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    if (pass) {

        /* The basic idea of this test is to setup the cache such
         * that:
         *
         * 1) the cache is full
         *
         * 2) the last entry on the LRU is dirty, and has a flush
         *    operation that will remove the second to last entry
         *    on the LRU from the cache.
         *
         * Then load another entry into the cache.  See if
         * H5C__make_space_in_cache() detects the removal of
         * the next item in the scan, and restarts the scan
         * from the bottom of the LRU.  Note that the newly
         * loaded entry must be large enough to require that
         * the scan continue after the entry is expunged.
         */

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */
        H5C_stats__reset(cache_ptr);

        /* Load four huge entries into the cache.  Recall that huge entries
         * are one fourth the size of monster entries (16 KB vs. 64 KB).
         */
        for (i = 0; i < 4; i++) {

            protect_entry(file_ptr, HUGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != (4 * HUGE_ENTRY_SIZE))) {

            pass = false;

            failure_mssg = "unexpected size/len in H5C__make_space_in_cache() test (1)";
        }
    }

    if (pass) {

        /* Next, set up the flush operation:
         *
         *     (HET, 0) expunges (HET, 1)
         *
         */
        add_flush_op(HUGE_ENTRY_TYPE, 0, FLUSH_OP__EXPUNGE, HUGE_ENTRY_TYPE, 1, false, (size_t)0, NULL);
    }

    if (pass) {

        /* to summarize, at present the following entries
         * are in cache with the following characteristics:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (HET, 0)     Y    16 KB    Y    N    -    expunge (HET 1)
         *
         * (HET, 1)    Y    16 KB    N    N    -    -
         *
         * (HET, 2)    Y    16 KB    N    N    -    -
         *
         * (HET, 3)    Y    16 KB    N    N    -    -
         *
         * Recall that in this test bed, flush operations are executed the
         * first time the associated entry is flushed, and are then
         * deleted.
         */

        /* Now fill up the cache with other, unrelated entries.  Recall
         * that the cache size is 2 MB and 31 * 64 KB  + 4 * 16 KP == 2 MB.
         */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* The cache should now be exactly full */
        if ((cache_ptr->index_len != 35) || (cache_ptr->index_size != 2 * 1024 * 1024) ||
            (cache_ptr->index_size != ((4 * HUGE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE)))) {

            pass         = false;
            failure_mssg = "unexpected size/len in H5C__make_space_in_cache() test (2)";
        }
        else {

            /* verify the expected status of all entries we have loaded to date: */
            verify_entry_status(cache_ptr, 0, 35, expected);
        }
    }

    if (pass) {

        /* now load another monster entry.  This should cause
         * H5C__make_space_in_cache() to be called.  (HET 0) is dirty, and is at
         * the bottom of the LRU.  * Thus it will be flushed, and moved to the
         * head of the LRU.  However, during the flush, (HET 1) should be expunged
         * from the cache.  Since (MET 1) is the next item in
         * H5C__make_space_in_cache(), must detect its removal from the cache,
         * and refrain from trying to flush it.
         *
         * Since all entries in the cache are dirty, all entries will be flushed,
         * and HET 0, 2, and 3 will be evicted to make room for the new
         * monster entry (MET, 31).
         *
         * Verify this.  If H5C__make_space_in_cache() chokes, failure will
         * be detected in protect_entry().  Thus end the "if(pass)" clause
         * there so the error message will not be overwritten.
         */

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31);
    }

    if (pass) {

        /* if the protect succeeded, unprotect and verify that all is at
         * it should be.
         */

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31, H5C__DIRTIED_FLAG);

        /* The cache should now be exactly full */
        if ((cache_ptr->index_len != 32) || (cache_ptr->index_size != 2 * 1024 * 1024) ||
            (cache_ptr->index_size != (32 * MONSTER_ENTRY_SIZE))) {

            pass         = false;
            failure_mssg = "unexpected size/len in H5C__make_space_in_cache() test (3)";
        }
        else {

            /* modify the expected table to match the new situation, and
             * then call verify_entry_status().
             */
            for (i = 0; i < num_huge_entries; i++) {
                expected[i].in_cache   = false;
                expected[i].is_dirty   = false;
                expected[i].serialized = true;
                expected[i].destroyed  = true;
            }

            /* (HET, 1) was expunged, so touch its entry up accordingly */
            expected[1].is_dirty   = true;
            expected[1].serialized = false;

            for (i = num_huge_entries; i < num_huge_entries + num_monster_entries - 1; i++) {
                expected[i].is_dirty   = false;
                expected[i].serialized = true;
            }

            /* verify the expected status of all entries: */
            verify_entry_status(cache_ptr, 0, 36, expected);
        }
    }

    /* flush the cache and end the test. */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush invalidate failed after flush op eviction test")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after cleanup of flush op eviction test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     */

    if (pass) {

        if ((cache_ptr->insertions[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[HUGE_ENTRY_TYPE] != 1) || (cache_ptr->flushes[HUGE_ENTRY_TYPE] != 3) ||
            (cache_ptr->evictions[HUGE_ENTRY_TYPE] != 4) ||
            (cache_ptr->take_ownerships[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->moves[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->pins[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->unpins[HUGE_ENTRY_TYPE] != 0) || (cache_ptr->dirty_pins[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[HUGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[HUGE_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected large entry stats in cedds__H5C_make_space_in_cache().";
        }
    }

    if (pass)
        if ((cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry stats in cedds__H5C_make_space_in_cache().";
        } /* end if */

    if (pass)
        if ((cache_ptr->slist_scan_restarts != 0) || (cache_ptr->LRU_scan_restarts != 1) ||
            (cache_ptr->index_scan_restarts != 0)) {

            pass         = false;
            failure_mssg = "unexpected scan restart stats in cedds__H5C_make_space_in_cache().";
        } /* end if */

#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass)
        reset_entries();

    if (pass)
        /* reset cache min clean size to its expected value */
        cache_ptr->min_clean_size = (1 * 1024 * 1024);

    free(expected);

} /* cedds__H5C_make_space_in_cache() */

/*-------------------------------------------------------------------------
 * Function:    cedds__H5C__autoadjust__ageout__evict_aged_out_entries()
 *
 * Purpose:     Verify that H5C__autoadjust__ageout__evict_aged_out_entries()
 *              can handle the removal from the cache of the next item in
 *              its reverse scan of the LRU list.
 *
 *              Do this by setting up a full cache, with the last entry
 *              on the LRU being both dirty and having a flush operation
 *              that deletes the second to last entry on the LRU.  Then
 *              access the first item in the LRU repeatedly until the
 *              item, and thereby the deletion of the second to last item.
 *
 *              H5C__make_space_in_cache() should detect this deletion, and
 *              restart its scan of the LRU from the tail, instead of
 *              examining the now deleted next item up on the LRU.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
cedds__H5C__autoadjust__ageout__evict_aged_out_entries(H5F_t *file_ptr)
{
    struct expected_entry_status *expected  = NULL;
    H5C_t                        *cache_ptr = file_ptr->shared->cache;
    int                           i;
    herr_t                        result;
    H5C_auto_size_ctl_t           saved_auto_size_ctl;
    H5C_auto_size_ctl_t           test_auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* bool     set_initial_size       = */ true,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.5,

        /* size_t      max_size               = */ (8 * 1024 * 1024),
        /* size_t      min_size               = */ (1 * 1024 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75,

        /* double      increment              = */ 2.0,

        /* bool     apply_max_increment    = */ true,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0,
        /* double      flash_threshold        = */ 0.5,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__age_out,

        /* double      upper_hr_threshold     = */ 0.995,

        /* double      decrement              = */ 0.5,

        /* bool     apply_max_decrement    = */ false,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 1,

        /* bool     apply_empty_reserve    = */ true,
        /* double      empty_reserve          = */ 0.05};

    expected = malloc(36 * sizeof(struct expected_entry_status));
    if (expected == NULL) {

        pass         = false;
        failure_mssg = "couldn't allocate expected entry status array\n";
    }

    if (expected) {
        /* the expected array is used to maintain a table of the expected status of every
         * entry used in this test.  Note that since the function that processes this
         * array only processes as much of it as it is told to, we don't have to
         * worry about maintaining the status of entries that we haven't used yet.
         */
        for (i = 0; i < 36; i++) {
            expected[i].entry_type   = MONSTER_ENTRY_TYPE;
            expected[i].entry_index  = (int)i;
            expected[i].size         = MONSTER_ENTRY_SIZE;
            expected[i].in_cache     = true;
            expected[i].at_main_addr = true;

            /* NOTE: special case for first entry */
            expected[i].is_dirty = (i == 0);

            expected[i].is_protected = false;
            expected[i].is_pinned    = false;
            expected[i].deserialized = true;
            expected[i].serialized   = false;
            expected[i].destroyed    = false;

            for (size_t j = 0; j < MAX_FLUSH_DEP_PARS; j++) {
                expected[i].flush_dep_par_type[j] = -1;
                expected[i].flush_dep_par_idx[j]  = -1;
            }

            expected[i].flush_dep_npar       = 0;
            expected[i].flush_dep_nchd       = 0;
            expected[i].flush_dep_ndirty_chd = 0;
            expected[i].flush_order          = -1;
            expected[i].is_corked            = false;
        }

        pass = true;
    }

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = false;
            failure_mssg = "cache_ptr NULL on entry to cedds for "
                           "H5C__autoadjust__ageout__evict_aged_out_entries() test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            failure_mssg =
                "cache not empty at start cedds for H5C__autoadjust__ageout__evict_aged_out_entries() test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of cedds "
                           "H5C__autoadjust__ageout__evict_aged_out_entries() test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    /* save the initial resize configuration so we can restore it later */
    if (pass) {

        saved_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;

        result = H5C_get_cache_auto_resize_config(cache_ptr, &saved_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_get_cache_auto_resize_config failed.";
        }
    }

    /* set the resize configuration we will be using in the test */
    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        /* The basic idea of this test is to setup the cache such
         * that:
         *
         * 1) the cache is full
         *
         * 2) the last entry on the LRU is dirty, and has a flush
         *    operation that will remove the second to last entry
         *    on the LRU from the cache.
         *
         * Then access the first item in the LRU until the epoch
         * and H5C__autoadjust__ageout__evict_aged_out_entries()
         * is invoked.  Verify that the function deals with the
         * deletion of the next item in its scan cleanly.
         */

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */
        H5C_stats__reset(cache_ptr);

        /* load the first entry -- mark it dirty */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__DIRTIED_FLAG);

        /* Then load the rest of the entries to fill the cache:
         *
         * Recall that the cache size is 2 MB and 32 * 64 KB == 2 MB.
         */
        for (i = 1; i < 32; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        }
    }

    if (pass) {

        /* Next, set up the flush operation:
         *
         *     (MET, 0) expunges (MET, 1)
         *
         */
        add_flush_op(MONSTER_ENTRY_TYPE, 0, FLUSH_OP__EXPUNGE, MONSTER_ENTRY_TYPE, 1, false, (size_t)0, NULL);
    }

    if (pass) {

        /* to summarize, at present the following entries
         * are in cache with the following characteristics:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (MET, 0)     Y    64 KB    Y    N    -    expunge (MET 1)
         *
         * (MET, 1-31)    Y    64 KB    N    N    -    -
         *
         * Recall that in this test bed, flush operations are executed the
         * first time the associated entry is flushed, and are then
         * deleted.
         */

        /* The cache should now be exactly full */
        if ((cache_ptr->index_len != 32) || (cache_ptr->index_size != 2 * 1024 * 1024) ||
            (cache_ptr->index_size != (32 * MONSTER_ENTRY_SIZE))) {

            pass = false;
            failure_mssg =
                "unexpected size/len in H5C__autoadjust__ageout__evict_aged_out_entries() test (1)";
        }
        else {

            /* verify the expected status of all entries we have loaded to date: */
            verify_entry_status(cache_ptr, 0, 32, expected);
        }
    }

    /* protect and unprotect (MET, 31) repeatedly until the end of the first epoch */
    while (pass && (cache_ptr->cache_accesses > 0)) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31, H5C__NO_FLAGS_SET);
    }

    /* at this point, an epoch marker entry should have been inserted into the LRU */

    if (pass) {

        /* protect and unprotect (MET, 31) again to get cache_accesses > 0 */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31, H5C__NO_FLAGS_SET);
    }

    /* protect and unprotect (MET, 31) repeatedly until the end of the second epoch */
    while (pass && (cache_ptr->cache_accesses > 0)) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31, H5C__NO_FLAGS_SET);
    }

    /* at this point, only (MET, 0) and (MET, 31) should remain in the cache,
     * all other entries having been evicted by the ageout adaptive cache
     * resizing algorithm. (Since (MET, 0) was dirty, it was flushed and
     * moved to the head of the LRU by the ageout algorithm.)
     */

    if (pass) {

        if ((cache_ptr->index_len != 2) || (cache_ptr->index_size != 2 * MONSTER_ENTRY_SIZE)) {

            pass = false;
            failure_mssg =
                "unexpected size/len in H5C__autoadjust__ageout__evict_aged_out_entries() test (2)";
        }
        else {

            /* update the expected table to reflect the expected values at
             * this point, and then verify.
             */

            expected[0].is_dirty   = false;
            expected[0].serialized = true;

            for (i = 1; i < 31; i++) {
                expected[i].in_cache  = false;
                expected[i].is_dirty  = false;
                expected[i].destroyed = true;
            }

            verify_entry_status(cache_ptr, 0, 32, expected);
        }
    }

    /* restore the initial resize configuration */
    if (pass) {

        saved_auto_size_ctl.set_initial_size = true;
        saved_auto_size_ctl.initial_size     = 2 * 1024 * 1024;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &saved_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = false;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    /* flush the cache and end the test. */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush invalidate failed after flush op eviction test")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after cleanup of flush op eviction test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     */

    if (pass)
        if ((cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass = false;
            failure_mssg =
                "Unexpected monster entry stats in cedds__H5C__autoadjust__ageout__evict_aged_out_entries().";
        } /* end if */

    if (pass)
        if ((cache_ptr->slist_scan_restarts != 0) || (cache_ptr->LRU_scan_restarts != 1) ||
            (cache_ptr->index_scan_restarts != 0)) {

            pass = false;
            failure_mssg =
                "unexpected scan restart stats in cedds__H5C__autoadjust__ageout__evict_aged_out_entries().";
        } /* end if */

#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass)
        reset_entries();

    if (pass)
        /* reset cache min clean size to its expected value */
        cache_ptr->min_clean_size = (1 * 1024 * 1024);

    free(expected);

} /* cedds__H5C__autoadjust__ageout__evict_aged_out_entries() */

/*-------------------------------------------------------------------------
 * Function:    cedds__H5C_flush_invalidate_cache__bucket_scan()
 *
 * Purpose:     Note:      We now use the index list when we scan the
 *              contents of the metadata cache, so in principal,
 *              this test is obsolete.  However, even using the
 *              index list, restarts are possible, and must be
 *              handled gracefully.
 *
 *              As it turns out, this test triggers index list
 *              scan restarts, and thus with minor changes is
 *              still a useful test.
 *
 *              For this reason, with the exception of changing
 *              to check the index_scan_restart stat instead of
 *              hash bucket restarts, I'm leaving the test
 *              alone.  If and when it starts to fail due to
 *              other changes, we can re-work it to test
 *              index list scan restarts explicitly.
 *
 *                                        JRM -- 11/2/16
 *
 *              Verify that H5C_flush_invalidate_cache() can handle
 *              the removal from the cache of the next item in
 *              its scans of hash buckets.
 *
 *              !!!!!!!!!!WARNING !!!!!!!!!!
 *
 *              This test may fail to function correctly if the hash
 *              table size or hash function is altered.
 *
 *              To setup the test, this function depends on the fact that
 *              H5C_flush_invalidate_cache() does alternating scans of the
 *              slist and the index.  If this changes, the test will likely
 *              also cease to function correctly.
 *
 *              The test relies on a known hash function and hash table
 *              size to select a set of test entries that will all hash
 *              to the same hash bucket -- call it the test hash bucket.
 *              It also relies on known behavior of the cache to place
 *              the entries in the test bucket in a known order.
 *
 *              To avoid pre-mature flushes of the entries in the
 *              test hash bucket, all entries are initially clean,
 *              with the exception of the first entry which is dirty.
 *              It avoids premature flushing by being the parent in
 *              a flush dependency.  The first entry in the test bucket
 *              also has a flush op which expunges the second entry --
 *              setting up the failure.
 *
 *              An additional dirty entry is added (which must hash
 *              to a different bucket, and must have a higher address
 *              than at least the first entry in the test hash bucket.
 *              This entry is the child in a flush dependency with the
 *              first entry in the above hash bucket, and contains
 *              a flush op to destroy this flush dependency.
 *
 *              Since the first entry in the test hash bucket has a lower
 *              address that the other dirty entry, the scan of the
 *              slist encounters it first, and passes over it because
 *              it has a flush dependency height of 1.
 *
 *              The scan then encounters the second dirty entry and flushes
 *              it -- causing it to destroy the flush dependency and thus
 *              reducing the flush dependency height of the first entry in
 *              the test hash bucket to zero.
 *
 *              After completing a scan of the slist,
 *              H5C_flush_invalidate_cache() then scans the index,
 *              flushing all entries of flush dependency height zero.
 *
 *              This sets up the potential error when the first entry
 *              in the test hash bucket is flushed -- expunging the
 *              second entry as a side effect.  If
 *              H5C_flush_invalidate_cache() fails to detect this,
 *              it will attempt to continue its scan of the bucket with
 *              an entry that has been deleted from the cache.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */

static void
cedds__H5C_flush_invalidate_cache__bucket_scan(H5F_t *file_ptr)
{
    H5C_t                    *cache_ptr = file_ptr->shared->cache;
    int                       i;
    int                       expected_hash_bucket = 0;
    haddr_t                   entry_addr;
    test_entry_t             *entry_ptr;
    test_entry_t             *base_addr = NULL;
    struct H5C_cache_entry_t *scan_ptr;
    /* clang-format off */
    struct expected_entry_status expected[5] =
    {
      /* the expected array is used to maintain a table of the expected status of every
       * entry used in this test.  Note that since the function that processes this
       * array only processes as much of it as it is told to, we don't have to
       * worry about maintaining the status of entries that we haven't used yet.
       */
      /* entry            entry                in    at main                                                  flush dep flush dep child flush   flush       flush */
      /* type:            index:    size:            cache:    addr:    dirty:    prot:    pinned:    dsrlzd:    srlzd:    dest:     par type[]: par idx[]: dep npart: dep nchd: dep ndirty chd: order:     corked: */
      { MONSTER_ENTRY_TYPE,     0,    MONSTER_ENTRY_SIZE,    true,    true,    true,    false,    true,    true,    false,    false,      {-1,0,0,0,0,0,0,0},                 {-1,0,0,0,0,0,0,0}, 0, 1, 1, -1, false},
      { MONSTER_ENTRY_TYPE,     8,    MONSTER_ENTRY_SIZE,    true,    true,    false,    false,    false,    true,    false,    false,      {-1,0,0,0,0,0,0,0},                 {-1,0,0,0,0,0,0,0}, 0, 0, 0, -1, false},
      { MONSTER_ENTRY_TYPE,     16,    MONSTER_ENTRY_SIZE,    true,    true,    false,    false,    false,    true,    false,    false,      {-1,0,0,0,0,0,0,0},                 {-1,0,0,0,0,0,0,0}, 0, 0, 0, -1, false},
      { MONSTER_ENTRY_TYPE,     24,    MONSTER_ENTRY_SIZE,    true,    true,    false,    false,    false,    true,    false,    false,      {-1,0,0,0,0,0,0,0},                 {-1,0,0,0,0,0,0,0}, 0, 0, 0, -1, false},
      { MONSTER_ENTRY_TYPE,     31,    MONSTER_ENTRY_SIZE,    true,    true,    true,    false,    false,    true,    false,    false,         {MONSTER_ENTRY_TYPE,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0},  1, 0, 0, -1, false},
    };
    /* clang-format on */

    if (pass) {

        if (cache_ptr == NULL) {

            pass = false;
            failure_mssg =
                "cache_ptr NULL on entry to cedds for cedds__H5C_flush_invalidate_cache__bucket_scan() test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = false;
            failure_mssg =
                "cache not empty at start cedds for cedds__H5C_flush_invalidate_cache__bucket_scan() test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of cedds "
                           "cedds__H5C_flush_invalidate_cache__bucket_scan() test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    if (pass) {

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */

        H5C_stats__reset(cache_ptr);

        /* load one dirty and three clean entries that should hash to the
         * same hash bucket.
         */

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__DIRTIED_FLAG);

        for (i = 8; i <= 24; i += 8) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        }
    }

    if (pass) {

        /* verify that the above entries hash to the same bucket */
        base_addr  = entries[MONSTER_ENTRY_TYPE];
        entry_ptr  = &(base_addr[0]);
        entry_addr = entry_ptr->header.addr;

        assert(entry_addr == entry_ptr->addr);

        expected_hash_bucket = H5C__HASH_FCN(entry_addr);

        for (i = 8; i <= 24; i += 8) {

            entry_ptr  = &(base_addr[i]);
            entry_addr = entry_ptr->header.addr;

            if (expected_hash_bucket != H5C__HASH_FCN(entry_addr)) {

                pass         = false;
                failure_mssg = "Test entries don't map to same bucket -- hash table size or hash fcn change?";
            }
        }
    }

    if (pass) {

        /* setup the expunge flush operation:
         *
         *     (MET, 0) expunges (MET, 8)
         *
         */
        add_flush_op(MONSTER_ENTRY_TYPE, 0, FLUSH_OP__EXPUNGE, MONSTER_ENTRY_TYPE, 8, false, (size_t)0, NULL);
    }

    if (pass) {

        /* load the entry that will have a flush dependency with (MET, 0),
         * thus preventing it from being flushed on the first pass through
         * the skip list.
         */

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 31, H5C__DIRTIED_FLAG);
    }

    if (pass) {

        /* verify that the dirty entry doesn't map to the same
         * hash bucket as the clean entries.
         */

        entry_ptr  = &(base_addr[31]);
        entry_addr = entry_ptr->header.addr;

        if (expected_hash_bucket == H5C__HASH_FCN(entry_addr)) {

            pass         = false;
            failure_mssg = "Dirty entry maps to same hash bucket as clean entries?!?!";
        }
    }

    if (pass) {

        /* Next, create the flush dependency requiring (MET, 31) to
         * be flushed prior to (MET, 0).
         */

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
        create_flush_dependency(MONSTER_ENTRY_TYPE, 0, MONSTER_ENTRY_TYPE, 31);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__DIRTIED_FLAG);
    }

    if (pass) {

        /* Then, setup the flush operation to take down the flush
         * dependency when (MET, 31) is flushed.
         *
         *     (MET, 31) destroys flush dependency with (MET, 8)
         *
         */
        add_flush_op(MONSTER_ENTRY_TYPE, 31, FLUSH_OP__DEST_FLUSH_DEP, MONSTER_ENTRY_TYPE, 0, false,
                     (size_t)0, NULL);
    }

    if (pass) {

        /* verify the expected status of all entries we have loaded to date: */
        verify_entry_status(cache_ptr, 0, 5, expected);
    }

    if (pass) {

        /* now do some protect / unprotect cycles to force the
         * entries into the desired order in the hash bucket.
         * Recall that entries are moved to the head of the
         * hash bucket list on lookup.
         */

        for (i = 24; i >= 0; i -= 8) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        }
    }

    if (pass) {

        /* scan the hash bucket to verify that the expected entries appear
         * in the expected order.
         */
        scan_ptr = cache_ptr->index[expected_hash_bucket];

        i = 0;

        while (pass && (i <= 24)) {
            entry_ptr = &(base_addr[i]);

            if (scan_ptr == NULL) {

                pass         = false;
                failure_mssg = "premature end of hash bucket list?!?!";
            }
            else if ((scan_ptr == NULL) || (scan_ptr != &(entry_ptr->header))) {

                pass         = false;
                failure_mssg = "bad test hash bucket setup?!?!";
            }

            if (pass) {

                scan_ptr = scan_ptr->ht_next;
                i += 8;
            }
        }
    }

    /* test setup complete -- flush the cache to run and end the test. */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush invalidate failed after flush op eviction test")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after cleanup of flush op eviction test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     */

    if (pass)
        if ((cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 2) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 5) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 1) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass = false;
            failure_mssg =
                "Unexpected monster entry stats in cedds__H5C_flush_invalidate_cache__bucket_scan().";
        } /* end if */

    if (pass)
        /* as this test is now checking for index list scan restarts,
         * the following has been modified to check this instead of
         * hash bucket scan restarts.
         */
        if ((cache_ptr->slist_scan_restarts != 0) || (cache_ptr->LRU_scan_restarts != 0) ||
            (cache_ptr->index_scan_restarts != 1)) {
            pass = false;
            failure_mssg =
                "unexpected scan restart stats in cedds__H5C_flush_invalidate_cache__bucket_scan().";
        }

#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass)
        reset_entries();

    if (pass)
        /* reset cache min clean size to its expected value */
        cache_ptr->min_clean_size = (1 * 1024 * 1024);

} /* cedds__H5C_flush_invalidate_cache__bucket_scan() */

/*-------------------------------------------------------------------------
 * Function:    check_stats()
 *
 * Purpose:    If stats are enabled, conduct tests to verify correct
 *        functioning of the cache statistics collection code.
 *
 *        Skip the test if stats are not enabled.
 *
 *        At present this test is a shell -- fill it out at time
 *        permits.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_stats(unsigned paged)
{

#if H5C_COLLECT_CACHE_STATS

    H5F_t *file_ptr = NULL;

#endif /* H5C_COLLECT_CACHE_STATS */

    if (paged)
        TESTING("metadata cache statistics collection (paged aggregation)");
    else
        TESTING("metadata cache statistics collection");

#if H5C_COLLECT_CACHE_STATS

    pass = true;

    reset_entries();

    file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024), paged);

    if (pass) {

        check_stats__smoke_check_1(file_ptr);
    }

    if (pass) {

        takedown_cache(file_ptr, false, false);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        fprintf(stdout, "%s(): failure_mssg = \"%s\".\n", __func__, failure_mssg);
    }

#else /* H5C_COLLECT_CACHE_STATS */

    SKIPPED();

    fprintf(stdout, "    Statistics collection disabled.\n");

#endif /* H5C_COLLECT_CACHE_STATS */

    return (unsigned)!pass;

} /* check_stats() */

/*-------------------------------------------------------------------------
 * Function:    check_stats__smoke_check_1()
 *
 * Purpose:     Test to see if the statistics collection code is working
 *              more or less as expected.  Do this by performing a number
 *              of operations in the cache, and checking to verify that
 *              they result in the expected statistics.
 *
 *              Note that this function is not intended to be a full test
 *              of the statistics collection facility -- only a cursory
 *              check that will serve as a place holder until more complete
 *              tests are implemented.
 *
 *              Do nothing if pass is false on entry.
 *
 * Return:      void
 *
 *-------------------------------------------------------------------------
 */
#if H5C_COLLECT_CACHE_STATS
static void
check_stats__smoke_check_1(H5F_t *file_ptr)
{
    H5C_t *cache_ptr = file_ptr->shared->cache;
    int    i;

    if (pass) {
        if (cache_ptr == NULL) {

            pass         = false;
            failure_mssg = "cache_ptr NULL on entry to check_stats__smoke_check_1().";
        } /* end if */
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = false;
            failure_mssg = "cache not empty on entry to check_stats__smoke_check_1().";
        } /* end else-if */
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = false;
            failure_mssg = "unexpected cache config at start of check_stats__smoke_check_1().";

        } /* end else-if */
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */
            cache_ptr->min_clean_size = 0;
        } /* end else */
    }     /* end if */

    if (pass)
        /* first fill the cache with monster entryies via insertion */
        for (i = 0; i < 32; i++)
            insert_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);

    if (pass)
        if ((cache_ptr->hits[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->misses[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->write_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster size entry stats in check_stats__smoke_check_1(1).";
        } /* end if */

    if (pass) {

        if ((cache_ptr->total_ht_insertions != 32) || (cache_ptr->total_ht_deletions != 0) ||
            (cache_ptr->successful_ht_searches != 0) || (cache_ptr->total_successful_ht_search_depth != 0) ||
            (cache_ptr->failed_ht_searches != 32) || (cache_ptr->total_failed_ht_search_depth != 48) ||
            (cache_ptr->max_index_len != 32) || (cache_ptr->max_index_size != 2 * 1024 * 1024) ||
            (cache_ptr->max_clean_index_size != 0) || (cache_ptr->max_dirty_index_size != 2 * 1024 * 1024) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->max_slist_len != 32) || (cache_ptr->max_slist_size != 2 * 1024 * 1024))) ||
            (cache_ptr->max_pl_len != 0) || (cache_ptr->max_pl_size != 0) || (cache_ptr->max_pel_len != 0) ||
            (cache_ptr->max_pel_size != 0) || (cache_ptr->calls_to_msic != 0) ||
            (cache_ptr->total_entries_skipped_in_msic != 0) ||
            (cache_ptr->total_entries_scanned_in_msic != 0) ||
            (cache_ptr->max_entries_skipped_in_msic != 0) || (cache_ptr->max_entries_scanned_in_msic != 0) ||
            (cache_ptr->entries_scanned_to_make_space != 0) || (cache_ptr->slist_scan_restarts != 0) ||
            (cache_ptr->LRU_scan_restarts != 0) || (cache_ptr->index_scan_restarts != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache stats in check_stats__smoke_check_1(1).";
        } /* end if */
    }

#if H5C_COLLECT_CACHE_ENTRY_STATS
    if (pass)
        /* Note that most entry level stats are only updated on entry eviction */
        if ((cache_ptr->max_accesses[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->min_accesses[MONSTER_ENTRY_TYPE] != 1000000) || /* initial value */
            (cache_ptr->max_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_size[MONSTER_ENTRY_TYPE] != 64 * 1024) ||
            (cache_ptr->max_pins[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry level stats in check_stats__smoke_check_1(1).";
        } /* end if */
#endif    /* H5C_COLLECT_CACHE_ENTRY_STATS */

    if (pass)
        /* protect and unprotect each entry once. Note
         * that all entries are already dirty, as they
         * entered the cache via insertion
         */
        for (i = 0; i < 32; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        } /* end for */

    if (pass)
        if ((cache_ptr->hits[MONSTER_ENTRY_TYPE] != 32) || (cache_ptr->misses[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->write_protects[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster size entry stats in check_stats__smoke_check_1(2).";
        } /* end if */

    if (pass) {

        if ((cache_ptr->total_ht_insertions != 32) || (cache_ptr->total_ht_deletions != 0) ||
            (cache_ptr->successful_ht_searches != 32) ||
            (cache_ptr->total_successful_ht_search_depth != 96) || (cache_ptr->failed_ht_searches != 32) ||
            (cache_ptr->total_failed_ht_search_depth != 48) || (cache_ptr->max_index_len != 32) ||
            (cache_ptr->max_index_size != 2 * 1024 * 1024) || (cache_ptr->max_clean_index_size != 0) ||
            (cache_ptr->max_dirty_index_size != 2 * 1024 * 1024) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->max_slist_len != 32) || (cache_ptr->max_slist_size != 2 * 1024 * 1024))) ||
            (cache_ptr->max_pl_len != 1) || (cache_ptr->max_pl_size != 64 * 1024) ||
            (cache_ptr->max_pel_len != 0) || (cache_ptr->max_pel_size != 0) ||
            (cache_ptr->calls_to_msic != 0) || (cache_ptr->total_entries_skipped_in_msic != 0) ||
            (cache_ptr->total_entries_scanned_in_msic != 0) ||
            (cache_ptr->max_entries_skipped_in_msic != 0) || (cache_ptr->max_entries_scanned_in_msic != 0) ||
            (cache_ptr->entries_scanned_to_make_space != 0) || (cache_ptr->slist_scan_restarts != 0) ||
            (cache_ptr->LRU_scan_restarts != 0) || (cache_ptr->index_scan_restarts != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache stats in check_stats__smoke_check_1(2).";
        } /* end if */
    }

#if H5C_COLLECT_CACHE_ENTRY_STATS
    if (pass)
        /* Note that most entry level stats are only updated on entry eviction */
        if ((cache_ptr->max_accesses[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->min_accesses[MONSTER_ENTRY_TYPE] != 1000000) || /* initial value */
            (cache_ptr->max_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_size[MONSTER_ENTRY_TYPE] != 64 * 1024) ||
            (cache_ptr->max_pins[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry level stats in check_stats__smoke_check_1(2).";
        } /* end if */
#endif    /* H5C_COLLECT_CACHE_ENTRY_STATS */

    if (pass) {
        /* protect and unprotect an entry that is not currently
         * in the cache.  Since the cache is full and all entries
         * are dirty, this will force a flush of each entry, and
         * the eviction of (MET, 0).
         */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 32);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 32, H5C__DIRTIED_FLAG);
    } /* end if */

    if (pass)
        if ((cache_ptr->hits[MONSTER_ENTRY_TYPE] != 32) || (cache_ptr->misses[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->write_protects[MONSTER_ENTRY_TYPE] != 33) ||
            (cache_ptr->read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster size entry stats in check_stats__smoke_check_1(3).";
        } /* end if */

    if (pass) {

        if ((cache_ptr->total_ht_insertions != 33) || (cache_ptr->total_ht_deletions != 1) ||
            (cache_ptr->successful_ht_searches != 32) ||
            (cache_ptr->total_successful_ht_search_depth != 96) || (cache_ptr->failed_ht_searches != 33) ||
            (cache_ptr->total_failed_ht_search_depth != 52) || (cache_ptr->max_index_len != 32) ||
            (cache_ptr->max_index_size != 2 * 1024 * 1024) ||
            (cache_ptr->max_clean_index_size != 2 * 1024 * 1024) ||
            (cache_ptr->max_dirty_index_size != 2 * 1024 * 1024) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->max_slist_len != 32) || (cache_ptr->max_slist_size != 2 * 1024 * 1024))) ||
            (cache_ptr->max_pl_len != 1) || (cache_ptr->max_pl_size != 64 * 1024) ||
            (cache_ptr->max_pel_len != 0) || (cache_ptr->max_pel_size != 0) ||
            (cache_ptr->calls_to_msic != 1) || (cache_ptr->total_entries_skipped_in_msic != 0) ||
            (cache_ptr->total_entries_scanned_in_msic != 33) ||
            (cache_ptr->max_entries_skipped_in_msic != 0) || (cache_ptr->max_entries_scanned_in_msic != 33) ||
            (cache_ptr->entries_scanned_to_make_space != 33) || (cache_ptr->slist_scan_restarts != 0) ||
            (cache_ptr->LRU_scan_restarts != 0) || (cache_ptr->index_scan_restarts != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache stats in check_stats__smoke_check_1(3).";
        } /* end if */
    }

#if H5C_COLLECT_CACHE_ENTRY_STATS
    if (pass)
        /* Note that most entry level stats are only updated on entry eviction */
        if ((cache_ptr->max_accesses[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->min_accesses[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->max_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_flushes[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->max_size[MONSTER_ENTRY_TYPE] != 64 * 1024) ||
            (cache_ptr->max_pins[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry level stats in check_stats__smoke_check_1(3).";
        } /* end if */

#endif /* H5C_COLLECT_CACHE_ENTRY_STATS */

    if (pass) {
        /* protect and unprotect dirty (MET, 1), and then flush destroy
         * the cache.
         */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);
    } /* end if */

    /* flush the cache to end the test and collect all entry stats */

    if (pass) {

        H5C_FLUSH_CACHE(file_ptr, H5C__FLUSH_INVALIDATE_FLAG,
                        "Cache flush invalidate failed in check_stats__smoke_check_1()")

        if ((pass) && ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0))) {

            pass         = false;
            failure_mssg = "Unexpected cache len/size after check_stats__smoke_check_1()";

        } /* end else-if */
    }     /* end if */

    if (pass)
        if ((cache_ptr->hits[MONSTER_ENTRY_TYPE] != 33) || (cache_ptr->misses[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->write_protects[MONSTER_ENTRY_TYPE] != 34) ||
            (cache_ptr->read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_read_protects[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 32) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 34) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 33) ||
            (cache_ptr->take_ownerships[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster size entry stats in check_stats__smoke_check_1(4).";
        } /* end if */

    if (pass) {

        if ((cache_ptr->total_ht_insertions != 33) || (cache_ptr->total_ht_deletions != 33) ||
            (cache_ptr->successful_ht_searches != 33) ||
            (cache_ptr->total_successful_ht_search_depth != 99) || (cache_ptr->failed_ht_searches != 33) ||
            (cache_ptr->total_failed_ht_search_depth != 52) || (cache_ptr->max_index_len != 32) ||
            (cache_ptr->max_index_size != 2 * 1024 * 1024) ||
            (cache_ptr->max_clean_index_size != 2 * 1024 * 1024) ||
            (cache_ptr->max_dirty_index_size != 2 * 1024 * 1024) ||
            ((cache_ptr->slist_enabled) &&
             ((cache_ptr->max_slist_len != 32) || (cache_ptr->max_slist_size != 2 * 1024 * 1024))) ||
            (cache_ptr->max_pl_len != 1) || (cache_ptr->max_pl_size != 64 * 1024) ||
            (cache_ptr->max_pel_len != 0) || (cache_ptr->max_pel_size != 0) ||
            (cache_ptr->calls_to_msic != 1) || (cache_ptr->total_entries_skipped_in_msic != 0) ||
            (cache_ptr->total_entries_scanned_in_msic != 33) ||
            (cache_ptr->max_entries_skipped_in_msic != 0) || (cache_ptr->max_entries_scanned_in_msic != 33) ||
            (cache_ptr->entries_scanned_to_make_space != 33) || (cache_ptr->slist_scan_restarts != 0) ||
            (cache_ptr->LRU_scan_restarts != 0) || (cache_ptr->index_scan_restarts != 0)) {

            pass         = false;
            failure_mssg = "Unexpected cache stats in check_stats__smoke_check_1(4).";
        } /* end if */
    }

#if H5C_COLLECT_CACHE_ENTRY_STATS
    if (pass)
        /* Note that most entry level stats are only updated on entry eviction */
        if ((cache_ptr->max_accesses[MONSTER_ENTRY_TYPE] != 2) ||
            (cache_ptr->min_accesses[MONSTER_ENTRY_TYPE] != 1) ||
            (cache_ptr->max_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->max_flushes[MONSTER_ENTRY_TYPE] != 2) ||
            (cache_ptr->max_size[MONSTER_ENTRY_TYPE] != 64 * 1024) ||
            (cache_ptr->max_pins[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = false;
            failure_mssg = "Unexpected monster entry level stats in check_stats__smoke_check_1(4).";
        } /* end if */

#endif /* H5C_COLLECT_CACHE_ENTRY_STATS */

    if (pass)
        reset_entries();

    if (pass)
        /* reset cache min clean size to its expected value */
        cache_ptr->min_clean_size = (1 * 1024 * 1024);

} /* check_stats__smoke_check_1() */

#endif /* H5C_COLLECT_CACHE_STATS */

/* Call back functions: */

/*-------------------------------------------------------------------------
 *
 * Function:    check_if_write_permitted
 *
 * Purpose:     Determine if a write is permitted under the current
 *              circumstances, and set *write_permitted_ptr accordingly.
 *              As a general rule it is, but when we are running in parallel
 *              mode with collective I/O, we must ensure that a read cannot
 *              cause a write.
 *
 *              In the event of failure, the value of *write_permitted_ptr
 *              is undefined.
 *
 * Return:      Non-negative on success/Negative on failure.
 *
 *-------------------------------------------------------------------------
 */
static herr_t
check_write_permitted(const H5F_t H5_ATTR_UNUSED *f, bool *write_permitted_ptr)
{
    assert(write_permitted_ptr);

    *write_permitted_ptr = write_permitted;

    return (SUCCEED);
} /* check_write_permitted() */

/*****************************************************************************
 *
 * Function:    setup_cache()
 *
 * Purpose:     Open an HDF file.  This will allocate an instance and
 *         initialize an associated instance of H5C_t.  However,
 *         we want to test an instance of H5C_t, so allocate and
 *         initialize one with the file ID returned by the call to
 *         H5Fcreate().  Return a pointer to this instance of H5C_t.
 *
 *        Observe that we open a HDF file because the cache now
 *        writes directly to file, and we need the file I/O facilities
 *        associated with the file.
 *
 *        To avoid tripping on error check code, must allocate enough
 *        space in the file to hold all the test entries and their
 *        alternates.  This is a little sticky, as the addresses of
 *        all the test entries are determined at compile time.
 *
 *        Deal with this by choosing BASE_ADDR large enough that
 *        the base address of the allocate space will be less than
 *        or equal to BASE_ADDR, and then requesting an extra BASE_ADDR
 *        bytes, so we don't have to wory about exceeding the allocation.
 *
 * Return:      Success:        Ptr to H5C_t
 *
 *              Failure:        NULL
 *
 *****************************************************************************/

H5F_t *
setup_cache(size_t max_cache_size, size_t min_clean_size, unsigned paged)
{
    char    filename[512];
    bool    show_progress = false;
    bool    verbose       = true;
    int     mile_stone    = 1;
    hid_t   fid           = H5I_INVALID_HID;
    H5F_t  *file_ptr      = NULL;
    H5C_t  *cache_ptr     = NULL;
    H5F_t  *ret_val       = NULL;
    haddr_t actual_base_addr;
    hid_t   fapl_id = H5P_DEFAULT;
    hid_t   fcpl_id = H5P_DEFAULT;

    if (show_progress) /* 1 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    saved_fid = -1;

    if (pass) {
        if ((fcpl_id = H5Pcreate(H5P_FILE_CREATE)) == FAIL) {
            pass         = false;
            failure_mssg = "H5Pcreate(H5P_FILE_CREATE) failed.\n";
        }
    }

    if (pass && paged) {
        /* Set up paged aggregation strategy */
        if (H5Pset_file_space_strategy(fcpl_id, H5F_FSPACE_STRATEGY_PAGE, 1, (hsize_t)1) == FAIL) {
            pass         = false;
            failure_mssg = "H5Pset_file_space_strategy() failed.\n";
            H5Pclose(fcpl_id);
            fcpl_id = H5P_DEFAULT;
        }
    }

    if (pass && paged) {
        /* Set up file space page size to BASE_ADDR */
        if (H5Pset_file_space_page_size(fcpl_id, (hsize_t)BASE_ADDR) == FAIL) {
            pass         = false;
            failure_mssg = "H5Pset_file_space_page_size() failed.\n";
            H5Pclose(fcpl_id);
            fcpl_id = H5P_DEFAULT;
        }
    }

    if (pass)
        saved_fcpl_id = fcpl_id;

    /* setup the file name */
    if (pass) {
        if (NULL == h5_fixname(FILENAME[0], H5P_DEFAULT, filename, sizeof(filename))) {
            pass         = false;
            failure_mssg = "h5_fixname() failed.\n";
        }
    }

    if (show_progress) /* 2 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass && try_core_file_driver) {
        if ((fapl_id = H5Pcreate(H5P_FILE_ACCESS)) == FAIL) {
            pass         = false;
            failure_mssg = "H5Pcreate(H5P_FILE_ACCESS) failed.\n";
        }
        else if (H5Pset_fapl_core(fapl_id, MAX_ADDR, false) < 0) {
            H5Pclose(fapl_id);
            fapl_id      = H5P_DEFAULT;
            pass         = false;
            failure_mssg = "H5P_set_fapl_core() failed.\n";
        }
        else if ((fid = H5Fcreate(filename, H5F_ACC_TRUNC, fcpl_id, fapl_id)) < 0) {
            core_file_driver_failed = true;

            if (verbose)
                fprintf(stdout, "%s: H5Fcreate() with CFD failed.\n", __func__);
        }
        else {
            saved_fapl_id = fapl_id;
        }
    }

    if (show_progress) /* 3 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    /* if we either aren't using the core file driver, or a create
     * with the core file driver failed, try again with a regular file.
     * If this fails, we are cooked.
     */
    if (pass && fid < 0) {
        fid       = H5Fcreate(filename, H5F_ACC_TRUNC, fcpl_id, fapl_id);
        saved_fid = fid;

        if (fid < 0) {
            pass         = false;
            failure_mssg = "H5Fcreate() failed.";

            if (verbose)
                fprintf(stdout, "%s: H5Fcreate() failed.\n", __func__);
        } /* end if */
    }     /* end if */

    /* Push API context */
    H5CX_push();

    if (show_progress) /* 4 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {
        assert(fid >= 0);
        saved_fid = fid;
        if (H5Fflush(fid, H5F_SCOPE_GLOBAL) < 0) {
            pass         = false;
            failure_mssg = "H5Fflush() failed.";

            if (verbose)
                fprintf(stdout, "%s: H5Fflush() failed.\n", __func__);
        }
        else {
            file_ptr = (H5F_t *)H5VL_object_verify(fid, H5I_FILE);
            if (file_ptr == NULL) {
                pass         = false;
                failure_mssg = "Can't get file_ptr.";

                if (verbose)
                    fprintf(stdout, "%s: H5Fflush() failed.\n", __func__);
            }
        }
    }

    if (show_progress) /* 5 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {

        /* A bit of fancy footwork here:
         *
         * The call to H5Fcreate() allocates an instance of H5C_t,
         * initializes it, and stores its address in f->shared->cache.
         *
         * We don't want to use this cache, as it has a bunch of extra
         * initialization that may change over time, and in any case
         * it will not in general be configured the way we want it.
         *
         * We used to deal with this problem by storing the file pointer
         * in another instance of H5C_t, and then ignoring the original
         * version.  However, this strategy doesn't work any more, as
         * we can't store the file pointer in the instance of H5C_t,
         * and we have modified many cache routines to use a file
         * pointer to look up the target cache.
         *
         * Thus we now make note of the address of the instance of
         * H5C_t created by the call to H5Fcreate(), set
         * file_ptr->shared->cache to NULL, call H5C_create()
         * to allocate a new instance of H5C_t for test purposes,
         * and store than new instance's address in
         * file_ptr->shared->cache.
         *
         * On shut down, we call H5C_dest on our instance of H5C_t,
         * set file_ptr->shared->cache to point to the original
         * instance, and then close the file normally.
         */

        assert(saved_cache == NULL);
        saved_cache             = file_ptr->shared->cache;
        file_ptr->shared->cache = NULL;

        cache_ptr = H5C_create(max_cache_size, min_clean_size, (NUMBER_OF_ENTRY_TYPES - 1), types,
                               check_write_permitted, true, NULL, NULL);

        file_ptr->shared->cache = cache_ptr;
    }

    if (show_progress) /* 6 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {
        if (cache_ptr == NULL) {
            pass         = false;
            failure_mssg = "H5C_create() failed.";

            if (verbose)
                fprintf(stdout, "%s: H5C_create() failed.\n", __func__);
        }
    }

    if (show_progress) /* 7 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) { /* allocate space for test entries */
        actual_base_addr = H5MF_alloc(file_ptr, H5FD_MEM_DEFAULT, (hsize_t)(ADDR_SPACE_SIZE + BASE_ADDR));

        if (actual_base_addr == HADDR_UNDEF) {
            pass         = false;
            failure_mssg = "H5MF_alloc() failed.";

            if (verbose)
                fprintf(stdout, "%s: H5MF_alloc() failed.\n", __func__);
        }
        else if (actual_base_addr > BASE_ADDR) {
            /* If this happens, must increase BASE_ADDR so that the
             * actual_base_addr is <= BASE_ADDR.  This should only happen
             * if the size of the superblock is increase.
             */
            pass         = false;
            failure_mssg = "actual_base_addr > BASE_ADDR";

            if (verbose)
                fprintf(stdout, "%s: actual_base_addr > BASE_ADDR.\n", __func__);
        }

        saved_actual_base_addr = actual_base_addr;
    }

    if (show_progress) /* 8 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    if (pass) {
        /* Need to set this else all cache tests will fail */
        cache_ptr->ignore_tags = true;

        H5C_stats__reset(cache_ptr);
        ret_val = file_ptr;
    }

    if (show_progress) /* 9 */
        fprintf(stdout, "%s() - %0d -- pass = %d\n", __func__, mile_stone++, (int)pass);

    return (ret_val);
} /* setup_cache() */

/*-------------------------------------------------------------------------
 * Function:    takedown_cache()
 *
 * Purpose:    Flush the specified cache and destroy it.  If requested,
 *        dump stats first.  Then close and delete the associate
 *        file.
 *
 *        If pass is false, do nothing.
 *
 * Return:    void
 *
 *-------------------------------------------------------------------------
 */

void
takedown_cache(H5F_t *file_ptr, bool dump_stats, bool dump_detailed_stats)
{
    char filename[512];

    if (file_ptr != NULL) {
        H5C_t *cache_ptr = file_ptr->shared->cache;

        if (dump_stats) {

            H5C_stats(cache_ptr, "test cache", dump_detailed_stats);
        }

        if (H5C_prep_for_file_close(file_ptr) < 0) {

            pass         = false;
            failure_mssg = "unexpected failure of prep for file close.\n";
        }

        flush_cache(file_ptr, true, false, false);

        H5C_dest(file_ptr);

        if (saved_cache != NULL) {

            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        }
    }

    if (saved_fapl_id != H5P_DEFAULT) {

        H5Pclose(saved_fapl_id);
        saved_fapl_id = H5P_DEFAULT;
    }

    if (saved_fcpl_id != H5P_DEFAULT) {
        H5Pclose(saved_fcpl_id);
        saved_fcpl_id = H5P_DEFAULT;
    }

    if (saved_fid != -1) {

        if (H5_addr_defined(saved_actual_base_addr)) {

            if (NULL == file_ptr) {
                file_ptr = (H5F_t *)H5VL_object_verify(saved_fid, H5I_FILE);
                assert(file_ptr);
            }

            H5MF_xfree(file_ptr, H5FD_MEM_DEFAULT, saved_actual_base_addr,
                       (hsize_t)(ADDR_SPACE_SIZE + BASE_ADDR));
            saved_actual_base_addr = HADDR_UNDEF;
        }

        if (H5Fclose(saved_fid) < 0) {

            pass         = false;
            failure_mssg = "couldn't close test file.";
        }
        else {

            saved_fid = -1;
        }

        /* Pop API context */
        H5CX_pop(false);

        if ((!try_core_file_driver) || (core_file_driver_failed)) {

            if (h5_fixname(FILENAME[0], H5P_DEFAULT, filename, sizeof(filename)) == NULL) {

                pass         = false;
                failure_mssg = "h5_fixname() failed.\n";
            }

            if (HDremove(filename) < 0) {

                pass         = false;
                failure_mssg = "couldn't delete test file.";
            }
        }
    }

} /* takedown_cache() */

/*-------------------------------------------------------------------------
 * Function:    main
 *
 * Return:      EXIT_SUCCESS/EXIT_FAILURE
 *
 *-------------------------------------------------------------------------
 */

int
main(void)
{
    unsigned nerrs = 0;
    unsigned paged;
    int      express_test;

    H5open();

    express_test = GetTestExpress();

    printf("=========================================\n");
    printf("Internal cache tests\n");
    printf("        express_test = %d\n", express_test);
    printf("=========================================\n");

    if (!h5_using_default_driver(NULL)) {
        puts(" -- SKIPPED for incompatible VFD --");
        exit(EXIT_SUCCESS);
    }

    if (create_entry_arrays() < 0) {

        printf("ERROR: Unable to create entries arrays. Aborting.\n");
        return EXIT_FAILURE;
    } /* end if */

    /* Test with paged aggregation enabled or not */
    /* Each test will call setup_cache() which set up the file space strategy according to "paged" */
    for (paged = false; paged <= true; paged++) {

        if (paged) {

            fprintf(stdout, "\n\nRe-running tests with paged aggregation:\n");

            if (express_test > 0)
                fprintf(stdout, "    Skipping smoke checks.\n");

            fprintf(stdout, "\n");
        }

        nerrs += smoke_check_1(express_test, paged);
        nerrs += smoke_check_2(express_test, paged);
        nerrs += smoke_check_3(express_test, paged);
        nerrs += smoke_check_4(express_test, paged);
        nerrs += smoke_check_5(express_test, paged);
        nerrs += smoke_check_6(express_test, paged);
        nerrs += smoke_check_7(express_test, paged);
        nerrs += smoke_check_8(express_test, paged);
        nerrs += smoke_check_9(express_test, paged);
        nerrs += smoke_check_10(express_test, paged);
        nerrs += write_permitted_check(express_test, paged);
        nerrs += check_insert_entry(paged);
        nerrs += check_flush_cache(paged);
        nerrs += check_get_entry_status(paged);
        nerrs += check_expunge_entry(paged);
        nerrs += check_multiple_read_protect(paged);
        nerrs += check_move_entry(paged);
        nerrs += check_pin_protected_entry(paged);
        nerrs += check_resize_entry(paged);
        nerrs += check_evictions_enabled(paged);
        nerrs += check_flush_protected_err(paged);
        nerrs += check_destroy_pinned_err(paged);
        nerrs += check_destroy_protected_err(paged);
        nerrs += check_duplicate_insert_err(paged);
        nerrs += check_double_pin_err(paged);
        nerrs += check_double_unpin_err(paged);
        nerrs += check_pin_entry_errs(paged);
        nerrs += check_double_protect_err(paged);
        nerrs += check_double_unprotect_err(paged);
        nerrs += check_mark_entry_dirty_errs(paged);
        nerrs += check_expunge_entry_errs(paged);
        nerrs += check_move_entry_errs(paged);
        nerrs += check_resize_entry_errs(paged);
        nerrs += check_unprotect_ro_dirty_err(paged);
        nerrs += check_protect_ro_rw_err(paged);
        nerrs += check_protect_retries(paged);
        nerrs += check_check_evictions_enabled_err(paged);
        nerrs += check_auto_cache_resize(false, paged);
        nerrs += check_auto_cache_resize(true, paged);
        nerrs += check_auto_cache_resize_disable(paged);
        nerrs += check_auto_cache_resize_epoch_markers(paged);
        nerrs += check_auto_cache_resize_input_errs(paged);
        nerrs += check_auto_cache_resize_aux_fcns(paged);
        nerrs += check_metadata_blizzard_absence(true, paged);
        nerrs += check_metadata_blizzard_absence(false, paged);
        nerrs += check_flush_deps(paged);
        nerrs += check_flush_deps_err(paged);
        nerrs += check_flush_deps_order(paged);
        nerrs += check_notify_cb(paged);
        nerrs += check_metadata_cork(true, paged);
        nerrs += check_metadata_cork(false, paged);
        nerrs += check_entry_deletions_during_scans(paged);
        nerrs += check_stats(paged);
    } /* end for */

    /* can't fail, returns void */
    free_entry_arrays();

    if (nerrs > 0)
        return EXIT_FAILURE;
    else
        return EXIT_SUCCESS;

} /* main() */
