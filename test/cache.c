/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright by The HDF Group.                                               *
 * Copyright by the Board of Trustees of the University of Illinois.         *
 * All rights reserved.                                                      *
 *                                                                           *
 * This file is part of HDF5.  The full HDF5 copyright notice, including     *
 * terms governing use, modification, and redistribution, is contained in    *
 * the COPYING file, which can be found at the root of the source code       *
 * distribution tree, or in https://www.hdfgroup.org/licenses.               *
 * If you do not have access to either file, you may request a copy from     *
 * help@hdfgroup.org.                                                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Programmer:  John Mainzer
 *              6/9/04
 *
 *        This file contains tests for the cache implemented in
 *        H5C.c
 */
#include "cache_common.h"
#include "H5MFprivate.h"

H5C_t *saved_cache = NULL; /* store the pointer to the instance of
                            * of H5C_t created by H5Fcreate()
                            * here between test cache setup and
                            * shutdown.
                            */

haddr_t saved_actual_base_addr = HADDR_UNDEF; /* Store the address of the
                                               * space allocated for cache items in the file between
                                               * cache setup & takedown
                                               */

hid_t saved_fapl_id = H5P_DEFAULT; /* store the fapl id here between
                                    * cache setup and takedown.  Note
                                    * that if saved_fapl_id == H5P_DEFAULT,
                                    * we assume that there is no fapl to
                                    * close.
                                    */

hid_t saved_fcpl_id = H5P_DEFAULT; /* store the fcpl id here between
                                    * cache setup and takedown.  Note
                                    * that if saved_fcpl_id == H5P_DEFAULT,
                                    * we assume that there is no fcpl to
                                    * close.
                                    */

hid_t saved_fid = -1; /* store the file id here between cache setup
                       * and takedown.
                       */
hbool_t try_core_file_driver    = FALSE;
hbool_t core_file_driver_failed = FALSE;
hbool_t skip_long_tests;
hbool_t run_full_test;

/* global variable declarations: */

const char *FILENAME[] = {"cache_test", NULL};

/* private typedef declarations: */

struct flush_cache_test_spec {
    int          entry_num;
    int          entry_type;
    int          entry_index;
    hbool_t      insert_flag;
    unsigned int flags;
    hbool_t      expected_loaded;
    hbool_t      expected_cleared;
    hbool_t      expected_flushed;
    hbool_t      expected_destroyed;
};

struct pe_flush_cache_test_spec {
    int          entry_num;
    int          entry_type;
    int          entry_index;
    hbool_t      insert_flag;
    unsigned int flags;
    int          num_pins;
    int          pin_type[MAX_PINS];
    int          pin_idx[MAX_PINS];
    hbool_t      expected_loaded;
    hbool_t      expected_cleared;
    hbool_t      expected_flushed;
    hbool_t      expected_destroyed;
};

struct fo_flush_entry_check {
    int     entry_num;
    int     entry_type;
    int     entry_index;
    size_t  expected_size;
    hbool_t in_cache;
    hbool_t at_main_addr;
    hbool_t is_dirty;
    hbool_t is_protected;
    hbool_t is_pinned;
    hbool_t expected_loaded;
    hbool_t expected_cleared;
    hbool_t expected_flushed;
    hbool_t expected_destroyed;
};

struct fo_flush_cache_test_spec {
    int             entry_num;
    int             entry_type;
    int             entry_index;
    hbool_t         insert_flag;
    unsigned int    flags;
    hbool_t         resize_flag;
    size_t          new_size;
    int             num_pins;
    int             pin_type[MAX_PINS];
    int             pin_idx[MAX_PINS];
    int             num_flush_ops;
    struct flush_op flush_ops[MAX_FLUSH_OPS];
    hbool_t         expected_loaded;
    hbool_t         expected_cleared;
    hbool_t         expected_flushed;
    hbool_t         expected_destroyed;
};

struct move_entry_test_spec {
    int     entry_type;
    int     entry_index;
    hbool_t is_dirty;
    hbool_t is_pinned;
};

/* private function declarations: */

static unsigned smoke_check_1(void);
static unsigned smoke_check_2(void);
static unsigned smoke_check_3(void);
static unsigned smoke_check_4(void);
static unsigned smoke_check_5(void);
static unsigned smoke_check_6(void);
static unsigned smoke_check_7(void);
static unsigned smoke_check_8(void);
static unsigned smoke_check_9(void);
static unsigned smoke_check_10(void);
static unsigned write_permitted_check(void);
static unsigned check_insert_entry(void);
static unsigned check_flush_cache(void);
static void     check_flush_cache__empty_cache(H5F_t *file_ptr);
static void     check_flush_cache__multi_entry(H5F_t *file_ptr);
static void     check_flush_cache__multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                                    int spec_size, struct flush_cache_test_spec spec[]);
static void check_flush_cache__pe_multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                                   int spec_size, struct pe_flush_cache_test_spec spec[]);
static void check_flush_cache__single_entry(H5F_t *file_ptr);
static void check_flush_cache__single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                                 hbool_t insert_flag, unsigned int flags,
                                                 unsigned int flush_flags, hbool_t expected_loaded,
                                                 hbool_t expected_cleared, hbool_t expected_flushed,
                                                 hbool_t expected_destroyed);
static void check_flush_cache__pinned_single_entry_test(
    H5F_t *file_ptr, int test_num, int entry_type, int entry_idx, hbool_t mark_dirty,
    hbool_t pop_mark_dirty_prot, hbool_t pop_mark_dirty_pinned, hbool_t unprotect_unpin, unsigned int flags,
    unsigned int flush_flags, hbool_t expected_cleared, hbool_t expected_flushed, hbool_t expected_destroyed);
static void     check_flush_cache__flush_ops(H5F_t *file_ptr);
static void     check_flush_cache__flush_op_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags,
                                                 int spec_size, struct fo_flush_cache_test_spec spec[],
                                                 int init_expected_index_len, size_t init_expected_index_size,
                                                 int expected_index_len, size_t expected_index_size,
                                                 int check_size, struct fo_flush_entry_check check[]);
static void     check_flush_cache__flush_op_eviction_test(H5F_t *file_ptr);
static unsigned check_flush_protected_err(void);
static unsigned check_get_entry_status(void);
static unsigned check_expunge_entry(void);
static unsigned check_multiple_read_protect(void);
static unsigned check_move_entry(void);
static void check_move_entry__run_test(H5F_t *file_ptr, int test_num, struct move_entry_test_spec *spec_ptr);
static unsigned check_pin_protected_entry(void);
static unsigned check_resize_entry(void);
static unsigned check_evictions_enabled(void);
static unsigned check_destroy_pinned_err(void);
static unsigned check_destroy_protected_err(void);
static unsigned check_duplicate_insert_err(void);
static unsigned check_move_err(void);
static unsigned check_double_pin_err(void);
static unsigned check_double_unpin_err(void);
static unsigned check_pin_entry_errs(void);
static unsigned check_double_protect_err(void);
static unsigned check_double_unprotect_err(void);
static unsigned check_mark_entry_dirty_errs(void);
static unsigned check_expunge_entry_errs(void);
static unsigned check_resize_entry_errs(void);
static unsigned check_unprotect_ro_dirty_err(void);
static unsigned check_protect_ro_rw_err(void);
static unsigned check_check_evictions_enabled_err(void);
static unsigned check_auto_cache_resize(void);
static unsigned check_auto_cache_resize_disable(void);
static unsigned check_auto_cache_resize_epoch_markers(void);
static unsigned check_auto_cache_resize_input_errs(void);
static unsigned check_auto_cache_resize_aux_fcns(void);
static unsigned check_metadata_blizzard_absence(hbool_t fill_via_insertion);

/* call back function declarations: */

herr_t check_write_permitted(const H5F_t *f, hid_t dxpl_id, hbool_t *write_permitted_ptr);

H5F_t *setup_cache(size_t max_cache_size, size_t min_clean_size);

static void takedown_cache(H5F_t *file_ptr, hbool_t dump_stats, hbool_t dump_detailed_stats);

/**************************************************************************/
/**************************************************************************/
/********************************* tests: *********************************/
/**************************************************************************/
/**************************************************************************/

/*-------------------------------------------------------------------------
 * Function:    smoke_check_1()
 *
 * Purpose:    A basic functional test, inserts, destroys, and moves in
 *              the mix, along with repeated protects and unprotects.
 *        All entries are marked as clean.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/16/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_1(void)
{
    const char *fcn_name         = "smoke_check_1";
    hbool_t     show_progress    = FALSE;
    int         dirty_unprotects = FALSE;
    int         dirty_destroys   = FALSE;
    hbool_t     display_stats    = FALSE;
    int32_t     lag              = 10;
    int         mile_stone       = 1;
    H5F_t *     file_ptr         = NULL;

    TESTING("smoke check #1 -- all clean, ins, dest, ren, 4/2 MB cache");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024));

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ FALSE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ FALSE,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ FALSE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_1() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_2()
 *
 * Purpose:    A basic functional test, with inserts, destroys, and
 *        moves in the mix, along with some repeated protects
 *        and unprotects.  About half the entries are marked as
 *        dirty.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_2(void)
{
    const char *fcn_name         = "smoke_check_2";
    hbool_t     show_progress    = FALSE;
    int         dirty_unprotects = TRUE;
    int         dirty_destroys   = TRUE;
    hbool_t     display_stats    = FALSE;
    int32_t     lag              = 10;
    int         mile_stone       = 1;
    H5F_t *     file_ptr         = NULL;

    TESTING("smoke check #2 -- ~1/2 dirty, ins, dest, ren, 4/2 MB cache");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024));

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr            */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_2() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_3()
 *
 * Purpose:    A basic functional test on a tiny cache, with inserts,
 *        destroys, and moves in the mix, along with repeated
 *        protects and unprotects.  All entries are marked as clean.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/16/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_3(void)
{
    const char *fcn_name         = "smoke_check_3";
    hbool_t     show_progress    = FALSE;
    int         dirty_unprotects = FALSE;
    int         dirty_destroys   = FALSE;
    hbool_t     display_stats    = FALSE;
    int32_t     lag              = 10;
    int         mile_stone       = 1;
    H5F_t *     file_ptr         = NULL;

    TESTING("smoke check #3 -- all clean, ins, dest, ren, 2/1 KB cache");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_3() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_4()
 *
 * Purpose:    A basic functional test on a tiny cache, with inserts,
 *         destroys, and moves in the mix, along with repeated
 *        protects and unprotects.  About half the entries are
 *        marked as dirty.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_4(void)
{
    const char *fcn_name         = "smoke_check_4";
    hbool_t     show_progress    = FALSE;
    int         dirty_unprotects = TRUE;
    int         dirty_destroys   = TRUE;
    hbool_t     display_stats    = FALSE;
    int32_t     lag              = 10;
    int         mile_stone       = 1;
    H5F_t *     file_ptr         = NULL;

    TESTING("smoke check #4 -- ~1/2 dirty, ins, dest, ren, 2/1 KB cache");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_4() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_5()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *        repeated protects and unprotects.  All entries are marked
 *        as clean.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/14/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_5(void)
{
    const char *        fcn_name = "smoke_check_5";
    herr_t              result;
    hbool_t             show_progress    = FALSE;
    int                 dirty_unprotects = FALSE;
    hbool_t             display_stats    = FALSE;
    int32_t             max_index        = 1024;
    int                 mile_stone       = 1;
    H5F_t *             file_ptr         = NULL;
    H5C_t *             cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
#if 1
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
#else
        /* H5C_auto_resize_report_fcn rpt_fcn = */ H5C_def_auto_resize_rpt_fcn,
#endif
        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1f,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.9f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.5f
    };

    TESTING("smoke check #5 -- all clean, ins, prot, unprot, AR cache 1");

    if (skip_long_tests) {

        SKIPPED();

        HDfprintf(stdout, "    Long tests disabled.\n");

        return 0; /* <========== note return */
    }

    if (run_full_test) {

        max_index = (10 * 1024) - 1;
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ FALSE);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ FALSE);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ TRUE,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_5() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_6()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *              repeated protects and unprotects.  About one half of all
 *        entries are marked as dirty.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/25/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_6(void)
{
    const char *        fcn_name = "smoke_check_6";
    herr_t              result;
    hbool_t             show_progress    = FALSE;
    int                 dirty_unprotects = FALSE;
    hbool_t             display_stats    = FALSE;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t *             file_ptr         = NULL;
    H5C_t *             cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
#if 1
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
#else
        /* H5C_auto_resize_report_fcn rpt_fcn = */ H5C_def_auto_resize_rpt_fcn,
#endif
        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1f,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.9f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.05f
    };

    TESTING("smoke check #6 -- ~1/2 dirty, ins, prot, unprot, AR cache 1");

    pass = TRUE;

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    if (run_full_test) {

        max_index = (10 * 1024) - 1;
    }

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ FALSE);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ FALSE);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ TRUE,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_6() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_7()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *        repeated protects and unprotects.  All entries are marked
 *        as clean.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              12/2/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_7(void)
{
    const char *        fcn_name = "smoke_check_7";
    herr_t              result;
    hbool_t             show_progress    = FALSE;
    int                 dirty_unprotects = FALSE;
    hbool_t             display_stats    = FALSE;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t *             file_ptr         = NULL;
    H5C_t *             cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
#if 1
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
#else
        /* H5C_auto_resize_report_fcn rpt_fcn = */ H5C_def_auto_resize_rpt_fcn,
#endif
        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1f,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 100000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (8 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */
        H5C_decr__age_out_with_threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.9f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.1f
    };

    TESTING("smoke check #7 -- all clean, ins, prot, unprot, AR cache 2");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    if (run_full_test) {

        max_index = (10 * 1024) - 1;
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ FALSE);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ FALSE);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ TRUE,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_7() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_8()
 *
 * Purpose:    A basic functional test on a cache with automatic cache
 *        resizing enabled, with inserts in the mix, along with
 *              repeated protects and unprotects.  About one half of all
 *        entries are marked as dirty.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/25/04
 *
 * Modifications:
 *
 *        JRM -- 1/18/05
 *        Added code to skip this test if the skip_long_tests global
 *        is true.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_8(void)
{
    const char *        fcn_name = "smoke_check_8";
    herr_t              result;
    hbool_t             show_progress    = FALSE;
    int                 dirty_unprotects = FALSE;
    hbool_t             display_stats    = FALSE;
    int                 mile_stone       = 1;
    int32_t             max_index        = 1024;
    H5F_t *             file_ptr         = NULL;
    H5C_t *             cache_ptr        = NULL;
    H5C_auto_size_ctl_t auto_size_ctl    = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
#if 1
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
#else
        /* H5C_auto_resize_report_fcn rpt_fcn = */ H5C_def_auto_resize_rpt_fcn,
#endif
        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (2 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.1f,

        /* size_t      max_size               = */ (32 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 100000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */
        H5C_decr__age_out_with_threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.9f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.1f
    };

    TESTING("smoke check #8 -- ~1/2 dirty, ins, prot, unprot, AR cache 2");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    if (run_full_test) {

        max_index = (10 * 1024) - 1;
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
    cache_ptr = file_ptr->shared->cache;

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ FALSE);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ FALSE);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_row_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_forward(/* file_ptr              */ file_ptr,
                              /* max_index              */ max_index,
                              /* verbose                */ FALSE,
                              /* reset_stats            */ TRUE,
                              /* display_stats          */ display_stats,
                              /* display_detailed_stats */ FALSE,
                              /* do_inserts             */ TRUE,
                              /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    hl_col_major_scan_backward(/* file_ptr              */ file_ptr,
                               /* max_index              */ max_index,
                               /* verbose                */ FALSE,
                               /* reset_stats            */ TRUE,
                               /* display_stats          */ display_stats,
                               /* display_detailed_stats */ FALSE,
                               /* do_inserts             */ TRUE,
                               /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_8() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_9()
 *
 * Purpose:    A repeat of smoke check 1, only with the cache corked
 *         part of the time.
 *
 *         Recall that smoke check 1 is a basic functional test,
 *         with inserts, destroys, and moves in the mix, along
 *         with repeated protects and unprotects.  All entries are
 *         marked as clean.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              8/1/07
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_9(void)
{
    const char *fcn_name = "smoke_check_9";
    herr_t      result;
    hbool_t     show_progress          = FALSE;
    int         dirty_unprotects       = FALSE;
    int         dirty_destroys         = FALSE;
    hbool_t     display_stats          = FALSE;
    hbool_t     display_detailed_stats = FALSE;
    int32_t     lag                    = 10;
    int         mile_stone             = 1;
    H5F_t *     file_ptr               = NULL;
    H5C_t *     cache_ptr              = NULL;

    TESTING("smoke check #9 -- all clean, ins, dest, ren, 4/2 MB, corked");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024));
    cache_ptr = file_ptr->shared->cache;

    /* disable evictions */

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 1.\n";
        }
    }

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    /* enable evictions */

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 1.\n";
        }
    }

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled \n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 2.\n";
        }
    }

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled \n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 2.\n";
        }
    }

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled \n", fcn_name, mile_stone++,
                  (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 3.\n";
        }
    }

    if (show_progress) /* 12 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 13 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 14 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 3.\n";
        }
    }

    if (show_progress) /* 15 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", fcn_name, mile_stone++,
                  (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 16 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 4.\n";
        }
    }

    if (show_progress) /* 17 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 18 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_9() */

/*-------------------------------------------------------------------------
 * Function:    smoke_check_10()
 *
 * Purpose:    A repeat of smoke check 2, only with the cache corked
 *         part of the time.
 *
 *         Recall that smoke check 2 is a basic functional test,
 *         with inserts, destroys, and moves in the mix, along
 *         with some repeated protects and unprotects.  About half
 *         the entries are marked as dirty.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              8/1/07
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
smoke_check_10(void)
{
    const char *fcn_name = "smoke_check_10";
    herr_t      result;
    hbool_t     show_progress          = FALSE;
    int         dirty_unprotects       = TRUE;
    int         dirty_destroys         = TRUE;
    hbool_t     display_stats          = FALSE;
    hbool_t     display_detailed_stats = FALSE;
    int32_t     lag                    = 10;
    int         mile_stone             = 1;
    H5F_t *     file_ptr               = NULL;
    H5C_t *     cache_ptr              = NULL;

    TESTING("smoke check #10 -- ~1/2 dirty, ins, dest, ren, 4/2 MB, corked");

    if (skip_long_tests) {
        SKIPPED();
        HDfprintf(stdout, "    Long tests disabled.\n");
        return 0; /* <========== note return */
    }

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr  = setup_cache((size_t)(4 * 1024 * 1024), (size_t)(2 * 1024 * 1024));
    cache_ptr = file_ptr->shared->cache;

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 1.\n";
        }
    }

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ dirty_destroys,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 1.\n";
        }
    }

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", fcn_name, mile_stone++,
                  (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ dirty_destroys,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 2.\n";
        }
    }

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 2.\n";
        }
    }

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", fcn_name, mile_stone++,
                  (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ display_detailed_stats,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 12 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 3.\n";
        }
    }

    if (show_progress) /* 13 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    /* flush all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ FALSE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 14 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't enable evictions 3.\n";
        }
    }

    if (show_progress) /* 15 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions enabled\n", fcn_name, mile_stone++,
                  (int)pass);

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ display_detailed_stats,
                            /* do_inserts             */ TRUE,
                            /* dirty_unprotects       */ dirty_unprotects);

    if (show_progress) /* 16 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "can't disable evictions 4.\n";
        }
    }

    if (show_progress) /* 17 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d -- evictions disabled\n", fcn_name, mile_stone++,
                  (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 18 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* smoke_check_10() */

/*-------------------------------------------------------------------------
 * Function:    write_permitted_check()
 *
 * Purpose:    A basic test of the write permitted function.  In essence,
 *        we load the cache up with dirty entryies, set
 *        write_permitted to FALSE, and then protect a bunch of
 *        entries.  If there are any writes while write_permitted is
 *        FALSE, the test will fail.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
write_permitted_check(void)
{

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS

    const char *fcn_name      = "write_permitted_check";
    hbool_t     show_progress = FALSE;
    hbool_t     display_stats = FALSE;
    int32_t     lag           = 10;
    int         mile_stone    = 1;
    H5F_t *     file_ptr      = NULL;

#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    TESTING("write permitted check -- 1/0 MB cache");

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    reset_entries();

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    file_ptr = setup_cache((size_t)(1 * 1024 * 1024), (size_t)(0));

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ TRUE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ TRUE,
                           /* dirty_unprotects       */ TRUE);

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    write_permitted = FALSE;

    row_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ FALSE,
                            /* do_moves             */ TRUE,
                            /* move_to_main_addr    */ TRUE,
                            /* do_destroys            */ FALSE,
                            /* do_mult_ro_protects    */ TRUE,
                            /* dirty_destroys         */ FALSE,
                            /* dirty_unprotects       */ NO_CHANGE);

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    write_permitted = TRUE;

    row_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* do_moves             */ TRUE,
                           /* move_to_main_addr    */ FALSE,
                           /* do_destroys            */ FALSE,
                           /* do_mult_ro_protects    */ TRUE,
                           /* dirty_destroys         */ TRUE,
                           /* dirty_unprotects       */ TRUE);

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* flush and destroy all entries in the cache: */

    flush_cache(/* file_ptr           */ file_ptr,
                /* destroy_entries     */ TRUE,
                /* dump_stats          */ FALSE,
                /* dump_detailed_stats */ FALSE);

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    col_major_scan_forward(/* file_ptr              */ file_ptr,
                           /* lag                    */ lag,
                           /* verbose                */ FALSE,
                           /* reset_stats            */ TRUE,
                           /* display_stats          */ display_stats,
                           /* display_detailed_stats */ TRUE,
                           /* do_inserts             */ TRUE,
                           /* dirty_unprotects       */ TRUE);

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    write_permitted = FALSE;

    col_major_scan_backward(/* file_ptr              */ file_ptr,
                            /* lag                    */ lag,
                            /* verbose                */ FALSE,
                            /* reset_stats            */ TRUE,
                            /* display_stats          */ display_stats,
                            /* display_detailed_stats */ TRUE,
                            /* do_inserts             */ FALSE,
                            /* dirty_unprotects       */ NO_CHANGE);

    write_permitted = TRUE;

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    takedown_cache(file_ptr, display_stats, TRUE);

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    verify_clean();
    verify_unprotected();

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    SKIPPED();

    HDfprintf(stdout, "    Clean and dirty LRU lists disabled.\n");

#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

    return (unsigned)!pass;

} /* write_permitted_check() */

/*-------------------------------------------------------------------------
 * Function:    check_insert_entry()
 *
 * Purpose:    Verify that H5C_insert_entry behaves as expected.
 *        Test the behaviour with different flags.
 *
 *        This test was added primarily to test basic insert
 *        pinned entry functionallity, but I through in explicit
 *        tests for other functionallity that is tested implicitly
 *        elsewhere.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              8/10/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_insert_entry(void)
{
    const char *              fcn_name   = "check_insert_entry";
    int                       entry_type = PICO_ENTRY_TYPE;
    int                       i;
    herr_t                    result;
    hbool_t                   in_cache;
    hbool_t                   is_dirty;
    hbool_t                   is_protected;
    hbool_t                   is_pinned;
    size_t                    entry_size;
    H5F_t *                   file_ptr  = NULL;
    H5C_t *                   cache_ptr = NULL;
    test_entry_t *            base_addr;
    test_entry_t *            entry_ptr;
    struct H5C_cache_entry_t *search_ptr;

    TESTING("H5C_insert_entry() functionality");

    pass = TRUE;

    /* Allocate a cache, and insert entries into it using all
     * combinations of flags.  Verify that the entries are inserted,
     * and that the flags have the desired effects.
     *
     * Note that the dirty parameter in insert_entry is no longer
     * used, as we have decided that all inserted entries are
     * dirty by definition. (Which sounds very reasonable, but didn't
     * used to be the case.)
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        insert_entry(file_ptr, entry_type, 0, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, entry_type, 1, H5C__SET_FLUSH_MARKER_FLAG);
        insert_entry(file_ptr, entry_type, 2, H5C__PIN_ENTRY_FLAG);
        insert_entry(file_ptr, entry_type, 3, (H5C__SET_FLUSH_MARKER_FLAG | H5C__PIN_ENTRY_FLAG));
    }

    /* Verify that the entries are inserted as desired. */

    i         = 0;
    base_addr = entries[0];
    while ((pass) && (i < 4)) {
        entry_ptr = &(base_addr[i]);

        /* Start by checking everything we can via H5C_get_entry_status() */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "H5C_get_entry_status() reports failure.";
        }

        if (pass) {

            /* check the universals */
            if ((!in_cache) || (!is_dirty) || (is_protected) || (entry_size != entry_sizes[entry_type])) {

                pass         = FALSE;
                failure_mssg = "Unexpected insert results 1.";
            }
        }

        if (pass) {

            /* verify that the pinned flag got set correctly */
            if ((i == 2) || (i == 3)) {

                if (!is_pinned) {

                    pass         = FALSE;
                    failure_mssg = "Unexpected insert results 2.";
                }
            }
            else if (is_pinned) {

                pass         = FALSE;
                failure_mssg = "Unexpected insert results 3.";
            }
            else if (is_pinned != ((entry_ptr->header).is_pinned)) {

                pass         = FALSE;
                failure_mssg = "Unexpected insert results 4.";
            }
        }

        /* Thats all we can get from H5C_get_entry_status().
         * Now start looking at the cache data structures directly.
         */

        if (pass) {

            /* Verify that the flush marker got set correctly */
            if ((i == 1) || (i == 3)) {

                if (!((entry_ptr->header).flush_marker)) {

                    pass         = FALSE;
                    failure_mssg = "Unexpected insert results 5.";
                }
            }
            else if ((entry_ptr->header).flush_marker) {

                pass         = FALSE;
                failure_mssg = "Unexpected insert results 6.";
            }
        }

        if (pass) {

            /* Verify that pinned entries are in the pinned entry list */
            if ((entry_ptr->header).is_pinned) {

                search_ptr = cache_ptr->pel_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->next;
                }

                if (search_ptr == NULL) {

                    pass         = FALSE;
                    failure_mssg = "Unexpected insert results 7.";
                }
            }
        }

        if (pass) {

            /* Verify that unpinned entries are in the LRU list */
            if (!((entry_ptr->header).is_pinned)) {

                search_ptr = cache_ptr->LRU_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->next;
                }

                if (search_ptr == NULL) {

                    pass         = FALSE;
                    failure_mssg = "Unexpected insert results 8.";
                }
            }
        }

#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
        if (pass) {

            /* Verify that unpinned entries are in the dirty LRU list */
            if (!((entry_ptr->header).is_pinned)) {

                search_ptr = cache_ptr->dLRU_head_ptr;

                while ((search_ptr != NULL) && (search_ptr != (struct H5C_cache_entry_t *)entry_ptr)) {
                    search_ptr = search_ptr->aux_next;
                }

                if (search_ptr == NULL) {

                    pass         = FALSE;
                    failure_mssg = "Unexpected insert results 9.";
                }
            }
        }
#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */

        i++;

    } /* while */

    /* So much for looking at the individual entries.  Now verify
     * that the various counts and sized in the cache header are
     * as expected.
     */

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != 4 * entry_sizes[entry_type]) ||
            (cache_ptr->slist_len != 4) || (cache_ptr->slist_size != 4 * entry_sizes[entry_type]) ||
            (cache_ptr->pl_len != 0) || (cache_ptr->pl_size != (size_t)0) || (cache_ptr->pel_len != 2) ||
            (cache_ptr->pel_size != 2 * entry_sizes[entry_type]) || (cache_ptr->LRU_list_len != 2) ||
            (cache_ptr->LRU_list_size != 2 * entry_sizes[entry_type]) ||
#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
            (cache_ptr->dLRU_list_len != 2) || (cache_ptr->dLRU_list_size != 2 * entry_sizes[entry_type]) ||
#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
            (cache_ptr->cLRU_list_len != 0) || (cache_ptr->cLRU_list_size != (size_t)0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected insert results 10.";
        }
    }

    /* Finally, if stats collection is enabled, verify that the expected
     * stats are collected.
     */
#if H5C_COLLECT_CACHE_STATS
    if (pass) {

        if ((cache_ptr->insertions[entry_type] != 4) || (cache_ptr->pinned_insertions[entry_type] != 2) ||
            (cache_ptr->pins[entry_type] != 2) || (cache_ptr->unpins[entry_type] != 0) ||
            (cache_ptr->dirty_pins[entry_type] != 0) || (cache_ptr->max_index_len != 4) ||
            (cache_ptr->max_index_size != 4 * entry_sizes[entry_type]) || (cache_ptr->max_slist_len != 4) ||
            (cache_ptr->max_slist_size != 4 * entry_sizes[entry_type]) || (cache_ptr->max_pl_len != 0) ||
            (cache_ptr->max_pl_size != (size_t)0) || (cache_ptr->max_pel_len != 2) ||
            (cache_ptr->max_pel_size != 2 * entry_sizes[entry_type])) {

            pass         = FALSE;
            failure_mssg = "Unexpected insert results 11.";
        }
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* Unpin the pinned entries so we can take down the cache cleanly. */

    if (pass) {

        unpin_entry(entry_type, 2);
        unpin_entry(entry_type, 3);
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_insert_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache()
 *
 * Purpose:    Verify that flush_cache behaves as expected.  In particular,
 *        test the behaviour with different flags.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/10/05
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_cache(void)
{
    const char *fcn_name      = "check_flush_cache";
    hbool_t     show_progress = FALSE;
    H5F_t *     file_ptr      = NULL;

    TESTING("H5C_flush_cache() functionality");

    pass = TRUE;

    /* allocate a cache, and flush it under various circumstances.
     * To the extent possible, verify that the desired actions took
     * place.
     */

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: reseting entries.\n", fcn_name);
        }

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));
    }

    /* first test behaviour on an empty cache.  Can't do much sanity
     * checking in this case, so simply check the return values.
     */

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: calling check_flush_cache__empty_cache().\n", fcn_name);
        }

        check_flush_cache__empty_cache(file_ptr);
    }

    /* now do a series of similar tests with a cache with a single entry.
     * Start with a clean entry, with no flags set.
     */

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: calling check_flush_cache__single_entry().\n", fcn_name);
        }

        check_flush_cache__single_entry(file_ptr);
    }

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: calling check_flush_cache__multi_entry().\n", fcn_name);
        }

        check_flush_cache__multi_entry(file_ptr);
    }

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: calling check_flush_cache__flush_ops().\n", fcn_name);
        }

        check_flush_cache__flush_ops(file_ptr);
    }

    if (pass) {

        if (show_progress) {

            HDfprintf(stdout, "%s: calling takedown_cache().\n", fcn_name);
        }

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_flush_cache() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__empty_cache()
 *
 * Purpose:    Verify that flush_cache behaves as expected with an empty
 *              cache.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/12/05
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__empty_cache(H5F_t *file_ptr)
{
    /* const char * fcn_name = "check_flush_cache__empty_cache"; */
    H5C_t *cache_ptr = file_ptr->shared->cache;
    herr_t result;

    if (cache_ptr == NULL) {

        pass         = FALSE;
        failure_mssg = "cache_ptr NULL on entry to empty cache case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = FALSE;
        failure_mssg = "cache not empty at beginning of empty cache case.";
    }

    /* Test behaviour on an empty cache.  Can't do much sanity
     * checking in this case, so simply check the return values.
     */

    if (pass) {

        result =
            H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, H5C__NO_FLAGS_SET);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "flush with flags = 0x00 failed on empty cache.\n";
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "flush with flags = 0x04 failed on empty cache.\n";
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_CLEAR_ONLY_FLAG);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "flush with flags = 0x08 failed on empty cache.\n";
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_MARKED_ENTRIES_FLAG);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "flush with flags = 0x10 failed on empty cache.\n";
        }
    }

} /* check_flush_cache__empty_cache() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__multi_entry()
 *
 * Purpose:    Verify that flush_cache behaves as expected when the cache
 *        contains multiple elements.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/14/05
 *
 * Modifications:
 *
 *         JRM -- 4/5/06
 *         Added pinned entry tests.
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__multi_entry(H5F_t *file_ptr)
{
    /* const char * fcn_name = "check_flush_cache__multi_entry"; */
    H5C_t *cache_ptr = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = FALSE;
        failure_mssg = "cache_ptr NULL on entry to multi entry case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = FALSE;
        failure_mssg = "cache not empty at beginning of multi entry case.";
    }

    if (pass) {
        int                          test_num    = 1;
        unsigned int                 flush_flags = H5C__NO_FLAGS_SET;
        int                          spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {
            {/* entry_num             = */ 0,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 100,
             /* insert_flag           = */ FALSE,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 1,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 75,
             /* insert_flag           = */ FALSE,
             /* flags                 = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 2,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 25,
             /* insert_flag           = */ TRUE,
             /* flags                 = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 3,
             /* entry_type            = */ PICO_ENTRY_TYPE,
             /* entry_index           = */ 50,
             /* insert_flag           = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 4,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 10,
             /* insert_flag           = */ FALSE,
             /* flags                 = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 5,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 20,
             /* insert_flag           = */ FALSE,
             /* flags                 = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 6,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 30,
             /* insert_flag           = */ TRUE,
             /* flags                 = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE},
            {/* entry_num             = */ 7,
             /* entry_type            = */ MONSTER_ENTRY_TYPE,
             /* entry_index           = */ 40,
             /* insert_flag           = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed    = */ FALSE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 2;
        unsigned int                 flush_flags = H5C__FLUSH_INVALIDATE_FLAG;
        int                          spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 3;
        unsigned int                 flush_flags = H5C__FLUSH_CLEAR_ONLY_FLAG;
        int                          spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 4;
        unsigned int                 flush_flags = H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int                          spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                          test_num    = 5;
        unsigned int                 flush_flags = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG;
        int                          spec_size   = 8;
        struct flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int          test_num                = 6;
        unsigned int flush_flags             = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int          spec_size               = 8;
        struct flush_cache_test_spec spec[8] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int          test_num                = 7;
        unsigned int flush_flags             = H5C__FLUSH_CLEAR_ONLY_FLAG | H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int          spec_size               = 8;
        struct flush_cache_test_spec spec[8] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int          test_num = 8;
        unsigned int flush_flags =
            H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG | H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int                          spec_size = 8;
        struct flush_cache_test_spec spec[8]   = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    /* verify that all other flags are ignored */
    if (pass) {
        int          test_num    = 9;
        unsigned int flush_flags = (unsigned)~(H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                                               H5C__FLUSH_MARKED_ENTRIES_FLAG);
        int          spec_size   = 8;
        struct flush_cache_test_spec spec[8] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};

        check_flush_cache__multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    /* Now do pinned entry tests:
     *
     * For the most part, this test is directed at testing the ability
     * of the flush routine to unravel collections of pinned entries.
     */

    if (pass) {
        int                             test_num    = 1;
        unsigned int                    flush_flags = H5C__NO_FLAGS_SET;
        int                             spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 2,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 3,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 4,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 5,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1,
              -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, 10, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 6,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE,
              MONSTER_ENTRY_TYPE, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, 10, 20, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 7,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, MONSTER_ENTRY_TYPE,
              MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, 10, 20, 30, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                             test_num    = 2;
        unsigned int                    flush_flags = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 2,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 3,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {MONSTER_ENTRY_TYPE, -1, -1, -1, -1 - 1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {10, -1, -1, -1 - 1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 2,
             /* pin_type[MAX_PINS] = */ {MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {10, 20, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 3,
             /* pin_type[MAX_PINS] = */
             {MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, MONSTER_ENTRY_TYPE, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {10, 20, 30, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int                             test_num    = 3;
        unsigned int                    flush_flags = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG;
        int                             spec_size   = 8;
        struct pe_flush_cache_test_spec spec[8]     = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int          test_num                   = 4;
        unsigned int flush_flags                = H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int          spec_size                  = 8;
        struct pe_flush_cache_test_spec spec[8] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 4,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 4,
             /* pin_type[MAX_PINS] = */
             {PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, PICO_ENTRY_TYPE, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, 75, 25, 50, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    if (pass) {
        int          test_num = 5;
        unsigned int flush_flags =
            H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG | H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int                             spec_size = 8;
        struct pe_flush_cache_test_spec spec[8]   = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 0,
             /* pin_type[MAX_PINS] = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {-1, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 75,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 25,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__NO_FLAGS_SET,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 30,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ MONSTER_ENTRY_TYPE,
             /* entry_index        = */ 40,
             /* insert_flag        = */ TRUE,
             /* flags              = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* num_pins           = */ 1,
             /* pin_type[MAX_PINS] = */ {PICO_ENTRY_TYPE, -1, -1, -1, -1, -1, -1, -1},
             /* pin_idx[MAX_PINS]  = */ {100, -1, -1, -1, -1, -1, -1, -1},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ TRUE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ TRUE}};

        check_flush_cache__pe_multi_entry_test(file_ptr, test_num, flush_flags, spec_size, spec);
    }

    return;

} /* check_flush_cache__multi_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__multi_entry_test()
 *
 * Purpose:    Run a multi entry flush cache test.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/13/05
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags, int spec_size,
                                    struct flush_cache_test_spec spec[])
{
    /* const char *   fcn_name = "check_flush_cache__multi_entry_test"; */
    H5C_t *       cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    herr_t        result;
    int           i;
    size_t        total_entry_size = 0;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

#if 0  /* JRM */
    /* This gets used a lot, so lets leave it in. */

    HDfprintf(stdout, "check_flush_cache__multi_entry_test: test %d\n",
        test_num);
#endif /* JRM */

    if (cache_ptr == NULL) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache_ptr NULL on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = FALSE;

        HDsnprintf(msg, (size_t)128, "cache not empty at beginning of multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "missing/bad test spec on entry to multi entry test #%d.", test_num);
        failure_mssg = msg;
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if ((spec[i].entry_num != i) || (spec[i].entry_type < 0) ||
            (spec[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[i].entry_index < 0) ||
            (spec[i].entry_index > max_indices[spec[i].entry_type])) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "bad data in spec[%d] on entry to multi entry test #%d.", i,
                       test_num);
            failure_mssg = msg;
        }
        i++;
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if (spec[i].insert_flag) {

            insert_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }
        else {

            protect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index);

            unprotect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }

        total_entry_size += entry_sizes[spec[i].entry_type];

        i++;
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, flush_flags);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "flush with flags 0x%x failed in multi entry test #%d.", flush_flags,
                       test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        if ((entry_ptr->loaded != spec[i].expected_loaded) ||
            (entry_ptr->cleared != spec[i].expected_cleared) ||
            (entry_ptr->flushed != spec[i].expected_flushed) ||
            (entry_ptr->destroyed != spec[i].expected_destroyed)) {

#if 0 /* This is useful debugging code.  Lets keep it around. */

            HDfprintf(stdout,
              "loaded = %d(%d), clrd = %d(%d), flshd = %d(%d), dest = %d(%d)\n",
              (int)(entry_ptr->loaded),
              (int)(spec[i].expected_loaded),
              (int)(entry_ptr->cleared),
              (int)(spec[i].expected_cleared),
              (int)(entry_ptr->flushed),
              (int)(spec[i].expected_flushed),
              (int)(entry_ptr->destroyed),
              (int)(spec[i].expected_destroyed));

#endif

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Bad status on entry %d after flush in multi entry test #%d.", i,
                       test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != spec_size) || (cache_ptr->index_size != total_entry_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after flush in multi entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Flush failed on cleanup in multi entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after cleanup in multi entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        entry_ptr->loaded    = FALSE;
        entry_ptr->cleared   = FALSE;
        entry_ptr->flushed   = FALSE;
        entry_ptr->destroyed = FALSE;

        i++;
    }

    return;

} /* check_flush_cache__multi_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__pe_multi_entry_test()
 *
 * Purpose:    Run a multi entry flush cache test.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/5/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__pe_multi_entry_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags, int spec_size,
                                       struct pe_flush_cache_test_spec spec[])
{
    /* const char *   fcn_name = "check_flush_cache__pe_multi_entry_test"; */
    H5C_t *       cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    herr_t        result;
    int           i;
    int           j;
    size_t        total_entry_size = 0;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

#if 0  /* JRM */
    /* This is useful debugging code.  Leave it in for now. */

    HDfprintf(stdout, "check_flush_cache__pe_multi_entry_test: test %d\n",
        test_num);
#endif /* JRM */

    if (cache_ptr == NULL) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache_ptr NULL on entry to pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = FALSE;

        HDsnprintf(msg, (size_t)128, "cache not empty at beginning of pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "missing/bad test spec on entry to pe multi entry test #%d.", test_num);
        failure_mssg = msg;
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if ((spec[i].entry_num != i) || (spec[i].entry_type < 0) ||
            (spec[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[i].entry_index < 0) ||
            (spec[i].entry_index > max_indices[spec[i].entry_type]) || (spec[i].num_pins < 0) ||
            (spec[i].num_pins > MAX_PINS)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "bad data in spec[%d] on entry to pe multi entry test #%d.", i,
                       test_num);
            failure_mssg = msg;
        }
        i++;
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if (spec[i].insert_flag) {

            insert_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }
        else {

            protect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index);

            unprotect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }

        total_entry_size += entry_sizes[spec[i].entry_type];

        for (j = 0; j < spec[i].num_pins; j++) {
            create_pinned_entry_dependency(file_ptr, spec[i].entry_type, spec[i].entry_index,
                                           spec[i].pin_type[j], spec[i].pin_idx[j]);
        }

        i++;
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, flush_flags);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "flush with flags 0x%x failed in pe multi entry test #%d.",
                       flush_flags, test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        if ((entry_ptr->loaded != spec[i].expected_loaded) ||
            (entry_ptr->cleared != spec[i].expected_cleared) ||
            (entry_ptr->flushed != spec[i].expected_flushed) ||
            (entry_ptr->destroyed != spec[i].expected_destroyed)) {

#if 0 /* This is useful debugging code.  Lets keep it around. */

            HDfprintf(stdout,
              "loaded = %d(%d), clrd = %d(%d), flshd = %d(%d), dest = %d(%d)\n",
              (int)(entry_ptr->loaded),
              (int)(spec[i].expected_loaded),
              (int)(entry_ptr->cleared),
              (int)(spec[i].expected_cleared),
              (int)(entry_ptr->flushed),
              (int)(spec[i].expected_flushed),
              (int)(entry_ptr->destroyed),
              (int)(spec[i].expected_destroyed));

#endif

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Bad status on entry %d after flush in pe multi entry test #%d.", i,
                       test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != spec_size) || (cache_ptr->index_size != total_entry_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after flush in pe multi entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Flush failed on cleanup in pe multi entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128,
                       "Unexpected cache len/size after cleanup in pe multi entry test #%d.", test_num);
            failure_mssg = msg;
        }
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        entry_ptr->loaded    = FALSE;
        entry_ptr->cleared   = FALSE;
        entry_ptr->flushed   = FALSE;
        entry_ptr->destroyed = FALSE;

        i++;
    }

    return;

} /* check_flush_cache__pe_multi_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_ops()
 *
 * Purpose:    Run the flush ops cache tests.
 *
 *         These are tests that test the cache's ability to handle
 *         the case in which the flush callback dirties, resizes,
 *         and/or moves entries.
 *
 *         Do nothing if pass is FALSE on entry.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              9/3/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_ops(H5F_t *file_ptr)
{
    /* const char *   fcn_name = "check_flush_cache__flush_ops"; */
    H5C_t *cache_ptr = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = FALSE;
        failure_mssg = "cache_ptr NULL on entry to flush ops test.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = FALSE;
        failure_mssg = "cache not empty at beginning of flush ops test.";
    }

    if (pass) /* test #1 */
    {
        /* start with a very simple test, in which there are two entries
         * resident in cache, and the second entry dirties the first in
         * the flush callback.  No size changes, and no flush flags.
         */
        int                             test_num                 = 1;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 2;
        int                             init_expected_index_len  = 2;
        size_t                          init_expected_index_size = 2 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 2;
        size_t                          expected_index_size      = 2 * PICO_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[2]                  = {{/* entry_num          = */ 0,
                                                    /* entry_type         = */ 0,
                                                    /* entry_index        = */ 0,
                                                    /* insert_flag        = */ FALSE,
                                                    /* flags          = */ H5C__NO_FLAGS_SET,
                                                    /* resize_flag        = */ FALSE,
                                                    /* new_size           = */ 0,
                                                    /* num_pins           = */ 0,
                                                    /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* num_flush_ops      = */ 0,
                                                    /* flush_ops          = */
                                                    /*    op_code:        type:    idx:    flag:    size: */
                                                    {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
                                                    /* expected_loaded    = */ TRUE,
                                                    /* expected_cleared   = */ FALSE,
                                                    /* expected_flushed   = */ TRUE,
                                                    /* expected_destroyed = */ FALSE},
                                                   {/* entry_num          = */ 1,
                                                    /* entry_type         = */ 0,
                                                    /* entry_index        = */ 1,
                                                    /* insert_flag        = */ FALSE,
                                                    /* flags          = */ H5C__DIRTIED_FLAG,
                                                    /* resize_flag        = */ FALSE,
                                                    /* new_size           = */ 0,
                                                    /* num_pins           = */ 0,
                                                    /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* num_flush_ops      = */ 1,
                                                    /* flush_ops          = */
                                                    /*    op_code:        type:    idx:    flag:    size: */
                                                    {{FLUSH_OP__DIRTY, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
                                                    /* expected_loaded    = */ TRUE,
                                                    /* expected_cleared   = */ FALSE,
                                                    /* expected_flushed   = */ TRUE,
                                                    /* expected_destroyed = */ FALSE}};
        int                             check_size               = 0;
        struct fo_flush_entry_check     checks[1]                = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #2 */
    {
        /* Same as test 1, only this time set the flush invalidate flag.
         * Note that we must repeat all tests with the flush invalidate flag
         * as this triggers a different set of code to execute the flush.
         *
         * Create two entries resident in cache, and have the second entry
         * dirty the first in the flush callback.
         */
        int                             test_num                 = 2;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 2;
        int                             init_expected_index_len  = 2;
        size_t                          init_expected_index_size = 2 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = 0;
        struct fo_flush_cache_test_spec spec[2]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:        idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #3 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function resizes the entry for which it has
         * been called.
         */
        int                             test_num                 = 3;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE / 4;
        int                             expected_index_len       = 1;
        size_t                          expected_index_size      = VARIABLE_ENTRY_SIZE / 2;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #4 */
    {
        /* Repeat test #4 with the flush invalidate flag.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function resizes the entry for which it has
         * been called.
         */
        int                             test_num                 = 4;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE / 4;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = 0;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #5 & #6 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function moves the entry for which it has
         * been called.
         *
         * Run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         */
        int                             test_num                 = 5; /* and 6 */
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 1;
        size_t                          expected_index_size      = VARIABLE_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            spec[0].flush_ops[0].flag = TRUE;
            test_num                  = 6;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #7 & #8 */
    {
        /* Run tests 5 & 6 again, using the flush invalidate flag on the
         * second test.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function moves the entry for which it has
         * been called.
         *
         * Run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         */
        int                             test_num                 = 7; /* and 8 */
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 1;
        size_t                          expected_index_size      = VARIABLE_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */

        if (pass) {

            test_num                   = 8;
            flush_flags                = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len         = 0;
            expected_index_size        = 0;
            spec[0].flush_ops[0].flag  = TRUE;
            spec[0].expected_destroyed = TRUE;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #9 & #10 */
    {
        /* Single entry test verifying that the cache can handle the case in
         * which the call back function both resizes and moves the entry
         * for which it has been called.
         *
         * Again, we run this entry twice, as the first run moves the entry
         * to its alternate address, and the second moves it back.
         */
        int                             test_num                 = 9; /* and 10 */
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE / 2;
        int                             expected_index_len       = 1;
        size_t                          expected_index_size      = VARIABLE_ENTRY_SIZE / 4;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 2,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            spec[0].flush_ops[1].flag = TRUE;
            test_num                  = 10;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #11 & #12 */
    {
        /* Repeat the previous test with the flush invalidate flag on the
         * second test.
         *
         * Single entry test verifying that the cache can handle the case in
         * which the call back function both resizes and moves the entry
         * for which it has been called.
         *
         * Again, we run this entry twice, as the first run moves the entry to its
         * alternate address, and the second moves it back.
         */
        int                             test_num                 = 11; /* and 12 */
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = VARIABLE_ENTRY_SIZE / 2;
        int                             expected_index_len       = 1;
        size_t                          expected_index_size      = VARIABLE_ENTRY_SIZE / 4;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 2,
             /* flush_ops          = */
             /*    op_code:        type:            idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the move to move the target entry back to its
         * main address.  The first test moved it to its alternate address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entry is moved forward in the slist.  In the second
         * it is moved backwards.
         *
         * Since there is only one entry in the cache, this doesn't really
         * matter in this case.  But we will do similar tests later with
         * other entries in the cache.
         */
        if (pass) {

            test_num                   = 12;
            flush_flags                = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len         = 0;
            expected_index_size        = 0;
            spec[0].flush_ops[1].flag  = TRUE;
            spec[0].expected_destroyed = TRUE;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #13 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * dirties two entries that are not in cache.  No size
         * changes.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int                             test_num                 = 13;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = 1 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 3;
        size_t                          expected_index_size      = 3 * PICO_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[1]                  = {{/* entry_num          = */ 0,
                                                    /* entry_type         = */ 0,
                                                    /* entry_index        = */ 1,
                                                    /* insert_flag        = */ FALSE,
                                                    /* flags          = */ H5C__DIRTIED_FLAG,
                                                    /* resize_flag        = */ FALSE,
                                                    /* new_size           = */ 0,
                                                    /* num_pins           = */ 0,
                                                    /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* num_flush_ops      = */ 2,
                                                    /* flush_ops          = */
                                                    /*    op_code:        type:    idx:    flag:    size: */
                                                    {{FLUSH_OP__DIRTY, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__DIRTY, 0, 2, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
                                                    /* expected_loaded    = */ TRUE,
                                                    /* expected_cleared   = */ FALSE,
                                                    /* expected_flushed   = */ TRUE,
                                                    /* expected_destroyed = */ FALSE}};
        int                             check_size               = 2;
        struct fo_flush_entry_check     checks[2]                = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #14 */
    {
        /* Repeat previous test with the flush invalidate flag.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * dirties two entries that are not in cache.  No size
         * changes.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int                             test_num                 = 14;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = 1 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = (size_t)0;
        struct fo_flush_cache_test_spec spec[1]                  = {{/* entry_num          = */ 0,
                                                    /* entry_type         = */ 0,
                                                    /* entry_index        = */ 1,
                                                    /* insert_flag        = */ FALSE,
                                                    /* flags          = */ H5C__DIRTIED_FLAG,
                                                    /* resize_flag        = */ FALSE,
                                                    /* new_size           = */ 0,
                                                    /* num_pins           = */ 0,
                                                    /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
                                                    /* num_flush_ops      = */ 2,
                                                    /* flush_ops          = */
                                                    /*    op_code:        type:    idx:    flag:    size: */
                                                    {{FLUSH_OP__DIRTY, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__DIRTY, 0, 2, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
                                                     {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
                                                    /* expected_loaded    = */ TRUE,
                                                    /* expected_cleared   = */ FALSE,
                                                    /* expected_flushed   = */ TRUE,
                                                    /* expected_destroyed = */ TRUE}};
        int                             check_size               = 2;
        struct fo_flush_entry_check     checks[2]                = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ PICO_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ PICO_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #15 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes and dirties two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int          test_num                 = 15;
        unsigned int flush_flags              = H5C__NO_FLAGS_SET;
        int          spec_size                = 1;
        int          init_expected_index_len  = 1;
        size_t       init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        int          expected_index_len       = 3;
        size_t       expected_index_size =
            VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);
        struct fo_flush_cache_test_spec spec[1] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 2;
        struct fo_flush_entry_check checks[2]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #16 */
    {
        /* Repeat previous test with the flush invalidate flag.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes and dirties two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int                             test_num                 = 16;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 1;
        int                             init_expected_index_len  = 1;
        size_t                          init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = (size_t)0;
        struct fo_flush_cache_test_spec spec[1]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 2;
        struct fo_flush_entry_check checks[2]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #17 & #18 */
    {
        /* Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes, dirties, and moves two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int          test_num                 = 17; /* and 18 */
        unsigned int flush_flags              = H5C__NO_FLAGS_SET;
        int          spec_size                = 1;
        int          init_expected_index_len  = 1;
        size_t       init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        int          expected_index_len       = 3;
        size_t       expected_index_size =
            VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);
        struct fo_flush_cache_test_spec spec[1] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 2;
        struct fo_flush_entry_check checks[2]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the moves to move the target entries back to
         * their main address.  The first test moved them to their alternate
         * address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entries are moved forward in the slist.  In the second
         * they are moved backwards.
         */
        if (pass) {

            test_num                  = 18;
            spec[0].flush_ops[2].flag = TRUE;
            spec[0].flush_ops[5].flag = TRUE;
            checks[0].at_main_addr    = TRUE;
            checks[1].at_main_addr    = TRUE;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #19 & #20 */
    {
        /* Repeat the above test with the flush invalidate flag on the
         * second test.
         *
         * Test the ability of the cache to handle the case in which
         * the flush function of an entry that is resident in cache
         * resizes, dirties, and moves two entries that are not in cache.
         *
         * At present, I am assured that this case will never occur, but
         * lets make sure we can handle it regardless.
         */
        int          test_num                 = 19; /* and 20 */
        unsigned int flush_flags              = H5C__NO_FLAGS_SET;
        int          spec_size                = 1;
        int          init_expected_index_len  = 1;
        size_t       init_expected_index_size = 1 * VARIABLE_ENTRY_SIZE;
        int          expected_index_len       = 3;
        size_t       expected_index_size =
            VARIABLE_ENTRY_SIZE + (VARIABLE_ENTRY_SIZE / 4) + (VARIABLE_ENTRY_SIZE / 2);
        struct fo_flush_cache_test_spec spec[1] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 2;
        struct fo_flush_entry_check checks[2]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        /* this change forces the moves to move the target entries back to
         * their main address.  The first test moved them to their alternate
         * address.
         *
         * Note that these two tests are not the same, as in the first test,
         * the moved entries are moved forward in the slist.  In the second
         * they are moved backwards.
         */
        if (pass) {

            test_num                     = 20;
            flush_flags                  = H5C__FLUSH_INVALIDATE_FLAG;
            expected_index_len           = 0;
            expected_index_size          = (size_t)0;
            spec[0].expected_destroyed   = TRUE;
            spec[0].flush_ops[2].flag    = TRUE;
            spec[0].flush_ops[5].flag    = TRUE;
            checks[0].at_main_addr       = TRUE;
            checks[0].in_cache           = FALSE;
            checks[0].expected_destroyed = TRUE;
            checks[1].at_main_addr       = TRUE;
            checks[1].in_cache           = FALSE;
            checks[1].expected_destroyed = TRUE;

            check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                             init_expected_index_len, init_expected_index_size,
                                             expected_index_len, expected_index_size, check_size, checks);
        }
    }

    if (pass) /* test #21 */
    {
        /* Now mix things up a bit.
         *
         * Load several entries, two of which have flush functions that
         * resize, dirty, and move two entries that are not in the
         * cache.  Mark only one of these entries, and then flush the
         * cache with the flush marked entries flag.
         *
         * This is the only test in which we test the
         * H5C__FLUSH_MARKED_ENTRIES_FLAG.  The hope is that since
         * we test the two features extensively by themselves, so
         * it should be sufficient to verify that they play together
         * as expected.
         */
        int          test_num                 = 21;
        unsigned int flush_flags              = H5C__FLUSH_MARKED_ENTRIES_FLAG;
        int          spec_size                = 4;
        int          init_expected_index_len  = 4;
        size_t       init_expected_index_size = (2 * VARIABLE_ENTRY_SIZE) + (2 * PICO_ENTRY_SIZE);
        int          expected_index_len       = 6;
        size_t       expected_index_size      = (2 * VARIABLE_ENTRY_SIZE) + (VARIABLE_ENTRY_SIZE / 4) +
                                     (VARIABLE_ENTRY_SIZE / 2) + (2 * PICO_ENTRY_SIZE);
        struct fo_flush_cache_test_spec spec[4] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 11,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 10, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 12, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 4;
        struct fo_flush_entry_check checks[4]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ TRUE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ TRUE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 10,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 3,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 12,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
        reset_entries();
    }

    if (pass) /* test #22 */
    {
        /* Mix things up some more.
         *
         * Load lots of entries, some of which have flush functions that
         * resize, dirty, and move two entries that are not in the
         * cache.
         *
         * Also load entries that have flush ops on entries that are in
         * cache.
         */
        int          test_num                 = 22;
        unsigned int flush_flags              = H5C__NO_FLAGS_SET;
        int          spec_size                = 6;
        int          init_expected_index_len  = 6;
        size_t       init_expected_index_size = (2 * VARIABLE_ENTRY_SIZE) + (4 * PICO_ENTRY_SIZE);
        int          expected_index_len       = 10;
        size_t       expected_index_size      = (2 * VARIABLE_ENTRY_SIZE) + (2 * (VARIABLE_ENTRY_SIZE / 4)) +
                                     (2 * (VARIABLE_ENTRY_SIZE / 2)) + (4 * PICO_ENTRY_SIZE);
        struct fo_flush_cache_test_spec spec[6] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 11,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 10, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 12, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ FALSE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 4;
        struct fo_flush_entry_check checks[4]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 10,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 3,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 12,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
        reset_entries();
    }

    if (pass) /* test #23 */
    {
        /* Repeat test #23 with the flush invalidate flag set.
         *
         * Mix things up some more.
         *
         * Load lots of entries, some of which have flush functions that
         * resize, dirty, and move two entries that are not in the
         * cache.
         *
         * Also load entries that have flush ops on entries that are in
         * cache.
         */
        int          test_num                   = 23;
        unsigned int flush_flags                = H5C__FLUSH_INVALIDATE_FLAG;
        int          spec_size                  = 6;
        int          init_expected_index_len    = 6;
        size_t       init_expected_index_size   = (2 * VARIABLE_ENTRY_SIZE) + (4 * PICO_ENTRY_SIZE);
        int          expected_index_len         = 0;
        size_t       expected_index_size        = 0;
        struct fo_flush_cache_test_spec spec[6] = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 11,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 6,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 10, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 10, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 12, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 12, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 0,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 1,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 10,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 20,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 4;
        struct fo_flush_entry_check checks[4]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 10,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 4,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 3,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 12,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
        reset_entries();
    }

    /* So much for tests involving only flush operations.
     *
     * Now create some tests mixing flush ops and pins.
     */
    if (pass) /* test #24 */
    {
        /* Pico entries 50 and 150 pin pico entry 100, and also dirty
         * pico entry 100 on flush.
         */
        int                             test_num                 = 24;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 3;
        int                             init_expected_index_len  = 3;
        size_t                          init_expected_index_size = 3 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 3;
        size_t                          expected_index_size      = 3 * PICO_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[3]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 1,
             /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 150,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 1,
             /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__DIRTY, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #25 */
    {
        /* Repeat the previous test with the flush invalidate flag.
         *
         * Pico entries 50 and 150 pin pico entry 100, and also dirty
         * pico entry 100 on flush.
         */
        int                             test_num                 = 25;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 3;
        int                             init_expected_index_len  = 3;
        size_t                          init_expected_index_size = 3 * PICO_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = (size_t)0;
        struct fo_flush_cache_test_spec spec[3]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 50,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 1,
             /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ PICO_ENTRY_TYPE,
             /* entry_index        = */ 150,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 1,
             /* pin_type           = */ {PICO_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 1,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, PICO_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__DIRTY, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ (size_t)0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);
    }

    if (pass) /* test #26 */
    {
        /* This one is complex.
         *
         * In the following overvies table, VET stands for
         * VARIABLE_ENTRY_TYPE.
         *
         * In trying to follow what happens when we flush the
         * set of entries constructed below, recall that each
         * flush operation is executed the first time the
         * entry is flushed, and then not executed again.
         * This may be a weakness in the tests, but that
         * is the way it is for now.
         *
         * After thinking about it for a while, I'm not sure that
         * the interaction between pins and flush operations needs
         * all that much testing, as the two are essentially
         * orthoginal.  Thus this is a bit of a smoke check to
         * verify that we get the expected results.
         *
         * (VET, 100)    initially not resident in cache
         *
         * (VET, 200)    initially clean and resident in cache
         *
         * (VET, 300)    initially not resident in cache
         *
         * (VET, 2100)    initially clean and resident in cache
         *
         * (VET, 2200)    initially not resident in cache
         *
         * (VET, 2300)    initially clean and resident in cache
         *
         * (VET, 1000)    initially clean, and in cache
         *         dirties (VET, 100)
         *         resizes (VET, 200)
         *         dirty    (VET, 300) -- dirty first to bring into cache.
         *         moves (VET, 300)
         *
         * (VET, 2000)    initially clean, and in cache
         *         dirties (VET, 2100)
         *         resizes (VET, 2200)
         *         moves (VET, 2300)
         *
         * (VET, 350)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 350)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 450)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties    (VET, 1000)
         *         moves (VET, 450)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 650)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 650)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 750)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 750)
         *         pins    (VET, 2000)
         *         dirties    (VET, 2000)
         *
         * (VET, 500)    initially dirty, and in cache
         *         dirties    (VET, 350)
         *         dirties    (VET, 450)
         *         dirties    (VET, 650)
         *         dirties (VET, 750)
         */
        int                             test_num                 = 26;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 10;
        int                             init_expected_index_len  = 10;
        size_t                          init_expected_index_size = 10 * VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 13;
        size_t                          expected_index_size      = 9 * VARIABLE_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[10]                 = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 200,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2300,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1000,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2000,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2200, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 350,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 350, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 450,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 450, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 650,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 650, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 8,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 750,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 750, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 9,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 500,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 350, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 450, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 650, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 750, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 3;
        struct fo_flush_entry_check checks[3]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 100,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 300,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE},
                                                 {/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2200,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ TRUE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ FALSE}

        };

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #27 */
    {
        /* Repeat test #26 with the flush invalidate flag.
         *
         * In the following overview table, VET stands for
         * VARIABLE_ENTRY_TYPE.
         *
         * In trying to follow what happens when we flush the
         * set of entries constructed below, recall that each
         * flush operation is executed the first time the
         * entry is flushed, and then not executed again.
         * This may be a weakness in the tests, but that
         * is the way it is for now.
         *
         * After thinking about it for a while, I'm not sure that
         * the interaction between pins and flush operations needs
         * all that much testing, as the two are essentially
         * orthoginal.  The big thing is to verify that flushes of
         * pinned entries with flush ops result in the expected
         * updates of the cache.
         *
         * Thus this is a bit of a smoke check to * verify that we
         * get the expected results.
         *
         * (VET, 100)    initially not resident in cache
         *
         * (VET, 200)    initially clean and resident in cache
         *
         * (VET, 300)    initially not resident in cache
         *
         * (VET, 2100)    initially clean and resident in cache
         *
         * (VET, 2200)    initially not resident in cache
         *
         * (VET, 2300)    initially clean and resident in cache
         *
         * (VET, 1000)    initially clean, and in cache
         *         dirties (VET, 100)
         *         resizes (VET, 200)
         *         dirty    (VET, 300) -- dirty first to bring into cache.
         *         moves (VET, 300)
         *
         * (VET, 2000)    initially clean, and in cache
         *         dirties (VET, 2100)
         *         resizes (VET, 2200)
         *         moves (VET, 2300)
         *
         * (VET, 350)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 350)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 450)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties    (VET, 1000)
         *         moves (VET, 450)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 650)    initially clean, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 650)
         *         pins    (VET, 2000)
         *         dirties (VET, 2000)
         *
         * (VET, 750)    initially dirty, and in cache
         *         pins    (VET, 1000)
         *         dirties (VET, 1000)
         *         resizes (VET, 750)
         *         pins    (VET, 2000)
         *         dirties    (VET, 2000)
         *
         * (VET, 500)    initially dirty, and in cache
         *         dirties    (VET, 350)
         *         dirties    (VET, 450)
         *         dirties    (VET, 650)
         *         dirties (VET, 750)
         */
        int                             test_num                 = 27;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 10;
        int                             init_expected_index_len  = 10;
        size_t                          init_expected_index_size = 10 * VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = (size_t)0;
        struct fo_flush_cache_test_spec spec[10]                 = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 200,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2300,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 1000,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 2000,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 2200, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 2300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 5,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 350,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 350, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 6,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 450,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 450, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 7,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 650,
             /* insert_flag        = */ TRUE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 650, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ FALSE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 8,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 750,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 2,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {1000, 2000, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 1000, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 2000, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 750, FALSE, VARIABLE_ENTRY_SIZE / 4},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 9,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 500,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 4,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 350, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 450, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 650, FALSE, 0},
              {FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 750, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 3;
        struct fo_flush_entry_check checks[3]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 100,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 1,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 300,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE},
                                                 {/* entry_num          = */ 2,
                                                  /* entry_type         = */ VARIABLE_ENTRY_TYPE,
                                                  /* entry_index        = */ 2200,
                                                  /* expected_size      = */ VARIABLE_ENTRY_SIZE / 2,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ TRUE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ TRUE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ TRUE,
                                                  /* expected_destroyed = */ TRUE}

        };

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #28 */
    {
        /* Test the expected fheap case, in which an entry dirties
         * and resizes itself, and dirties an entry which it has
         * pinned.
         */
        int                             test_num                 = 28;
        unsigned int                    flush_flags              = H5C__NO_FLAGS_SET;
        int                             spec_size                = 5;
        int                             init_expected_index_len  = 5;
        size_t                          init_expected_index_size = 3 * VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 5;
        size_t                          expected_index_size      = 4 * VARIABLE_ENTRY_SIZE;
        struct fo_flush_cache_test_spec spec[5]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 200,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, FALSE, VARIABLE_ENTRY_SIZE},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 200, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 300,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {400, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 400, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 300, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 400,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 500,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 500, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 500, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ FALSE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ 0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    if (pass) /* test #29 */
    {
        /* Repeat test #28 with the flush invalidate flag.
         *
         * Test the expected fheap case, in which an entry dirties
         * and resizes itself, and dirties an entry which it has
         * pinned.
         */
        int                             test_num                 = 29;
        unsigned int                    flush_flags              = H5C__FLUSH_INVALIDATE_FLAG;
        int                             spec_size                = 5;
        int                             init_expected_index_len  = 5;
        size_t                          init_expected_index_size = 3 * VARIABLE_ENTRY_SIZE;
        int                             expected_index_len       = 0;
        size_t                          expected_index_size      = 0;
        struct fo_flush_cache_test_spec spec[5]                  = {
            {/* entry_num          = */ 0,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 100,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 1,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 200,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 2,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 200, FALSE, VARIABLE_ENTRY_SIZE},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 200, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 2,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 300,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {400, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 400, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 300, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 300, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 3,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 400,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__NO_FLAGS_SET,
             /* resize_flag        = */ FALSE,
             /* new_size           = */ 0,
             /* num_pins           = */ 0,
             /* pin_type           = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {0, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 0,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE},
            {/* entry_num          = */ 4,
             /* entry_type         = */ VARIABLE_ENTRY_TYPE,
             /* entry_index        = */ 500,
             /* insert_flag        = */ FALSE,
             /* flags          = */ H5C__DIRTIED_FLAG,
             /* resize_flag        = */ TRUE,
             /* new_size           = */ VARIABLE_ENTRY_SIZE / 4,
             /* num_pins           = */ 1,
             /* pin_type           = */ {VARIABLE_ENTRY_TYPE, 0, 0, 0, 0, 0, 0, 0},
             /* pin_idx            = */ {100, 0, 0, 0, 0, 0, 0, 0},
             /* num_flush_ops      = */ 3,
             /* flush_ops          = */
             /*    op_code:        type:    idx:    flag:    size: */
             {{FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 100, FALSE, 0},
              {FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 500, FALSE, VARIABLE_ENTRY_SIZE / 2},
              {FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 500, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0},
              {FLUSH_OP__NO_OP, 0, 0, FALSE, 0}},
             /* expected_loaded    = */ TRUE,
             /* expected_cleared   = */ FALSE,
             /* expected_flushed   = */ TRUE,
             /* expected_destroyed = */ TRUE}};
        int                         check_size = 0;
        struct fo_flush_entry_check checks[1]  = {{/* entry_num          = */ 0,
                                                  /* entry_type         = */ 0,
                                                  /* entry_index        = */ 0,
                                                  /* expected_size      = */ 0,
                                                  /* in_cache           = */ FALSE,
                                                  /* at_main_addr       = */ FALSE,
                                                  /* is_dirty              = */ FALSE,
                                                  /* is_protected       = */ FALSE,
                                                  /* is_pinned          = */ FALSE,
                                                  /* expected_loaded    = */ FALSE,
                                                  /* expected_cleared   = */ FALSE,
                                                  /* expected_flushed   = */ FALSE,
                                                  /* expected_destroyed = */ FALSE}};

        check_flush_cache__flush_op_test(file_ptr, test_num, flush_flags, spec_size, spec,
                                         init_expected_index_len, init_expected_index_size,
                                         expected_index_len, expected_index_size, check_size, checks);

        reset_entries();
    }

    /* finally finish up with the flush ops eviction test */
    check_flush_cache__flush_op_eviction_test(file_ptr);

    return;

} /* check_flush_cache__flush_ops() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_op_test()
 *
 * Purpose:    Run a flush op flush cache test.  Of the nature of
 *         flush operations, this is a multi-entry test.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              9/3/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_op_test(H5F_t *file_ptr, int test_num, unsigned int flush_flags, int spec_size,
                                 struct fo_flush_cache_test_spec spec[], int init_expected_index_len,
                                 size_t init_expected_index_size, int expected_index_len,
                                 size_t expected_index_size, int check_size,
                                 struct fo_flush_entry_check check[])
{
    const char *  fcn_name  = "check_flush_cache__flush_op_test";
    H5C_t *       cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    hbool_t       show_progress = FALSE;
    hbool_t       verbose       = FALSE;
    herr_t        result;
    int           i;
    int           j;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

#if 0 /* This is useful debugging code -- lets keep it around. */
    HDfprintf(stdout, "check_flush_cache__flush_op_test: test %d\n",
        test_num);
#endif

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: running sanity checks on entry(1).\n", fcn_name, test_num, (int)pass);
    }

    if (cache_ptr == NULL) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache_ptr NULL on entry to flush op test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = FALSE;

        HDsnprintf(msg, (size_t)128, "cache not empty at beginning of flush op test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((spec_size < 1) || (spec == NULL)) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "missing/bad test spec on entry to flush op test #%d.", test_num);
        failure_mssg = msg;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: running sanity checks on entry(2).\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if ((spec[i].entry_num != i) || (spec[i].entry_type < 0) ||
            (spec[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (spec[i].entry_index < 0) ||
            (spec[i].entry_index > max_indices[spec[i].entry_type]) || (spec[i].num_pins < 0) ||
            (spec[i].num_pins > MAX_PINS) || (spec[i].num_flush_ops < 0) ||
            (spec[i].num_flush_ops > MAX_FLUSH_OPS)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "bad data in spec[%d] on entry to flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: running sanity checks on entry(3).\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < check_size)) {
        if ((check[i].entry_num != i) || (check[i].entry_type < 0) ||
            (check[i].entry_type >= NUMBER_OF_ENTRY_TYPES) || (check[i].entry_index < 0) ||
            (check[i].entry_index > max_indices[check[i].entry_type]) ||
            (check[i].expected_size <= (size_t)0) ||
            ((check[i].in_cache != TRUE) && (check[i].in_cache != FALSE)) ||
            ((check[i].at_main_addr != TRUE) && (check[i].at_main_addr != FALSE)) ||
            ((check[i].is_dirty != TRUE) && (check[i].is_dirty != FALSE)) ||
            ((check[i].is_protected != TRUE) && (check[i].is_protected != FALSE)) ||
            ((check[i].is_pinned != TRUE) && (check[i].is_pinned != FALSE)) ||
            ((check[i].expected_loaded != TRUE) && (check[i].expected_loaded != FALSE)) ||
            ((check[i].expected_cleared != TRUE) && (check[i].expected_cleared != FALSE)) ||
            ((check[i].expected_flushed != TRUE) && (check[i].expected_flushed != FALSE)) ||
            ((check[i].expected_destroyed != TRUE) && (check[i].expected_destroyed != FALSE))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "bad data in check[%d] on entry to flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Setting up the test.\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        if (spec[i].insert_flag) {

            if (show_progress) {

                HDfprintf(stdout, "%s:%d: Inserting entry(%d,%d) with flags 0x%x.\n", fcn_name, test_num,
                          (int)(spec[i].entry_type), (int)(spec[i].entry_index), (unsigned)spec[i].flags);
            }

            insert_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }
        else {

            if (show_progress) {

                HDfprintf(stdout, "%s:%d: Protecting entry(%d,%d).\n", fcn_name, test_num,
                          (int)(spec[i].entry_type), (int)(spec[i].entry_index));
            }

            protect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index);

            if (show_progress) {

                HDfprintf(stdout, "%s:%d: Unprotecting entry(%d,%d) with flags 0x%x ns = %d.\n", fcn_name,
                          test_num, (int)(spec[i].entry_type), (int)(spec[i].entry_index),
                          (unsigned)spec[i].flags, (int)(spec[i].new_size));
            }

            if (spec[i].resize_flag)
                resize_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].new_size, TRUE);

            unprotect_entry(file_ptr, spec[i].entry_type, spec[i].entry_index, spec[i].flags);
        }

        for (j = 0; j < spec[i].num_pins; j++) {
            create_pinned_entry_dependency(file_ptr, spec[i].entry_type, spec[i].entry_index,
                                           spec[i].pin_type[j], spec[i].pin_idx[j]);
        }

        for (j = 0; j < spec[i].num_flush_ops; j++) {
            add_flush_op(spec[i].entry_type, spec[i].entry_index, spec[i].flush_ops[j].op_code,
                         spec[i].flush_ops[j].type, spec[i].flush_ops[j].idx, spec[i].flush_ops[j].flag,
                         spec[i].flush_ops[j].size);
        }

        i++;
    }

    if (pass) {

        if ((cache_ptr->index_len != init_expected_index_len) ||
            (cache_ptr->index_size != init_expected_index_size)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size before flush in flush op test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Running the test.\n", fcn_name, test_num, (int)pass);
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, flush_flags);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "flush with flags 0x%x failed in flush op test #%d.", flush_flags,
                       test_num);
            failure_mssg = msg;
        }
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Checking test results(1).\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        if ((entry_ptr->loaded != spec[i].expected_loaded) ||
            (entry_ptr->cleared != spec[i].expected_cleared) ||
            (entry_ptr->flushed != spec[i].expected_flushed) ||
            (entry_ptr->destroyed != spec[i].expected_destroyed)) {

#if 0 /* This is useful debugging code.  Lets keep it around. */

            HDfprintf(stdout,
              "loaded = %d(%d), clrd = %d(%d), flshd = %d(%d), dest = %d(%d)\n",
              (int)(entry_ptr->loaded),
              (int)(spec[i].expected_loaded),
              (int)(entry_ptr->cleared),
              (int)(spec[i].expected_cleared),
              (int)(entry_ptr->flushed),
              (int)(spec[i].expected_flushed),
              (int)(entry_ptr->destroyed),
              (int)(spec[i].expected_destroyed));

        HDfprintf(stdout, "entry_ptr->header.is_dirty = %d\n",
            (int)(entry_ptr->header.is_dirty));
#endif

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Bad status on entry %d after flush op test #%d.", i, test_num);
            failure_mssg = msg;
        }
        i++;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Checking test results(2).\n", fcn_name, test_num, (int)pass);
    }

    if (pass) {

        i = 0;
        while ((pass) && (i < check_size)) {
            if (check[i].in_cache != entry_in_cache(cache_ptr, check[i].entry_type, check[i].entry_index)) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "Check1 failed on entry %d after flush op test #%d.", i,
                           test_num);
                failure_mssg = msg;
            }

            base_addr = entries[check[i].entry_type];
            entry_ptr = &(base_addr[check[i].entry_index]);

            if ((entry_ptr->size != check[i].expected_size) ||
                ((!entry_ptr->header.destroy_in_progress) && (check[i].in_cache) &&
                 (entry_ptr->header.size != check[i].expected_size)) ||
                (entry_ptr->at_main_addr != check[i].at_main_addr) ||
                (entry_ptr->is_dirty != check[i].is_dirty) ||
                (entry_ptr->header.is_dirty != check[i].is_dirty) ||
                (entry_ptr->is_protected != check[i].is_protected) ||
                (entry_ptr->header.is_protected != check[i].is_protected) ||
                (entry_ptr->is_pinned != check[i].is_pinned) ||
                (entry_ptr->header.is_pinned != check[i].is_pinned) ||
                (entry_ptr->loaded != check[i].expected_loaded) ||
                (entry_ptr->cleared != check[i].expected_cleared) ||
                (entry_ptr->flushed != check[i].expected_flushed) ||
                (entry_ptr->destroyed != check[i].expected_destroyed)) {

#if 0 /* This is useful debugging code.  Lets keep it around for a while. */

        if ( entry_ptr->size != check[i].expected_size ) {
            HDfprintf(stdout, "entry_ptr->size (expected) = %d (%d).\n",
                (int)(entry_ptr->size),
                (int)(check[i].expected_size));
        }
        if ( ( ! entry_ptr->header.destroy_in_progress ) &&
            ( check[i].in_cache ) &&
                     ( entry_ptr->header.size != check[i].expected_size ) ) {
                    HDfprintf(stdout,
                              "(!destroy in progress and in cache and size (expected) = %d (%d).\n",
                              (int)(entry_ptr->header.size),
                (int)(check[i].expected_size));
        }
        if ( entry_ptr->at_main_addr != check[i].at_main_addr ) {
            HDfprintf(stdout, "(%d,%d) at main addr (expected) = %d (%d).\n",
                (int)(check[i].entry_type),
                (int)(check[i].entry_index),
                              (int)(entry_ptr->at_main_addr),
                (int)(check[i].at_main_addr));
                }
        if ( entry_ptr->is_dirty != check[i].is_dirty ) {
            HDfprintf(stdout, "entry_ptr->is_dirty (expected) = %d (%d).\n",
                    (int)(entry_ptr->is_dirty),
                (int)(check[i].is_dirty));
        }
        if ( entry_ptr->header.is_dirty != check[i].is_dirty ) {
            HDfprintf(stdout, "entry_ptr->header.is_dirty (expected) = %d (%d).\n",
                    (int)(entry_ptr->header.is_dirty),
                (int)(check[i].is_dirty));
        }
            if ( entry_ptr->is_protected != check[i].is_protected ) {
                    HDfprintf(stdout, "entry_ptr->is_protected (expected) = %d (%d).\n",
                (int)(entry_ptr->is_protected),
                (int)(check[i].is_protected));
        }
            if ( entry_ptr->header.is_protected != check[i].is_protected ) {
                    HDfprintf(stdout, "entry_ptr->header.is_protected (expected) = %d (%d).\n",
                (int)(entry_ptr->is_protected),
                (int)(check[i].is_protected));
        }
        if ( entry_ptr->is_pinned != check[i].is_pinned ) {
            HDfprintf(stdout, "entry_ptr->is_pinned (expected) = %d (%d).\n",
                (int)(entry_ptr->is_pinned),
                (int)(check[i].is_pinned));
        }
        if ( entry_ptr->header.is_pinned != check[i].is_pinned ) {
            HDfprintf(stdout, "entry_ptr->header.is_pinned (expected) = %d (%d).\n",
                (int)(entry_ptr->header.is_pinned),
                (int)(check[i].is_pinned));
        }
        if ( entry_ptr->loaded != check[i].expected_loaded ) {
            HDfprintf(stdout, "entry_ptr->loaded (expected) = %d (%d).\n",
                (int)(entry_ptr->loaded),
                (int)(check[i].expected_loaded));
        }
        if ( entry_ptr->cleared != check[i].expected_cleared ) {
            HDfprintf(stdout, "entry_ptr->cleared (expected) = %d (%d).\n",
                (int)(entry_ptr->cleared),
                (int)(check[i].expected_cleared));
        }
        if ( entry_ptr->flushed != check[i].expected_flushed ) {
            HDfprintf(stdout, "entry_ptr->flushed (expected) = %d (%d).\n",
                (int)(entry_ptr->flushed),
                (int)(check[i].expected_flushed));
        }
        if ( entry_ptr->destroyed != check[i].expected_destroyed ) {
            HDfprintf(stdout, "entry_ptr->destroyed (expected) = %d (%d).\n",
                (int)(entry_ptr->destroyed),
                (int)(check[i].expected_destroyed));
        }
#endif
                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "Check2 failed on entry %d after flush op test #%d.", i,
                           test_num);
                failure_mssg = msg;
            }
            i++;
        }
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Checking test results(3).\n", fcn_name, test_num, (int)pass);
    }

    if (pass) {

        if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
             ((cache_ptr->index_len != expected_index_len) ||
              (cache_ptr->index_size != expected_index_size))) ||
            (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
             ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after flush in flush op test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Cleaning up after test(1).\n", fcn_name, test_num, (int)pass);
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Flush failed on cleanup in flush op test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) ||
                 (cache_ptr->clean_index_size != 0) || (cache_ptr->dirty_index_size != 0)) {

            pass = FALSE;

            if (verbose) {

                HDfprintf(stdout, "%s:%d: il/is/cis/dis = %lld/%lld/%lld/%lld.\n", fcn_name, test_num,
                          (long long)(cache_ptr->index_len), (long long)(cache_ptr->index_size),
                          (long long)(cache_ptr->clean_index_size), (long long)(cache_ptr->dirty_index_size));
            }
            HDsnprintf(msg, (size_t)128,
                       "Unexpected cache len/size/cs/ds after cleanup in flush op test #%d.", test_num);
            failure_mssg = msg;
        }
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Cleaning up after test(2).\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < spec_size)) {
        base_addr = entries[spec[i].entry_type];
        entry_ptr = &(base_addr[spec[i].entry_index]);

        entry_ptr->size = entry_sizes[spec[i].entry_type];

        entry_ptr->loaded    = FALSE;
        entry_ptr->cleared   = FALSE;
        entry_ptr->flushed   = FALSE;
        entry_ptr->destroyed = FALSE;

        i++;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Cleaning up after test(3).\n", fcn_name, test_num, (int)pass);
    }

    i = 0;
    while ((pass) && (i < check_size)) {
        base_addr = entries[check[i].entry_type];
        entry_ptr = &(base_addr[check[i].entry_index]);

        entry_ptr->size = entry_sizes[check[i].entry_type];

        entry_ptr->loaded    = FALSE;
        entry_ptr->cleared   = FALSE;
        entry_ptr->flushed   = FALSE;
        entry_ptr->destroyed = FALSE;

        i++;
    }

    if (show_progress) {

        HDfprintf(stdout, "%s:%d:%d: Done.\n", fcn_name, test_num, (int)pass);
    }

    return;

} /* check_flush_cache__flush_op_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__flush_op_eviction_test()
 *
 * Purpose:    Verify that flush operations work as expected when an
 *              entry is evicted.
 *
 *              Do nothing if pass is FALSE on entry.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/3/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__flush_op_eviction_test(H5F_t *file_ptr)
{
    /* const char *   fcn_name = "check_flush_cache__flush_op_eviction_test"; */
    H5C_t *                      cache_ptr = file_ptr->shared->cache;
    int                          i;
    int                          num_variable_entries = 8;
    int                          num_monster_entries  = 31;
    int                          num_large_entries    = 0;
    herr_t                       result;
    test_entry_t *               entry_ptr;
    test_entry_t *               base_addr;
    struct expected_entry_status expected[8 + 31 + 14] = {
        /* the expected array is used to maintain a table of the expected status of every
         * entry used in this test.  Note that since the function that processes this
         * array only processes as much of it as it is told to, we don't have to
         * worry about maintaining the status of entries that we haven't used yet.
         */
        /* entry            entry                in    at main */
        /* type:            index:    size:            cache:    addr:    dirty:    prot:    pinned: loaded:
           clrd:    flshd:    dest: */
        {VARIABLE_ENTRY_TYPE, 0, VARIABLE_ENTRY_SIZE / 2, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 1, VARIABLE_ENTRY_SIZE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 2, VARIABLE_ENTRY_SIZE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 3, VARIABLE_ENTRY_SIZE / 2, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 4, VARIABLE_ENTRY_SIZE / 2, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 5, VARIABLE_ENTRY_SIZE / 2, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 6, VARIABLE_ENTRY_SIZE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {VARIABLE_ENTRY_TYPE, 7, VARIABLE_ENTRY_SIZE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 0, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 1, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 2, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 3, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 4, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 5, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 6, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 7, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 8, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 9, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 10, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 11, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 12, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 13, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 14, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 15, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 16, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 17, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 18, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 19, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 20, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 21, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 22, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 23, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 24, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 25, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 26, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 27, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 28, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 29, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {MONSTER_ENTRY_TYPE, 30, MONSTER_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE,
         FALSE},
        {LARGE_ENTRY_TYPE, 0, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 1, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 2, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 3, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 4, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 5, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 6, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 7, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 8, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 9, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 10, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 11, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 12, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE},
        {LARGE_ENTRY_TYPE, 13, LARGE_ENTRY_SIZE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE}};

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "cache_ptr NULL on entry to flush ops test.";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = FALSE;
            failure_mssg = "cache not empty at start of flush ops eviction test.";
        }
        else if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
                 (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "unexpected cache config at start of flush op eviction test.";
        }
        else {

            /* set min clean size to zero for this test as it simplifies
             * computing the expected cache size after each operation.
             */

            cache_ptr->min_clean_size = 0;
        }
    }

    if (pass) {

        /* the basic idea in this test is to insert a bunch of entries
         * with flush operations associated with them, and then load
         * other entries into the cache until the cache is full.  At
         * that point, load yet more entries into the cache, and see
         * if the flush operations are performed as expected.
         *
         * To make things a bit more interesting, we also include a
         * couple of pins.
         */

        /* reset the stats before we start.  If stats are enabled, we will
         * check to see if they are as expected at the end.
         */
        H5C_stats__reset(cache_ptr);

        /* load a few entries with pin relationships and flush ops.
         * Start by just loading the entries.
         */

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0, (VARIABLE_ENTRY_SIZE / 2), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 0, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3, (VARIABLE_ENTRY_SIZE / 2), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 3, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 4);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 4, (VARIABLE_ENTRY_SIZE / 2), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 4, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5, (VARIABLE_ENTRY_SIZE / 2), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 5, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 6);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 6, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 7);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 7, H5C__NO_FLAGS_SET);

        if ((cache_ptr->index_len != 8) ||
            (cache_ptr->index_size != (4 * (VARIABLE_ENTRY_SIZE / 2)) + (4 * VARIABLE_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 1.";
        }
    }

    if (pass) {

        /* Now set up the pinning relationships:
         *
         * Briefly, (VET, 0) is pinned by (VET, 1), (VET, 2), and (VET, 3)
         *          (VET, 7) is pinned by (VET, 3), and (VET, 5)
         */
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 1, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 2, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 3, VARIABLE_ENTRY_TYPE, 0);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 3, VARIABLE_ENTRY_TYPE, 7);
        create_pinned_entry_dependency(file_ptr, VARIABLE_ENTRY_TYPE, 5, VARIABLE_ENTRY_TYPE, 7);

        /* Next, set up the flush operations:
         *
         * Briefly, (VET, 1) dirties (VET, 0)
         *                   resizes (VET, 0) to 3/4 VARIABLE_ENTRY_SIZE
         *
         *          (VET, 2) dirties (VET, 0)
         *                   resizes (VET, 0) to VARIABLE_ENTRY_SIZE
         *                   moves (VET, 0) to its alternate address
         *
         *          (VET, 3) dirties (VET, 0)
         *                   resizes itself to VARIABLE_ENTRY_SIZE
         *
         *          (VET, 7) dirties (VET, 6)
         */
        add_flush_op(VARIABLE_ENTRY_TYPE, 1, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, (size_t)0);
        add_flush_op(VARIABLE_ENTRY_TYPE, 1, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, TRUE,
                     3 * VARIABLE_ENTRY_SIZE / 4);

        add_flush_op(VARIABLE_ENTRY_TYPE, 2, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, (size_t)0);
        add_flush_op(VARIABLE_ENTRY_TYPE, 2, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 0, TRUE,
                     VARIABLE_ENTRY_SIZE);
        add_flush_op(VARIABLE_ENTRY_TYPE, 2, FLUSH_OP__MOVE, VARIABLE_ENTRY_TYPE, 0, FALSE, (size_t)0);

        add_flush_op(VARIABLE_ENTRY_TYPE, 3, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 0, FALSE, (size_t)0);
        add_flush_op(VARIABLE_ENTRY_TYPE, 3, FLUSH_OP__RESIZE, VARIABLE_ENTRY_TYPE, 3, TRUE,
                     VARIABLE_ENTRY_SIZE);

        add_flush_op(VARIABLE_ENTRY_TYPE, 7, FLUSH_OP__DIRTY, VARIABLE_ENTRY_TYPE, 6, FALSE, (size_t)0);
    }

    if (pass) {

        /* to summarize, at present the following variable size entries
         * are in cache with the following characteristics:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y     5 KB    Y    Y    -    -
         *
         * (VET, 1)    Y    10 KB    N    N    0    dirty (VET, 0),
         *                             resize (VET, 0) to 7.5 KB
         *
         * (VET, 2)    Y    10 KB    N    N    0    dirty (VET, 0)
         *                             resize (VET, 0) to 10 KB
         *                             move (VET, 0) to its alternate address
         *
         * (VET, 3)    Y     5 KB    Y    N    0, 7    dirty (VET, 0)
         *                             resize (VET, 3) to 10 KB
         *
         * (VET, 4)    Y     5 KB    Y    N    -    -
         *
         * (VET, 5)    Y     5 KB    Y    N    7    -
         *
         * (VET, 6)    Y    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    N    Y    -    dirty (VET, 6)
         *
         * Recall that in this test bed, flush operations are excuted the
         * first time the associated entry is flushed, and are then
         * deleted.
         */

        /* Now fill up the cache with other, unrelated entries */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 1; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* The cache should now be exactly full */
        if ((cache_ptr->index_len != 40) || (cache_ptr->index_size != 2 * 1024 * 1024) ||
            (cache_ptr->index_size != ((4 * VARIABLE_ENTRY_SIZE / 2) + (4 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (1 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 2.";
        }
        else {

            /* verify the expected status of all entries we have loaded to date: */
            num_large_entries = 1;
            verify_entry_status(cache_ptr, 0,
                                (num_variable_entries + num_monster_entries + num_large_entries), expected);
        }
    }

    if (pass) {

        /* Now load a large entry.  This should result in the eviction
         * of (VET,1), and the increase in the size of (VET, 0) from .5
         * VARIABLE_ENTRY_SIZE to .75 VARIABLE_ENTRY_SIZE.
         *
         * The following table illustrates the intended state of affairs
         * after the eviction:
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    7.5 KB    Y    Y    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    Y    10 KB    N    N    0    dirty (VET, 0)
         *                             resize (VET, 0) to 10 KB
         *                             move (VET, 0) to its alternate address
         *
         * (VET, 3)    Y     5 KB    Y    N    0, 7    dirty (VET, 0)
         *                             resize (VET, 3) to 10 KB
         *
         * (VET, 4)    Y     5 KB    Y    N    -    -
         *
         * (VET, 5)    Y     5 KB    Y    N    7    -
         *
         * (VET, 6)    Y    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    Y    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */
        expected[0].size      = 3 * VARIABLE_ENTRY_SIZE / 4;
        expected[1].in_cache  = FALSE;
        expected[1].flushed   = TRUE;
        expected[1].destroyed = TRUE;

        num_large_entries = 2;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);

        if ((cache_ptr->index_len != 40) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (VARIABLE_ENTRY_SIZE) + (VARIABLE_ENTRY_SIZE / 4) + (LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((1 * 3 * VARIABLE_ENTRY_SIZE / 4) + (3 * VARIABLE_ENTRY_SIZE / 2) + (3 * VARIABLE_ENTRY_SIZE) +
              (31 * MONSTER_ENTRY_SIZE) + (2 * LARGE_ENTRY_SIZE)))) {
            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 3.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 1, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Now load another large entry.  This should result in the eviction
         * of (VET, 2), the increase in the size of (VET, 0) from .75
         * VARIABLE_ENTRY_SIZE to 1.0 VARIABLE_ENTRY_SIZE, and the moving
         * of (VET, 0) to its alternate address.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    Y    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    Y     5 KB    Y    N    0, 7    dirty (VET, 0)
         *                             resize (VET, 3) to 10 KB
         *
         * (VET, 4)    Y     5 KB    Y    N    -    -
         *
         * (VET, 5)    Y     5 KB    Y    N    7    -
         *
         * (VET, 6)    Y    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    Y    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */
        expected[0].size         = VARIABLE_ENTRY_SIZE;
        expected[0].at_main_addr = FALSE;
        expected[2].in_cache     = FALSE;
        expected[2].flushed      = TRUE;
        expected[2].destroyed    = TRUE;

        num_large_entries = 3;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__DIRTIED_FLAG);

        if ((cache_ptr->index_len != 40) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (2 * VARIABLE_ENTRY_SIZE) +
                                          (VARIABLE_ENTRY_SIZE / 2) + (2 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((3 * VARIABLE_ENTRY_SIZE / 2) + (3 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (3 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 4.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 2, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load two more large entries.  This should result in (VET, 3) being
         * flushed, and increasing its size from 1/2 VARIABLE_ENTRY_SIZE to
         * VARIABLE_ENTRY_SIZE.
         *
         * As a result of this size increase, the cache will have to look
         * for another entry to evict.  After flushing (VET, 4) and (VET, 5),
         * it should evict (VET, 6), yielding the needed memory.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    Y    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    Y    10 KB    N    N    0, 7    -
         *
         * (VET, 4)    Y     5 KB    N    N    -    -
         *
         * (VET, 5)    Y     5 KB    N    N    7    -
         *
         * (VET, 6)    N    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    Y    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[3].size      = VARIABLE_ENTRY_SIZE;
        expected[3].is_dirty  = FALSE;
        expected[3].flushed   = TRUE;
        expected[4].is_dirty  = FALSE;
        expected[4].flushed   = TRUE;
        expected[5].is_dirty  = FALSE;
        expected[5].flushed   = TRUE;
        expected[6].in_cache  = FALSE;
        expected[6].flushed   = TRUE;
        expected[6].destroyed = TRUE;

        num_large_entries = 5;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 4);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 4, H5C__DIRTIED_FLAG);

        /* verify cache size */
        if ((cache_ptr->index_len != 41) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) +
                 (1 * VARIABLE_ENTRY_SIZE) + /* size increases of (VET, 0) & (VET, 3) */
                 (4 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((2 * VARIABLE_ENTRY_SIZE / 2) + (3 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (5 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 5.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 3, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* now touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to bring all the VARIABLE_ENTRY_TYPE entries to the
         * end of the LRU list.
         *
         * Note that we don't have to worry about (VET, 0) and (VET, 7)
         * as they are pinned and thus not in the LRU list to begin with.
         */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 5; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 41) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (2 * VARIABLE_ENTRY_SIZE) + (4 * LARGE_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 6.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 4, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Now load three more large entries.  This should result
         * in the eviction of (VET, 3), and the unpinning of (VET, 0)
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    10 KB    N    N    -    -
         *
         * (VET, 4)    Y     5 KB    N    N    -    -
         *
         * (VET, 5)    Y     5 KB    N    N    7    -
         *
         * (VET, 6)    N    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    Y    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[0].is_pinned = FALSE;
        expected[3].in_cache  = FALSE;
        expected[3].destroyed = TRUE;

        num_large_entries = 8;

        for (i = 5; i < 8; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) + (7 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((2 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (8 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 7.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 5, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load another large entry.  (VET, 4) should be evicted.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    10 KB    N    N    -    -
         *
         * (VET, 4)    N     5 KB    N    N    -    -
         *
         * (VET, 5)    Y     5 KB    N    N    7    -
         *
         * (VET, 6)    N    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    Y    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[4].in_cache  = FALSE;
        expected[4].destroyed = TRUE;

        num_large_entries = 9;

        for (i = 8; i < 9; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size != (2 * 1024 * 1024) - (3 * VARIABLE_ENTRY_SIZE) -
                                          (VARIABLE_ENTRY_SIZE / 2) + (8 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((1 * VARIABLE_ENTRY_SIZE / 2) + (2 * VARIABLE_ENTRY_SIZE) +
                                       (31 * MONSTER_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 8.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 6, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Load another large entry.
         *
         * (VET, 5) should be evicted, and (VET, 7) should be unpinned.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     Y    10 KB    Y    N    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    10 KB    N    N    -    -
         *
         * (VET, 4)    N     5 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N    10 KB    N    N    -    -
         *
         * (VET, 7)    Y    10 KB    Y    N    -    dirty (VET, 6)
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[5].in_cache  = FALSE;
        expected[5].destroyed = TRUE;
        expected[7].is_pinned = FALSE;

        num_large_entries = 10;

        for (i = 9; i < 10; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (4 * VARIABLE_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (10 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 9.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 7, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Again, touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to bring all the VARIABLE_ENTRY_TYPE entries to the
         * end of the LRU list.
         *
         * Both (VET, 0) and (VET, 7) have been unpinned, so they are
         * now in the LRU list.
         */
        for (i = 0; i < 31; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < 10; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 43) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (4 * VARIABLE_ENTRY_SIZE) + (9 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((2 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (10 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 10.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 8, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* load two more large entries.
         *
         * (VET, 0) should be flushed, but not evicted initially since it is dirty.
         *
         * (VET, 7) should be evicted, but (VET, 7) has an eviction operation that
         * dirties (VET, 6).  Since (VET, 6) is not in the cache, it will be loaded.
         * Since this results in no net increase in free space, the cache will
         * continue to attempt to create free space.
         *
         * The cache will then flush all the monster and large entries, but since they
         * are all dirty, they will not be evicted.
         *
         * Finally, it will reach (VET, 0) again, and evict it on the second pass.
         * This finally makes the necessary space.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     N    10 KB    N    N    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    10 KB    N    N    -    -
         *
         * (VET, 4)    N     5 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    Y    10 KB    Y    N    -    -
         *
         * (VET, 7)    N    10 KB    N    N    -    -
         *
         * Start by updating the expected table for the expected changes in entry status:
         *
         * Note that we reset the loaded, cleared, flushed, and destroyed fields of
         * (VET,6) so we can track what is happening.
         */
        base_addr            = entries[VARIABLE_ENTRY_TYPE];
        entry_ptr            = &(base_addr[6]);
        entry_ptr->loaded    = FALSE;
        entry_ptr->cleared   = FALSE;
        entry_ptr->flushed   = FALSE;
        entry_ptr->destroyed = FALSE;

        expected[0].in_cache  = FALSE;
        expected[0].is_dirty  = FALSE;
        expected[0].flushed   = TRUE;
        expected[0].destroyed = TRUE;
        expected[6].in_cache  = TRUE;
        expected[6].is_dirty  = TRUE;
        expected[6].loaded    = TRUE;
        expected[6].flushed   = FALSE;
        expected[6].destroyed = FALSE;
        expected[7].in_cache  = FALSE;
        expected[7].flushed   = TRUE;
        expected[7].destroyed = TRUE;

        num_large_entries = 12;

        /* a newly loaded entry is not inserted in the cache until after
         * space has been made for it.  Thus (LET, 11) will not be flushed.
         */
        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty = FALSE;
            expected[i].flushed  = TRUE;
        }

        for (i = 10; i < 12; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size  */
        if ((cache_ptr->index_len != 44) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (5 * VARIABLE_ENTRY_SIZE) + (11 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((1 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (12 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 11.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 9, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Again, touch all the non VARIABLE_ENTRY_TYPE entries in the
         * cache to bring the last remaining VARIABLE_ENTRY_TYPE entry to the
         * end of the LRU list.
         */
        for (i = 0; i < num_monster_entries; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        for (i = 0; i < num_large_entries; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* update the expected array to mark all these entries dirty again. */
        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty = TRUE;
        }

        /* verify cache size */
        if ((cache_ptr->index_len != 44) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (5 * VARIABLE_ENTRY_SIZE) + (11 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size !=
             ((1 * VARIABLE_ENTRY_SIZE) + (31 * MONSTER_ENTRY_SIZE) + (12 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 12.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 10, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    if (pass) {

        /* Load two more large entries.
         *
         * Since (VET, 6) is dirty, at first this will just cause (VET, 6) to be flushed.
         *
         * But all other entries in the cache are dirty, so the cache will flush them all,
         * and then evict (VET, 6) on the second pass.
         *
         * The following table shows the expected states of the variable
         * size entries after the test.
         *
         *         in
         * entry:    cache?    size:    dirty?    pinned?    pins:    flush operations:
         *
         * (VET, 0)     N    10 KB    N    N    -    -
         *
         * (VET, 1)    N    10 KB    N    N    -    -
         *
         * (VET, 2)    N    10 KB    N    N    -    -
         *
         * (VET, 3)    N    10 KB    N    N    -    -
         *
         * (VET, 4)    N     5 KB    N    N    -    -
         *
         * (VET, 5)    N     5 KB    N    N    -    -
         *
         * (VET, 6)    N    10 KB    N    N    -    -
         *
         * (VET, 7)    N    10 KB    N    N    -    -
         *
         * Start by updating the expected table for the expected changes in entry status:
         */

        expected[6].in_cache  = FALSE;
        expected[6].is_dirty  = FALSE;
        expected[6].flushed   = TRUE;
        expected[6].destroyed = TRUE;

        num_large_entries = 14;

        /* a newly loaded entry is not inserted in the cache until after
         * space has been made for it.  Thus (LET, 13) will not be flushed.
         */
        for (i = num_variable_entries; i < num_variable_entries + num_monster_entries + num_large_entries - 1;
             i++) {
            expected[i].is_dirty = FALSE;
            expected[i].flushed  = TRUE;
        }

        for (i = 12; i < 14; i++) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__DIRTIED_FLAG);
        }

        /* verify cache size  */
        if ((cache_ptr->index_len != 45) ||
            (cache_ptr->index_size !=
             (2 * 1024 * 1024) - (6 * VARIABLE_ENTRY_SIZE) + (13 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->index_size != ((31 * MONSTER_ENTRY_SIZE) + (14 * LARGE_ENTRY_SIZE)))) {

            pass         = FALSE;
            failure_mssg = "unexpected size/len in flush op eviction test 13.";
        }

        /* verify entry status */
        verify_entry_status(cache_ptr, 11, (num_variable_entries + num_monster_entries + num_large_entries),
                            expected);
    }

    /* at this point we have cycled all the variable size entries through
     * the cache.
     *
     * flush the cache and end the test.
     */

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "Cache flush invalidate failed after flush op eviction test";
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache len/size after cleanup of flush op eviction test";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    /* If we are collecting stats, check to see if we get the expected
     * values.
     *
     * Testing the stats code is fairly new, but given the extent
     * to which I find myself depending on the stats, I've decided
     * to start testing the stats whenever it is convenient to do
     * so.
     */
    if (pass) {

        if ((cache_ptr->insertions[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->flushes[VARIABLE_ENTRY_TYPE] != 14) ||
            (cache_ptr->evictions[VARIABLE_ENTRY_TYPE] != 9) ||
            (cache_ptr->moves[VARIABLE_ENTRY_TYPE] != 1) ||
            (cache_ptr->entry_flush_moves[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[VARIABLE_ENTRY_TYPE] != 2) || (cache_ptr->unpins[VARIABLE_ENTRY_TYPE] != 2) ||
            (cache_ptr->dirty_pins[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[VARIABLE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[VARIABLE_ENTRY_TYPE] != 3) ||
            (cache_ptr->size_decreases[VARIABLE_ENTRY_TYPE] != 4) ||
            (cache_ptr->entry_flush_size_changes[VARIABLE_ENTRY_TYPE] != 1) ||
            (cache_ptr->cache_flush_size_changes[VARIABLE_ENTRY_TYPE] != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected variable size entry stats.";
        }
    }

    if (pass) {

        if ((cache_ptr->insertions[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[LARGE_ENTRY_TYPE] != 0) || (cache_ptr->flushes[LARGE_ENTRY_TYPE] != 38) ||
            (cache_ptr->evictions[LARGE_ENTRY_TYPE] != 14) || (cache_ptr->moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[LARGE_ENTRY_TYPE] != 0) || (cache_ptr->unpins[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[LARGE_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[LARGE_ENTRY_TYPE] != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected monster entry stats.";
        }
    }

    if (pass) {

        if ((cache_ptr->insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_insertions[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->clears[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->flushes[MONSTER_ENTRY_TYPE] != 93) ||
            (cache_ptr->evictions[MONSTER_ENTRY_TYPE] != 31) || (cache_ptr->moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_moves[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pins[MONSTER_ENTRY_TYPE] != 0) || (cache_ptr->unpins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->dirty_pins[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_flushes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->pinned_clears[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_increases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->size_decreases[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->entry_flush_size_changes[MONSTER_ENTRY_TYPE] != 0) ||
            (cache_ptr->cache_flush_size_changes[MONSTER_ENTRY_TYPE] != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected monster entry stats.";
        }
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {

        reset_entries();
    }

    return;

} /* check_flush_cache__flush_op_eviction_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__single_entry()
 *
 * Purpose:    Verify that flush_cache behaves as expected when the cache
 *        contains only one element.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/12/05
 *
 * Modifications:
 *
 *         JRM -- 3/29/06
 *         Added tests for pinned entries.
 *
 *         JRM -- 5/17/06
 *         Complete reqrite of pinned entry tests to accomodate
 *         the new H5C_mark_entry_dirty() call.
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__single_entry(H5F_t *file_ptr)
{
    const char *fcn_name      = "check_flush_cache__single_entry";
    hbool_t     show_progress = FALSE;
    H5C_t *     cache_ptr     = file_ptr->shared->cache;

    if (cache_ptr == NULL) {

        pass         = FALSE;
        failure_mssg = "cache_ptr NULL on entry to single entry case.";
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass         = FALSE;
        failure_mssg = "cache not empty at beginning of single entry case.";
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 1);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 1,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 2);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 2,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 3);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 3,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 4);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 4,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 5);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 5,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 6);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 6,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 7);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 7,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 8);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 8,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 9);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 9,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 10);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 10,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 11);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 11,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 12);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 12,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 13);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 13,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 14);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 14,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 15);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 15,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 16);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 16,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 17);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 17,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 18);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 18,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 19);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 19,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 20);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 20,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 21);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 21,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 22);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 22,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 23);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 23,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 24);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 24,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 25);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 25,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 26);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 26,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 27);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 27,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 28);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 28,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 29);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 29,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 30);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 30,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 31);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 31,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 32);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 32,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ FALSE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ TRUE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 33);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 33,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 34);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 34,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 35);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 35,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 36);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 36,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 37);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 37,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 38);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 38,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 39);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 39,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 40);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 40,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 41);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 41,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 42);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 42,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 43);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 43,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 44);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 44,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 45);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 45,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 46);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 46,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 47);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 47,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__NO_FLAGS_SET,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 48);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 48,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 49);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 49,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 50);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 50,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__NO_FLAGS_SET,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 51);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 51,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 52);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 52,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 53);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 53,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 54);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 54,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 55);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 55,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 56);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 56,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 57);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 57,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 58);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 58,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 59);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 59,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 60);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 60,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ FALSE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 61);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 61,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 62);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 62,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_INVALIDATE_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ FALSE,
            /* expected_flushed     */ TRUE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 63);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 63,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    if (pass) {

        if (show_progress) {
            HDfprintf(stdout, "%s: running test %d.\n", fcn_name, 64);
        }

        check_flush_cache__single_entry_test(
            /* file_ptr            */ file_ptr,
            /* test_num             */ 64,
            /* entry_type           */ PICO_ENTRY_TYPE,
            /* entry_idx            */ 0,
            /* insert_flag          */ TRUE,
            /* flags                */ H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
            /* flush_flags          */ H5C__FLUSH_INVALIDATE_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG |
                H5C__FLUSH_MARKED_ENTRIES_FLAG,
            /* expected_loaded      */ FALSE,
            /* expected_cleared     */ TRUE,
            /* expected_flushed     */ FALSE,
            /* expected_destroyed   */ TRUE);

        if (show_progress) {
            HDfprintf(stdout, "%s: pass = %d.\n", fcn_name, (int)pass);
        }
    }

    /* Now run single entry tests for pinned entries.  Test all combinations
     * of:
     *
     *     1) Unpin by unprotect vs. unpin by call to H5C_unpin_entry().
     *
     *     2) Marked dirty by unprotect or not.
     *
     *     3) Marked dirty by call to H5C_mark_entry_dirty() or not.
     *
     *  4) Marked dirty by call to H5C_mark_entry_dirty() while protected
     *     or not.
     *
     *  5) Marked dirty by call to H5C_mark_entry_dirty() while pinned or not.
     *
     *     6) Entry marked for flush or not.
     *
     *     7) Call flush with H5C__FLUSH_MARKED_ENTRIES_FLAG or not.
     *
     *     8) Call flush with H5C__FLUSH_CLEAR_ONLY_FLAG or not.
     *
     * This yields a total of 256 tests.
     *
     * The tests and their expected results are given in the spec table
     * below.  The values assigned to the expected_cleared, expected_flushed,
     * and expected_destroyed fields are somewhat arcane, so the following
     * overview may be useful.
     *
     * In addition to simply checking to see if the test case runs,
     * we also check to see if the desired operations take place on the
     * cache entry.  Thus expected_cleared is set to TRUE if we expect
     * the entry to be flushed, expected_flushed is set to TRUE if we
     * we expect the entry to be flushed, and expected_destroyed is set
     * to TRUE if we expect the entry to be destroyed.
     *
     * In this test, we are working with pinned entries which can't be
     * evicted, so expected_destroyed is always FALSE.  We could pull it
     * from the table, but it is a hold over from the code this test
     * was adapted from, and it doesn't do any particular harm.
     *
     * In general, we expect an entry to be flushed if it is dirty, and
     * flush in invoked WITHOUT the H5C__FLUSH_CLEAR_ONLY_FLAG.  However,
     * there are exceptions:  If flush is invoked with the
     * H5C__FLUSH_MARKED_ENTRIES_FLAG, only marked entries will be flushed.
     *
     * Further, unprotecting an entry with the H5C__SET_FLUSH_MARKER_FLAG
     * will NOT mark the entry unless the entry has either been marked
     * dirty either before or durting the unprotect call.  This results in
     * some counterintuitive entries in the table.  It make be useful to
     * look in the test code to see the exact order of operations.
     *
     * Similarly, we expect an entry to be cleared if it is dirty, and
     * flush is invoked WITH the H5C__FLUSH_CLEAR_ONLY_FLAG.  Again, there
     * are exceptions -- If flush is also invoked with the
     * H5C__FLUSH_MARKED_ENTRIES_FLAG, only the marked entries will be
     * cleared.
     *
     * The above comments about applying unprotect with the
     * H5C__SET_FLUSH_MARKER_FLAG apply here as well.
     */

    if (pass) {

        int i;
        struct pinned_single_entry_test_spec {
            int          test_num;
            int          entry_type;
            int          entry_idx;
            hbool_t      mark_dirty;
            hbool_t      pop_mark_dirty_prot;
            hbool_t      pop_mark_dirty_pinned;
            hbool_t      unprotect_unpin;
            unsigned int flags;
            unsigned int flush_flags;
            hbool_t      expected_cleared;
            hbool_t      expected_flushed;
            hbool_t      expected_destroyed;
        } spec[256] =
            /*                                    pop    pop
             *                         ent        mark   mark
             *  test  entry            -ry mark   dirty  dirty  unprot                             flush
             * expect  expect expect num   type             idx dirty  prot   pinned unpin  flags flags clear
             * flush  destroy
             */
            {{1, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              FALSE, FALSE},
             {2, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              FALSE, FALSE},
             {3, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {4, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {5, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {6, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {7, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {8, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {9, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {10, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {11, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {12, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {13, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {14, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {15, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {16, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {17, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {18, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {19, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {20, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {21, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {22, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {23, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {24, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {25, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {26, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {27, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {28, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {29, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {30, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {31, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {32, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__NO_FLAGS_SET, FALSE,
              TRUE, FALSE},
             {33, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, FALSE, FALSE},
             {34, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, FALSE, FALSE},
             {35, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {36, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {37, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {38, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {39, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {40, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {41, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {42, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {43, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {44, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {45, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {46, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {47, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {48, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET,
              FALSE, TRUE, FALSE},
             {49, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {50, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {51, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {52, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {53, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {54, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {55, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {56, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {57, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {58, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {59, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {60, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {61, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {62, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {63, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {64, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__NO_FLAGS_SET, FALSE, TRUE, FALSE},
             {65, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {66, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {67, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {68, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {69, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {70, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {71, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {72, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {73, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {74, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {75, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {76, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {77, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {78, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {79, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {80, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {81, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {82, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {83, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {84, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {85, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {86, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {87, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {88, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {89, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {90, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {91, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {92, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {93, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {94, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {95, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {96, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {97, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {98, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {99, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {100, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {101, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {102, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {103, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {104, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {105, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {106, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {107, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {108, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, FALSE, FALSE},
             {109, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {110, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {111, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {112, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {113, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {114, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {115, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {116, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {117, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {118, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {119, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {120, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {121, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {122, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {123, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {124, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {125, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {126, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {127, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE,
              FALSE},
             {128, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG, FALSE, TRUE, FALSE},
             {129, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {130, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {131, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {132, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {133, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {134, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {135, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {136, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {137, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {138, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {139, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {140, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {141, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {142, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {143, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {144, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {145, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {146, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {147, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {148, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {149, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {150, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {151, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {152, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {153, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {154, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {155, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {156, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {157, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {158, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {159, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {160, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG,
              TRUE, FALSE, FALSE},
             {161, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {162, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {163, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {164, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {165, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {166, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {167, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {168, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {169, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {170, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {171, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {172, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {173, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {174, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {175, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {176, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {177, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {178, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {179, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {180, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {181, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {182, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {183, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {184, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {185, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {186, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {187, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {188, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {189, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {190, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {191, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG, H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {192, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {193, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {194, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {195, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {196, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {197, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {198, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {199, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {200, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {201, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {202, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {203, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {204, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {205, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {206, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {207, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {208, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__NO_FLAGS_SET,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {209, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {210, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {211, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {212, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {213, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {214, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {215, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {216, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {217, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {218, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {219, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {220, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {221, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {222, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {223, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {224, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {225, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {226, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {227, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {228, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {229, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {230, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {231, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {232, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {233, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {234, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {235, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {236, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, FALSE, FALSE, FALSE},
             {237, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {238, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {239, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {240, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {241, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {242, PICO_ENTRY_TYPE, 0, FALSE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {243, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {244, PICO_ENTRY_TYPE, 0, FALSE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {245, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {246, PICO_ENTRY_TYPE, 0, FALSE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {247, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {248, PICO_ENTRY_TYPE, 0, FALSE, TRUE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {249, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {250, PICO_ENTRY_TYPE, 0, TRUE, FALSE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {251, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {252, PICO_ENTRY_TYPE, 0, TRUE, FALSE, TRUE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {253, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {254, PICO_ENTRY_TYPE, 0, TRUE, TRUE, FALSE, TRUE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {255, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, FALSE,
              H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE},
             {256, PICO_ENTRY_TYPE, 0, TRUE, TRUE, TRUE, TRUE, H5C__DIRTIED_FLAG | H5C__SET_FLUSH_MARKER_FLAG,
              H5C__FLUSH_MARKED_ENTRIES_FLAG | H5C__FLUSH_CLEAR_ONLY_FLAG, TRUE, FALSE, FALSE}};

        i = 0;
        while ((pass) && (i < 256)) {

            if (show_progress) {
                HDfprintf(stdout, "%s: running pinned test %d.\n", fcn_name, i);
            }

            check_flush_cache__pinned_single_entry_test(
                /* file_ptr             */ file_ptr,
                /* test_num              */ spec[i].test_num,
                /* entry_type            */ spec[i].entry_type,
                /* entry_idx             */ spec[i].entry_idx,
                /* mark_dirty            */ spec[i].mark_dirty,
                /* pop_mark_dirty_prot   */ spec[i].pop_mark_dirty_prot,
                /* pop_mark_dirty_pinned */ spec[i].pop_mark_dirty_pinned,
                /* unprotect_unpin       */ spec[i].unprotect_unpin,
                /* flags                 */ spec[i].flags,
                /* flush_flags           */ spec[i].flush_flags,
                /* expected_cleared      */ spec[i].expected_cleared,
                /* expected_flushed      */ spec[i].expected_flushed,
                /* expected_destroyed    */ spec[i].expected_destroyed);
            i++;
        }
    }

    return;

} /* check_flush_cache__single_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__single_entry_test()
 *
 * Purpose:    Run a single entry flush cache test.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              1/12/05
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                     hbool_t insert_flag, unsigned int flags, unsigned int flush_flags,
                                     hbool_t expected_loaded, hbool_t expected_cleared,
                                     hbool_t expected_flushed, hbool_t expected_destroyed)
{
    /* const char *   fcn_name = "check_flush_cache__single_entry_test"; */
    H5C_t *       cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    herr_t        result;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (cache_ptr == NULL) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache_ptr NULL on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache not empty at beginning of single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((entry_type < 0) || (entry_type >= NUMBER_OF_ENTRY_TYPES) || (entry_idx < 0) ||
             (entry_idx > max_indices[entry_type])) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "Bad parameters on entry to single entry test #%d.", test_num);
        failure_mssg = msg;
    }

    if (pass) {

        base_addr = entries[entry_type];
        entry_ptr = &(base_addr[entry_idx]);

        if (insert_flag) {

            insert_entry(file_ptr, entry_type, entry_idx, flags);
        }
        else {

            protect_entry(file_ptr, entry_type, entry_idx);

            unprotect_entry(file_ptr, entry_type, entry_idx, flags);
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, flush_flags);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "flush with flags 0x%x failed in single entry test #%d.",
                       flush_flags, test_num);
            failure_mssg = msg;
        }
        else if ((entry_ptr->loaded != expected_loaded) || (entry_ptr->cleared != expected_cleared) ||
                 (entry_ptr->flushed != expected_flushed) || (entry_ptr->destroyed != expected_destroyed)) {

#if 0 /* This is useful debugging code -- lets keep it for a while */

            HDfprintf(stdout,
              "loaded = %d(%d), clrd = %d(%d), flshd = %d(%d), dest = %d(%d)\n",
              (int)(entry_ptr->loaded),
              (int)expected_loaded,
              (int)(entry_ptr->cleared),
              (int)expected_cleared,
              (int)(entry_ptr->flushed),
              (int)expected_flushed,
              (int)(entry_ptr->destroyed),
              (int)expected_destroyed);
#endif
            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry status after flush in single entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
        else if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
                  ((cache_ptr->index_len != 1) || (cache_ptr->index_size != entry_sizes[entry_type]))) ||
                 (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
                  ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after flush in single entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Flush failed on cleanup in single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache len/size after cleanup in single entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
        else {

            entry_ptr->loaded    = FALSE;
            entry_ptr->cleared   = FALSE;
            entry_ptr->flushed   = FALSE;
            entry_ptr->destroyed = FALSE;
        }
    }

    return;

} /* check_flush_cache__single_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_cache__pinned_single_entry_test()
 *
 * Purpose:    Run a pinned single entry flush cache test.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              3/28/06
 *
 * Modifications:
 *
 *         JRM -- 5/17/06
 *         Added the pop_mark_dirty_prot and pop_mark_dirty_pinned
 *         flags and supporting code to allow us to test the
 *         H5C_mark_entry_dirty() call.  Use the
 *         call to mark the entry dirty while the entry is protected
 *         if pop_mark_dirty_prot is TRUE, and to mark the entry
 *         dirty while it is pinned if pop_mark_dirty_pinned is TRUE.
 *
 *-------------------------------------------------------------------------
 */

static void
check_flush_cache__pinned_single_entry_test(H5F_t *file_ptr, int test_num, int entry_type, int entry_idx,
                                            hbool_t mark_dirty, hbool_t pop_mark_dirty_prot,
                                            hbool_t pop_mark_dirty_pinned, hbool_t unprotect_unpin,
                                            unsigned int flags, unsigned int flush_flags,
                                            hbool_t expected_cleared, hbool_t expected_flushed,
                                            hbool_t expected_destroyed)
{
    /* const char *fcn_name = "check_flush_cache__pinned_single_entry_test"; */
    H5C_t *       cache_ptr = file_ptr->shared->cache;
    static char   msg[128];
    hbool_t       expected_loaded = TRUE;
    herr_t        result;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    if (cache_ptr == NULL) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache_ptr NULL on entry to pinned single entry test #%d.", test_num);
        failure_mssg = msg;
    }
    else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "cache not empty at beginning of pinned single entry test #%d.",
                   test_num);
        failure_mssg = msg;
    }
    else if ((entry_type < 0) || (entry_type >= NUMBER_OF_ENTRY_TYPES) || (entry_idx < 0) ||
             (entry_idx > max_indices[entry_type])) {

        pass = FALSE;
        HDsnprintf(msg, (size_t)128, "Bad parameters on entry to pinned single entry test #%d.", test_num);
        failure_mssg = msg;
    }

    if (pass) {

        base_addr = entries[entry_type];
        entry_ptr = &(base_addr[entry_idx]);

        protect_entry(file_ptr, entry_type, entry_idx);

        if (pop_mark_dirty_prot) {

            mark_entry_dirty(entry_type, entry_idx);
        }

        unprotect_entry(file_ptr, entry_type, entry_idx, (flags | H5C__PIN_ENTRY_FLAG));

        if (mark_dirty) {

            mark_entry_dirty(entry_type, entry_idx);
        }

        if (pop_mark_dirty_pinned) {

            mark_entry_dirty(entry_type, entry_idx);
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, flush_flags);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "flush with flags 0x%x failed in pinned single entry test #%d.",
                       flush_flags, test_num);
            failure_mssg = msg;
        }
        else if ((entry_ptr->loaded != expected_loaded) || (entry_ptr->cleared != expected_cleared) ||
                 (entry_ptr->flushed != expected_flushed) || (entry_ptr->destroyed != expected_destroyed)) {
#if 0 /* this is useful debugging code -- keep it around */
            HDfprintf(stdout,
              "loaded = %d(%d), clrd = %d(%d), flshd = %d(%d), dest = %d(%d)\n",
              (int)(entry_ptr->loaded),
              (int)expected_loaded,
              (int)(entry_ptr->cleared),
              (int)expected_cleared,
              (int)(entry_ptr->flushed),
              (int)expected_flushed,
              (int)(entry_ptr->destroyed),
              (int)expected_destroyed);
#endif
            pass = FALSE;
            HDsnprintf(msg, (size_t)128,
                       "Unexpected entry status after flush in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else if ((((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) == 0) &&
                  ((cache_ptr->index_len != 1) || (cache_ptr->index_size != entry_sizes[entry_type]))) ||
                 (((flush_flags & H5C__FLUSH_INVALIDATE_FLAG) != 0) &&
                  ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128,
                       "Unexpected cache len/size after flush in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
    }

    /* clean up the cache to prep for the next test */
    if (pass) {

        if (unprotect_unpin) {

            protect_entry(file_ptr, entry_type, entry_idx);

            unprotect_entry(file_ptr, entry_type, entry_idx,
                            (flags & H5C__DIRTIED_FLAG) | H5C__UNPIN_ENTRY_FLAG);
        }
        else {

            unpin_entry(entry_type, entry_idx);
        }
    }

    if (pass) {

        result = H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                 H5C__FLUSH_INVALIDATE_FLAG);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Flush failed on cleanup in pinned single entry test #%d.",
                       test_num);
            failure_mssg = msg;
        }
        else if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128,
                       "Unexpected cache len/size after cleanup in pinned single entry test #%d.", test_num);
            failure_mssg = msg;
        }
        else {

            entry_ptr->loaded    = FALSE;
            entry_ptr->cleared   = FALSE;
            entry_ptr->flushed   = FALSE;
            entry_ptr->destroyed = FALSE;
        }
    }

    return;

} /* check_flush_cache__pinned_single_entry_test() */

/*-------------------------------------------------------------------------
 * Function:    check_get_entry_status()
 *
 * Purpose:    Verify that H5C_get_entry_status() behaves as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/28/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_get_entry_status(void)
{
    const char *  fcn_name = "check_get_entry_status";
    static char   msg[128];
    herr_t        result;
    hbool_t       in_cache;
    hbool_t       is_dirty;
    hbool_t       is_protected;
    hbool_t       is_pinned;
    size_t        entry_size;
    H5F_t *       file_ptr  = NULL;
    test_entry_t *base_addr = NULL;
    test_entry_t *entry_ptr = NULL;

    TESTING("H5C_get_entry_status() functionality");

    pass = TRUE;

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));

        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {

            base_addr = entries[0];
            entry_ptr = &(base_addr[0]);
        }
    }

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || !is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        mark_entry_dirty(0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        unpin_entry(0, 0);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_get_entry_status() */

/*-------------------------------------------------------------------------
 * Function:    check_expunge_entry()
 *
 * Purpose:    Verify that H5C_expunge_entry() behaves as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              7/5/06
 *
 * Modifications:
 *
 *         None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_expunge_entry(void)
{
    const char *  fcn_name = "check_expunge_entry";
    static char   msg[128];
    herr_t        result;
    hbool_t       in_cache;
    hbool_t       is_dirty;
    hbool_t       is_protected;
    hbool_t       is_pinned;
    size_t        entry_size;
    H5F_t *       file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    TESTING("H5C_expunge_entry() functionality");

    pass = TRUE;

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));

        base_addr = entries[0];
        entry_ptr = &(base_addr[0]);
    }

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    /* protect an entry to force the cache to load it, and then unprotect
     * it without marking it dirty.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    /* Expunge the entry and then verify that it is no longer in the cache.
     * Also verify that the entry was loaded, cleared, and destroyed, but
     * not flushed.
     */
    if (pass) {

        expunge_entry(file_ptr, 0, 0);
    }

    if (pass) {

        /* entry shouldn't be in cache -- only in_cache should be touched
         * by the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (!entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    /* now repeat the process with a different entry.  On unprotect
     * mark the entry as dirty.  Verify that it is not flushed.
     */

    base_addr = entries[0];
    entry_ptr = &(base_addr[1]);

    if (pass) {

        /* entry not in cache -- only in_cache should be touched by
         * the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    /* protect the entry to force the cache to load it, and then unprotect
     * it with the dirty flag set.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 1);

        unprotect_entry(file_ptr, 0, 1, H5C__DIRTIED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    /* Expunge the entry and then verify that it is no longer in the cache.
     * Also verify that the entry was loaded, cleared and destroyed, but not
     * flushed.
     */
    if (pass) {

        expunge_entry(file_ptr, 0, 1);
    }

    if (pass) {

        /* entry shouldn't be in cache -- only in_cache should be touched
         * by the status call.  Thus, only check that boolean.
         */

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (!entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_expunge_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_multiple_read_protect()
 *
 * Purpose:    Verify that multiple, simultaneous read protects of a
 *         single entry perform as expectd.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/1/07
 *
 * Modifications:
 *
 *         None.
 *
 *-------------------------------------------------------------------------
 */
static unsigned
check_multiple_read_protect(void)
{
    const char *fcn_name = "check_multiple_read_protect()";
    H5F_t *     file_ptr = NULL;
#if H5C_COLLECT_CACHE_STATS
    H5C_t *cache_ptr = NULL;
#endif /* H5C_COLLECT_CACHE_STATS */
    test_entry_t *entry_ptr;

    TESTING("multiple read only protects on a single entry");

    pass = TRUE;

    /* allocate a cache.  Should succeed.
     *
     * Then to start with, proceed as follows:
     *
     * Read protect an entry.
     *
     * Then read protect the entry again.  Should succeed.
     *
     * Read protect yet again.  Should succeed.
     *
     * Unprotect with no changes, and then read protect twice again.
     * Should succeed.
     *
     * Now unprotect three times.  Should succeed.
     *
     * If stats are enabled, verify that correct stats are collected at
     * every step.
     *
     * Also, verify internal state of read protects at every step.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
#if H5C_COLLECT_CACHE_STATS
        cache_ptr = file_ptr->shared->cache;
#endif /* H5C_COLLECT_CACHE_STATS */

        entry_ptr = &((entries[0])[0]);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 1.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 0) ||
        (cache_ptr->max_read_protects[0] != 0)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 1.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 2.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 1) ||
        (cache_ptr->max_read_protects[0] != 1)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 2.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 3.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 2) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 3.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 4.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 2) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 4.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 5.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 3) ||
        (cache_ptr->max_read_protects[0] != 2)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 5.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        protect_entry_ro(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 3)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 6.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 6.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 2)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 7.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 7.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((!(entry_ptr->header.is_protected)) || (!(entry_ptr->header.is_read_only)) ||
            (entry_ptr->header.ro_ref_count != 1)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 8.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 8.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 9.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 0) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 9.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* If we get this far, do a write protect and unprotect to verify
     * that the stats are getting collected properly here as well.
     */

    if (pass) {
        protect_entry(file_ptr, 0, 0);

        if ((!(entry_ptr->header.is_protected)) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 10.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 1) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 10.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        if ((entry_ptr->header.is_protected) || (entry_ptr->header.is_read_only) ||
            (entry_ptr->header.ro_ref_count != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected ro protected status 11.\n";
        }
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 1) || (cache_ptr->read_protects[0] != 4) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 11.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    /* Finally, mix things up a little, using a mix of reads and
     * and writes on different entries.  Also include a pin to verify
     * that it works as well.
     *
     * Stats are looking OK, so we will only test them one more time
     * at the end to ensure that all is at it should be.
     */

    if (pass) {

        protect_entry(file_ptr, 0, 2);    /* (0,2) write */
        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (1) */
        protect_entry(file_ptr, 0, 6);    /* (0,6) write */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) unprotect */
                        H5C__NO_FLAGS_SET);

        protect_entry_ro(file_ptr, 0, 2); /* (0,2) read only (1) */
        protect_entry(file_ptr, 0, 1);    /* (0,1) write */
        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (2) */
        protect_entry(file_ptr, 0, 0);    /* (0,0) write */
        protect_entry_ro(file_ptr, 0, 2); /* (0,2) read only (2) */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) read only (1) pin */
                        H5C__PIN_ENTRY_FLAG);
        unprotect_entry(file_ptr, 0, 6, /* (0,6) unprotect */
                        H5C__NO_FLAGS_SET);

        protect_entry_ro(file_ptr, 0, 4); /* (0,4) read only (3) */

        unprotect_entry(file_ptr, 0, 2, /* (0,2) unprotect */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 1, /* (0,1) unprotect */
                        H5C__NO_FLAGS_SET);

        if (pass) {

            entry_ptr = &((entries[0])[4]);

            if (H5C_pin_protected_entry((void *)entry_ptr) < 0) {

                pass         = FALSE;
                failure_mssg = "H5C_pin_protected_entry() failed.\n";
            }
            else if (!(entry_ptr->header.is_pinned)) {

                pass         = FALSE;
                failure_mssg = "entry (0,4) not pinned.\n";
            }
            else {

                /* keep test bed sanity checks happy */
                entry_ptr->is_pinned = TRUE;
            }
        }

        unprotect_entry(file_ptr, 0, 4, /* (0,4) read only (2) */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 4, /* (0,4) read only (1) */
                        H5C__UNPIN_ENTRY_FLAG);

        if ((pass) && (entry_ptr->header.is_pinned)) {

            pass         = FALSE;
            failure_mssg = "enty (0,4) still pinned.\n";
        }

        unprotect_entry(file_ptr, 0, 4, /* (0,4) unprotect */
                        H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 0, /* (0,0) unprotect */
                        H5C__NO_FLAGS_SET);

        unpin_entry(0, 2);
    }

#if H5C_COLLECT_CACHE_STATS
    if ((cache_ptr->write_protects[0] != 5) || (cache_ptr->read_protects[0] != 9) ||
        (cache_ptr->max_read_protects[0] != 3)) {

        pass         = FALSE;
        failure_mssg = "Unexpected protect stats 11.\n";
    }
#endif /* H5C_COLLECT_CACHE_STATS */

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_multiple_read_protect() */

/*-------------------------------------------------------------------------
 * Function:    check_move_entry()
 *
 * Purpose:    Verify that H5C_move_entry behaves as expected.  In
 *         particular, verify that it works correctly with pinned
 *         entries.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/26/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_move_entry(void)
{
    const char *                fcn_name = "check_move_entry";
    int                         i;
    H5F_t *                     file_ptr      = NULL;
    struct move_entry_test_spec test_specs[4] = {{/* int     entry_type  = */ PICO_ENTRY_TYPE,
                                                  /* int     entry_index = */ 10,
                                                  /* hbool_t is_dirty    = */ FALSE,
                                                  /* hbool_t is_pinned   = */ FALSE},
                                                 {/* int     entry_type  = */ PICO_ENTRY_TYPE,
                                                  /* int     entry_index = */ 20,
                                                  /* hbool_t is_dirty    = */ TRUE,
                                                  /* hbool_t is_pinned   = */ FALSE},
                                                 {/* int     entry_type  = */ PICO_ENTRY_TYPE,
                                                  /* int     entry_index = */ 30,
                                                  /* hbool_t is_dirty    = */ FALSE,
                                                  /* hbool_t is_pinned   = */ TRUE},
                                                 {/* int     entry_type  = */ PICO_ENTRY_TYPE,
                                                  /* int     entry_index = */ 40,
                                                  /* hbool_t is_dirty    = */ TRUE,
                                                  /* hbool_t is_pinned   = */ TRUE}};

    TESTING("H5C_move_entry() functionality");

    pass = TRUE;

    /* allocate a cache, load entries into it, and then move
     * them.  To the extent possible, verify that the desired
     * actions took place.
     *
     * At present, we should do the following tests:
     *
     * 1) move a clean, unprotected, unpinned entry.
     *
     * 2) move a dirty, unprotected, unpinned entry.
     *
     * 3) move a clean, unprotected, pinned entry.
     *
     * 4) move a dirty, unprotected, pinned entry.
     *
     * In all cases, the entry should have moved to its
     * new location, and have been marked dirty if it wasn't
     * already.
     *
     * Unpinned entries should have been moved to the head
     * of the LRU list.
     *
     * Pinned entries should remain untouched on the pinned entry
     * list.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));
    }

    i = 0;
    while ((pass) && (i < 4)) {
        check_move_entry__run_test(file_ptr, i, &(test_specs[i]));
        i++;
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_move_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_move_entry__run_test()
 *
 * Purpose:     Run a move entry test.
 *
 *        Do nothing if pass is FALSE on entry.
 *
 * Return:      void
 *
 * Programmer:  John Mainzer
 *              4/27/06
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static void
check_move_entry__run_test(H5F_t *file_ptr, int test_num, struct move_entry_test_spec *spec_ptr)
{
    /* const char *   fcn_name = "check_move_entry__run_test"; */
    H5C_t *            cache_ptr = file_ptr->shared->cache;
    static char        msg[128];
    unsigned int       flags = H5C__NO_FLAGS_SET;
    test_entry_t *     base_addr;
    test_entry_t *     entry_ptr = NULL;
    H5C_cache_entry_t *test_ptr  = NULL;

    assert(cache_ptr);
    assert(spec_ptr);

    if (pass) {

        base_addr = entries[spec_ptr->entry_type];
        entry_ptr = &(base_addr[spec_ptr->entry_index]);

        if ((entry_ptr->self != entry_ptr) ||
            ((entry_ptr->cache_ptr != cache_ptr) && (entry_ptr->cache_ptr != NULL)) ||
            (!(entry_ptr->at_main_addr)) || (entry_ptr->addr != entry_ptr->main_addr)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "bad entry_ptr in move test #%d.", test_num);
            failure_mssg = msg;
        }
        else if (spec_ptr->is_pinned) {

            flags |= H5C__PIN_ENTRY_FLAG;
        }
    }

    if (pass) {

        protect_entry(file_ptr, spec_ptr->entry_type, spec_ptr->entry_index);

        if (spec_ptr->is_dirty)
            flags |= H5C__DIRTIED_FLAG;

        unprotect_entry(file_ptr, spec_ptr->entry_type, spec_ptr->entry_index, flags);

        move_entry(cache_ptr, spec_ptr->entry_type, spec_ptr->entry_index, FALSE);
    }

    if (pass) {

        /* verify that the move took place, and that the cache's internal
         * structures are as expected.  Note that some sanity checking is
         * done by move_entry(), so we don't have to repeat it here.
         */

        if (spec_ptr->is_pinned) {

            if (!(entry_ptr->header.is_pinned)) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "Pinned entry not pinned after move in test #%d.", test_num);
                failure_mssg = msg;
            }

            if (pass) {

                test_ptr = cache_ptr->pel_head_ptr;

                while ((test_ptr != NULL) && (test_ptr != (H5C_cache_entry_t *)entry_ptr)) {
                    test_ptr = test_ptr->next;
                }

                if (test_ptr == NULL) {

                    pass = FALSE;
                    HDsnprintf(msg, (size_t)128, "Pinned entry not in pel after move in test #%d.", test_num);
                    failure_mssg = msg;
                }
            }

            unpin_entry(spec_ptr->entry_type, spec_ptr->entry_index);
        }
        else {

            if (entry_ptr->header.is_pinned) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "Unpinned entry pinned after move in test #%d.", test_num);
                failure_mssg = msg;
            }

            if ((entry_ptr->header.prev != NULL) ||
                (cache_ptr->LRU_head_ptr != (H5C_cache_entry_t *)entry_ptr)) {
                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "Entry not at head of LRU after move in test #%d.", test_num);
                failure_mssg = msg;
            }
        }
    }

    /* put the entry back where it started from */
    move_entry(cache_ptr, spec_ptr->entry_type, spec_ptr->entry_index, TRUE);

    return;

} /* check_move_entry__run_test() */

/*-------------------------------------------------------------------------
 * Function:    check_pin_protected_entry()
 *
 * Purpose:    Verify that H5C_pin_protected_entry behaves as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/28/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_pin_protected_entry(void)
{
    const char *  fcn_name = "check_pin_protected_entry";
    static char   msg[128];
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    TESTING("H5C_pin_protected_entry() functionality");

    pass = TRUE;

    /* Create a cache, protect an entry, and then use H5C_pin_protected_entry()
     * to pin it.  Verify that the entry is in fact pined.  Unprotect the entry
     * to unpin it, and then destroy the cache.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));

        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
    }

    if (pass) {

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        base_addr = entries[0];
        entry_ptr = &(base_addr[0]);

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_pin_protected_entry() reports failure.");
            failure_mssg = msg;
        }
        else if (!(entry_ptr->header.is_pinned)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "entry not pinned when it should be.");
            failure_mssg = msg;
        }
        else {

            entry_ptr->is_pinned = TRUE;
        }
    }

    unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_pin_protected_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_resize_entry()
 *
 * Purpose:    Verify that H5C_resize_entry() and H5C_unprotect() resize
 *         entries as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              7/7/06
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_resize_entry(void)
{
    const char *  fcn_name = "check_resize_entry";
    static char   msg[128];
    herr_t        result;
    hbool_t       in_cache;
    hbool_t       is_dirty;
    hbool_t       is_protected;
    hbool_t       is_pinned;
    size_t        entry_size;
    size_t        reported_entry_size;
    H5F_t *       file_ptr  = NULL;
    H5C_t *       cache_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    TESTING("entry resize functionality");

    /* Setup a cache and verify that it is empty.
     *
     * Then force the load of an entry by protecting it, and verify that
     * the entry and cache have the expected sizes.
     *
     * Then unprotect the entry with the size changed flag and a reduced
     * size.  Verify that the entry and cache have the expected expected
     * sizes.
     *
     * Use a second protect/unprotect cycle to restore the entry to
     * its original size.  Verify that the entry and cache have the
     * expected sizes.
     *
     * Protect and unprotect the entry again to pin it.  Use
     * H5C_resize_entry to reduce its size.  Verify that the entry
     * and cache have the expected sizes.
     *
     * Use H5C_resize_entry again to restore the entry to its original
     * size.  Verify that the entry  and cache have the expected sizes.
     *
     * Use a protect / unprotect cycle to unpin and destroy the entry.
     * Verify that the entry  and cache have the expected sizes.
     *
     *
     * Obesrve that all the above tests have been done with only one
     * entry in the cache.  Repeat the tests with several entries in
     * the cache.
     */

    pass = TRUE;

    /* tests with only one entry in the cache: */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024 * 1024), (size_t)(1 * 1024 * 1024));
        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {
            cache_ptr = file_ptr->shared->cache;

            base_addr  = entries[LARGE_ENTRY_TYPE];
            entry_ptr  = &(base_addr[0]);
            entry_size = LARGE_ENTRY_SIZE;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 2));

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                   &(types[LARGE_ENTRY_TYPE]), entry_ptr->addr, (void *)entry_ptr,
                                   H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "H5C_unprotect() reports failure 1.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = FALSE;
                entry_ptr->is_dirty     = TRUE;
                entry_ptr->size         = LARGE_ENTRY_SIZE / 2;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != (LARGE_ENTRY_SIZE / 2)) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != (LARGE_ENTRY_SIZE / 2))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 2))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                   &(types[LARGE_ENTRY_TYPE]), entry_ptr->addr, (void *)entry_ptr,
                                   H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "H5C_unprotect() reports failure 2.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = FALSE;
                entry_ptr->is_dirty     = TRUE;
                entry_ptr->size         = LARGE_ENTRY_SIZE;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 4));

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 1.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != (LARGE_ENTRY_SIZE / 4)) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != (LARGE_ENTRY_SIZE / 4))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 4))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 2.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__UNPIN_ENTRY_FLAG | H5C__DELETED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 6.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 6.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (!entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 6.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 7.");
            failure_mssg = msg;
        }
    }

    /* now repeat the above tests with several entries in the cache: */

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 8.");
            failure_mssg = msg;
        }
        base_addr  = entries[LARGE_ENTRY_TYPE];
        entry_ptr  = &(base_addr[3]);
        entry_size = LARGE_ENTRY_SIZE;
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        if ((cache_ptr->index_len != 3) || (cache_ptr->index_size != 3 * LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 9.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != 4 * LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 10.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 7.");
            failure_mssg = msg;
        }
        else if (!in_cache || is_dirty || !is_protected || is_pinned) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 7.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 7.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 2));

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                   &(types[LARGE_ENTRY_TYPE]), entry_ptr->addr, (void *)entry_ptr,
                                   H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "H5C_unprotect() reports failure 3.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = FALSE;
                entry_ptr->is_dirty     = TRUE;
                entry_ptr->size         = LARGE_ENTRY_SIZE / 2;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) ||
            (cache_ptr->index_size != ((3 * LARGE_ENTRY_SIZE) + (LARGE_ENTRY_SIZE / 2))) ||
            (cache_ptr->slist_len != 2) ||
            (cache_ptr->slist_size != (LARGE_ENTRY_SIZE + (LARGE_ENTRY_SIZE / 2)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 11.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 8.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 2))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 8.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 8.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "error(s) in H5C_resize_entry().");
            failure_mssg = msg;
        }
        else {

            result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                   &(types[LARGE_ENTRY_TYPE]), entry_ptr->addr, (void *)entry_ptr,
                                   H5C__DIRTIED_FLAG);

            if (result < 0) {

                pass = FALSE;
                HDsnprintf(msg, (size_t)128, "H5C_unprotect() reports failure 4.");
                failure_mssg = msg;
            }
            else {

                /* tidy up so we play nice with the standard protect / unprotect
                 * calls.
                 */
                entry_ptr->is_protected = FALSE;
                entry_ptr->is_dirty     = TRUE;
                entry_ptr->size         = LARGE_ENTRY_SIZE;
            }
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != 4 * LARGE_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 12.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 9.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 9.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 9.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__PIN_ENTRY_FLAG);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (LARGE_ENTRY_SIZE / 4));

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 3.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) ||
            (cache_ptr->index_size != ((3 * LARGE_ENTRY_SIZE) + (LARGE_ENTRY_SIZE / 4))) ||
            (cache_ptr->slist_len != 2) ||
            (cache_ptr->slist_size != (LARGE_ENTRY_SIZE + (LARGE_ENTRY_SIZE / 4)))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 13.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 10.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != (LARGE_ENTRY_SIZE / 4))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 10.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 10.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, LARGE_ENTRY_SIZE);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_resize_entry() reports failure 4.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 4) || (cache_ptr->index_size != (4 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != (2 * LARGE_ENTRY_SIZE))) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 14.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &reported_entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 11.");
            failure_mssg = msg;
        }
        else if (!in_cache || !is_dirty || is_protected || !is_pinned ||
                 (reported_entry_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 11.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 11.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);

        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__UNPIN_ENTRY_FLAG | H5C__DELETED_FLAG);
    }

    if (pass) {

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, &entry_size, &in_cache, &is_dirty,
                                      &is_protected, &is_pinned);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 12.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 12.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (!entry_ptr->cleared) || (entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 12.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        if ((cache_ptr->index_len != 3) || (cache_ptr->index_size != (3 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != LARGE_ENTRY_SIZE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 15.");
            failure_mssg = msg;
        }
    }

    if (pass) {
        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__DELETED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__DELETED_FLAG);

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__DELETED_FLAG);
    }

    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 16.");
            failure_mssg = msg;
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_resize_entry() */

/*-------------------------------------------------------------------------
 * Function:    check_evictions_enabled()
 *
 * Purpose:    Verify that H5C_get_evictions_enabled() and
 *         H5C_set_evictions_enabled() functions perform as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              8/2/07
 *
 * Modifications:
 *
 *         None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_evictions_enabled(void)
{
    const char *  fcn_name = "check_evictions_enabled";
    static char   msg[128];
    herr_t        result;
    hbool_t       show_progress = FALSE;
    hbool_t       evictions_enabled;
    hbool_t       in_cache;
    int           i;
    int           mile_stone = 1;
    H5F_t *       file_ptr   = NULL;
    H5C_t *       cache_ptr  = NULL;
    test_entry_t *base_addr  = NULL;
    test_entry_t *entry_ptr;

    TESTING("evictions enabled/disabled functionality");

    /* Setup a cache and verify that it is empty.
     *
     * Use H5C_get_evictions_enabled() to determine if evictions are
     * currently enabled -- they should be.
     *
     * Load entries until the cache is full.  Load one more.  Verify that
     * this caused an entry to be evicted.
     *
     * Insert an entry.  Verify that this cases and entry to be evicted.
     *
     * Used H5C_set_evictions_enabled() to disable evictions.  Verify
     * with a call to H5C_get_evictions_enabled().
     *
     * Load another entry -- verify that this does not cause an entry
     * to be evicted.
     *
     * Insert an entry -- verify that this does not cause an entry to
     * be evicted.
     *
     * Use H5C_set_evictions_enabled() to re-enable evictions.  Verify
     * with a call to H5C_get_evictions_enabled().
     *
     * Protect and unprotect some of the entries in the cache.  Verify
     * that there are no evictions (since we only try to make space
     * when we either insert or load a new entry).
     *
     * Protect an entry not in the cache.  Verify that this causes
     * two evictions.
     *
     * Used H5C_set_evictions_enabled() to disable evictions again.
     * Verify with a call to H5C_get_evictions_enabled().
     *
     * Now flush and discard the cache -- should succeed.
     */

    pass = TRUE;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* create the cache */
    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(1 * 1024 * 1024), (size_t)(512 * 1024));
        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {
            cache_ptr = file_ptr->shared->cache;

            base_addr = entries[MONSTER_ENTRY_TYPE];
        }
    }

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that it is empty */
    if (pass) {

        if ((cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->slist_len != 0) ||
            (cache_ptr->slist_size != 0) || (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that H5C_get_evictions_enabled() returns the expected value */
    if (pass) {

        result = H5C_get_evictions_enabled(cache_ptr, &evictions_enabled);

        if ((result != SUCCEED) || (evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected evictions enabled 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* fill the cache */
        for (i = 0; i < 16; i++) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
        }
    }

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that the cache is full */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect another entry */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 16);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 16, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that an entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 0) || (cache_ptr->slist_size != 0) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[0]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 1.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 1.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (!entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* insert an entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 17, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that another entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 4.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[1]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 2.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 2.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (!entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 12 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* disable evictions */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result != SUCCEED) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "can't disable evictions 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 13 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that evictions are disabled */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != FALSE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 5.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 14 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect another entry */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 18);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 18, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 15 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that no entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 17) || (cache_ptr->index_size != 17 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 1) || (cache_ptr->slist_size != MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != FALSE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 6.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 16 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* insert another entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 19, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 17 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that no entry has been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 18) || (cache_ptr->index_size != 18 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != FALSE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 7.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 18 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* re-enable evictions */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result != SUCCEED) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "can't enable evictions 1.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 19 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that is in the cache */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 19);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 19, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 20 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that no entries have been evicted */
    if (pass) {

        if ((cache_ptr->index_len != 18) || (cache_ptr->index_size != 18 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 8.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 21 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that isn't in the cache */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 20);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 20, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 22 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that the entries have been evicted to bring the
     * cache back down to its normal size.
     */

    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 9.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 23 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[2]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 3.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 3.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (!entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 24 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[3]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 4.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 4.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (!entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 4.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 25 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* disable evictions again */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result != SUCCEED) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "can't disable evictions 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 26 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* protect and unprotect an entry that isn't in the cache, forcing
         * the cache to grow.
         */
        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 21);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 21, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 27 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that the cache has grown */
    if (pass) {

        if ((cache_ptr->index_len != 17) || (cache_ptr->index_size != 17 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 2) || (cache_ptr->slist_size != 2 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != FALSE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 10.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 28 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* re-enable evictions again */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result != SUCCEED) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "can't enable evictions 2.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 29 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* insert an entry */
        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 22, H5C__NO_FLAGS_SET);
    }

    if (show_progress) /* 30 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* verify that the cache has returned to its maximum size */
    if (pass) {

        if ((cache_ptr->index_len != 16) || (cache_ptr->index_size != 16 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->slist_len != 3) || (cache_ptr->slist_size != 3 * MONSTER_ENTRY_SIZE) ||
            (cache_ptr->evictions_enabled != TRUE)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected cache status 11.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 31 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        entry_ptr = &(base_addr[4]);

        result = H5C_get_entry_status(file_ptr, entry_ptr->addr, NULL, &in_cache, NULL, NULL, NULL);

        if (result < 0) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "H5C_get_entry_status() reports failure 5.");
            failure_mssg = msg;
        }
        else if (in_cache) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected status 5.");
            failure_mssg = msg;
        }
        else if ((!entry_ptr->loaded) || (entry_ptr->cleared) || (!entry_ptr->flushed) ||
                 (!entry_ptr->destroyed)) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "Unexpected entry history 5.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 32 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* disable evictions one last time before we shut down */
    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, FALSE);

        if (result != SUCCEED) {

            pass = FALSE;
            HDsnprintf(msg, (size_t)128, "can't disable evictions 3.");
            failure_mssg = msg;
        }
    }

    if (show_progress) /* 33 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (show_progress) /* 34 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_evictions_enabled() */

/*-------------------------------------------------------------------------
 * Function:    check_flush_protected_err()
 *
 * Purpose:    Verify that an attempt to flush the cache when it contains
 *        a protected entry will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_flush_protected_err(void)
{
    const char *fcn_name = "check_flush_protected_err";
    H5F_t *     file_ptr = NULL;

    TESTING("flush cache with protected entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, and try to flush.  This
     * should fail.  Unprotect the entry and flush again -- should
     * succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        if (H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                            H5C__NO_FLAGS_SET) >= 0) {

            pass         = FALSE;
            failure_mssg = "flush succeeded on cache with protected entry.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);

            if (H5C_flush_cache(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                H5C__NO_FLAGS_SET) < 0) {

                pass         = FALSE;
                failure_mssg = "flush failed after unprotect.\n";
            }
            else {

                takedown_cache(file_ptr, FALSE, FALSE);
            }
        }
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_flush_protected_err() */

/*-------------------------------------------------------------------------
 * Function:    check_destroy_pinned_err()
 *
 * Purpose:    Verify that an attempt to destroy the cache when it contains
 *        a pinned entry that can't be unpined during the flush destroy
 *        will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/7/06
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_destroy_pinned_err(void)
{
    const char *fcn_name = "check_destroy_pinned_err()";
    H5F_t *     file_ptr = NULL;

    TESTING("destroy cache with permanently pinned entry error");

    pass = TRUE;

    /* allocate a cache, pin an entry, and try to flush destroy.  This
     * should fail.  Unpin the entry and flush destroy again -- should
     * succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);
        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

        if (H5C_dest(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT) >= 0) {

            pass         = FALSE;
            failure_mssg = "destroy succeeded on cache with pinned entry.\n";
        }
        else {

            unpin_entry(0, 0);

            if (H5C_dest(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT) < 0) {

                pass         = FALSE;
                failure_mssg = "destroy failed after unpin.\n";
            }
            else {
                file_ptr->shared->cache = NULL;
            }
        }

        if (saved_cache != NULL) {

            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        }

        /* call takedown_cache() with a NULL file_ptr parameter.
         * This causes the function to close and delete the file,
         * while skipping the call to H5C_dest().
         */
        takedown_cache(NULL, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_destroy_pinned_err() */

/*-------------------------------------------------------------------------
 * Function:    check_destroy_protected_err()
 *
 * Purpose:    Verify that an attempt to destroy the cache when it contains
 *        a protected entry will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_destroy_protected_err(void)
{
    const char *fcn_name = "check_destroy_protected_err";
    H5F_t *     file_ptr = NULL;

    TESTING("destroy cache with protected entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, and try to flush.  This
     * should fail.  Unprotect the entry and flush again -- should
     * succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        if (H5C_dest(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT) >= 0) {

            pass         = FALSE;
            failure_mssg = "destroy succeeded on cache with protected entry.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);

            if (H5C_dest(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT) < 0) {

                pass         = FALSE;
                failure_mssg = "destroy failed after unprotect.\n";
            }
            else {
                file_ptr->shared->cache = NULL;
            }
        }

        if (saved_cache != NULL) {

            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        }

        /* call takedown_cache() with a NULL file_ptr parameter.
         * This causes the function to close and delete the file,
         * while skipping the call to H5C_dest().
         */
        takedown_cache(NULL, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_destroy_protected_err() */

/*-------------------------------------------------------------------------
 * Function:    check_duplicate_insert_err()
 *
 * Purpose:    Verify that an attempt to insert and entry that is
 *        alread in the cache will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_duplicate_insert_err(void)
{
    const char *  fcn_name = "check_duplicate_insert_err";
    herr_t        result   = -1;
    H5F_t *       file_ptr = NULL;
    test_entry_t *base_addr;
    test_entry_t *entry_ptr;

    TESTING("duplicate entry insertion error");

    pass = TRUE;

    /* allocate a cache, protect an entry, and then try to insert
     * the entry again.  This should fail.  Unprotect the entry and
     * destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        if (pass) {

            base_addr = entries[0];
            entry_ptr = &(base_addr[0]);

            result = H5C_insert_entry(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                      &(types[0]), entry_ptr->addr, (void *)entry_ptr, H5C__NO_FLAGS_SET);

            if (result >= 0) {

                pass         = FALSE;
                failure_mssg = "insert of duplicate entry succeeded.\n";
            }
            else {

                unprotect_entry(file_ptr, 0, 0, H5C__DIRTIED_FLAG);

                takedown_cache(file_ptr, FALSE, FALSE);
            }
        }
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s(): failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_duplicate_insert_err() */

/*-------------------------------------------------------------------------
 * Function:    check_move_err()
 *
 * Purpose:    Verify that an attempt to move an entry to the address
 *        of an existing entry will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_move_err(void)
{
    const char *  fcn_name = "check_move_err()";
    herr_t        result;
    H5F_t *       file_ptr  = NULL;
    H5C_t *       cache_ptr = NULL;
    test_entry_t *entry_0_0_ptr;
    test_entry_t *entry_0_1_ptr;
    test_entry_t *entry_1_0_ptr;

    TESTING("move to existing entry errors");

    pass = TRUE;

    /* allocate a cache, and insert several entries.  Try to move
     * entries to other entries resident in the cache.  This should
     * fail.  Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;

        insert_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, 0, 1, H5C__NO_FLAGS_SET);
        insert_entry(file_ptr, 1, 0, H5C__NO_FLAGS_SET);

        entry_0_0_ptr = &((entries[0])[0]);
        entry_0_1_ptr = &((entries[0])[1]);
        entry_1_0_ptr = &((entries[1])[0]);
    }

    if (pass) {

        result = H5C_move_entry(cache_ptr, &(types[0]), entry_0_0_ptr->addr, entry_0_1_ptr->addr);

        if (result >= 0) {

            pass         = FALSE;
            failure_mssg = "move to addr of same type succeeded.\n";
        }
    }

    if (pass) {

        result = H5C_move_entry(cache_ptr, &(types[0]), entry_0_0_ptr->addr, entry_1_0_ptr->addr);

        if (result >= 0) {

            pass         = FALSE;
            failure_mssg = "move to addr of different type succeeded.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_move_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_pin_err()
 *
 * Purpose:    Verify that an attempt to pin an entry that is already
 *        pinned will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/24/06
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_pin_err(void)
{
    const char *  fcn_name = "check_double_pin_err()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("pin a pinned entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, unprotect it with the pin flag,
     * protect it again, and then try to unprotect it again with the pin
     * flag.  This should fail.  Unpin the entry and destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                               entry_ptr->addr, (void *)entry_ptr, H5C__PIN_ENTRY_FLAG);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to pin a pinned entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_pin_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_unpin_err()
 *
 * Purpose:    Verify that an attempt to unpin an unpinned entry will
 *         generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/24/06
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_unpin_err(void)
{
    const char *  fcn_name = "check_double_unpin_err()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("unpin an unpinned entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, unprotect it with the unpin flag.
     * -- This should fail.
     *
     * Try again with H5C_unpin_entry -- this should also fail.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                               entry_ptr->addr, (void *)entry_ptr, H5C__UNPIN_ENTRY_FLAG);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to unpin an unpinned entry succeeded 1.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        }
    }

    if (pass) {

        result = H5C_unpin_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to unpin an unpinned entry succeeded 2.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_unpin_err() */

/*-------------------------------------------------------------------------
 * Function:    check_pin_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_pin_protected_entry()
 *         generate errors as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/24/06
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_pin_entry_errs(void)
{
    const char *  fcn_name = "check_pin_entry_errs()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("pin entry related errors");

    pass = TRUE;

    /* Allocate a cache, protect an entry, unprotect it with no flags,
     * and then call H5C_pin_protected_entry() to pin it -- This should fail.
     *
     * Protect the entry again, unprotect it with a pin flag, protect it
     * again, and then call H5C_pin_protected_entry() to pin it -- This
     * should fail also.
     *
     * Unprotect the entry with the unpin flag.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to pin an unprotected entry succeeded.\n";
        }
        else {

            protect_entry(file_ptr, 0, 0);

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);

            protect_entry(file_ptr, 0, 0);
        }
    }

    if (pass) {

        result = H5C_pin_protected_entry((void *)entry_ptr);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to pin a pinned, protected entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__UNPIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_pin_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_double_protect_err()
 *
 * Purpose:    Verify that an attempt to protect an entry that is already
 *        protected will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_protect_err(void)
{
    const char *       fcn_name = "check_double_protect_err()";
    H5F_t *            file_ptr = NULL;
    test_entry_t *     entry_ptr;
    H5C_cache_entry_t *cache_entry_ptr;

    TESTING("protect a protected entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, and then try to protect
     * the entry again.  This should fail.  Unprotect the entry and
     * destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        cache_entry_ptr =
            (H5C_cache_entry_t *)H5C_protect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                             &(types[0]), entry_ptr->addr, NULL, H5C__NO_FLAGS_SET);

        if (cache_entry_ptr != NULL) {

            pass         = FALSE;
            failure_mssg = "attempt to protect a protected entry succeeded.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_protect_err() */

/*-------------------------------------------------------------------------
 * Function:    check_double_unprotect_err()
 *
 * Purpose:    Verify that an attempt to unprotect an entry that is already
 *        unprotected will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              6/24/04
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_double_unprotect_err(void)
{
    const char *  fcn_name = "check_double_unprotect_err()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("unprotect an unprotected entry error");

    pass = TRUE;

    /* allocate a cache, protect an entry, unprotect it, and then try to
     * unprotect the entry again.  This should fail.  Destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                               entry_ptr->addr, (void *)entry_ptr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to unprotect an unprotected entry succeeded 1.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_double_unprotect_err() */

/*-------------------------------------------------------------------------
 * Function:    check_mark_entry_dirty_errs()
 *
 * Purpose:    Verify that:
 *
 *        1) a call to H5C_mark_entry_dirty with
 *           and unpinned and unprotected entry will generate an
 *           error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              5/17/06
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_mark_entry_dirty_errs(void)
{
    const char *  fcn_name = "check_mark_entry_dirty_errs()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("mark entry dirty related errors");

    pass = TRUE;

    /* allocate a cache, protect an entry, unprotect the entry without
     * pinning it, and try to mark it dirty -- this should fail.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry(file_ptr, 0, 0);

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_mark_entry_dirty((void *)entry_ptr);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to dirty a unpinned and unprotected entry succeeded.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_mark_entry_dirty_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_expunge_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_expunge_entry()
 *         generate errors as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              7/6/06
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_expunge_entry_errs(void)
{
    const char *  fcn_name = "check_expunge_entry_errs()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("expunge entry related errors");

    pass = TRUE;

    /* Allocate a cache, protect an entry, and then call H5C_expunge_entry()
     * to expunge it -- this should fail
     *
     * Unprotect the the entry with the pinned flag, and then call
     * H5C_expunge_entry() again.  This should fail too.
     *
     * Finally, unpin the entry and call H5C_expunge_entry() yet again.
     * This should succeed.
     *
     * Destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        entry_ptr = &((entries[0])[0]);

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                                   entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to expunge a protected entry succeeded.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                                   entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to expunge a pinned entry succeeded.\n";
        }
        else {

            unpin_entry(0, 0);
        }
    }

    if (pass) {

        result = H5C_expunge_entry(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                                   entry_ptr->addr, H5C__NO_FLAGS_SET);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "attempt to expunge an unpinned and unprotected entry failed.\n";
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_expunge_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_resize_entry_errs()
 *
 * Purpose:    Verify that invalid calls to H5C_resize_entry()
 *         generates errors as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              7/7/06
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_resize_entry_errs(void)
{
    const char *  fcn_name = "check_resize_entry_errs()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("resize entry related errors");

    pass = TRUE;

    /* Allocate a cache, protect an entry, and then call
     * H5C_resize_entry() to resize it -- this should succeed.
     *
     * Unprotect the the entry with the pinned flag, and then call
     * H5C_resize_entry() again with new size of zero.
     * This should fail.
     *
     * Finally, unpin the entry and destroy the cache.
     * This should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        entry_ptr = &((entries[0])[0]);

        protect_entry(file_ptr, 0, 0);
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (size_t)1);

        if (result < 0) {

            pass         = FALSE;
            failure_mssg = "Call to H5C_resize_entry on a protected entry failed.\n";
        }
        else {

            unprotect_entry(file_ptr, 0, 0, H5C__PIN_ENTRY_FLAG);
        }
    }

    if (pass) {

        result = H5C_resize_entry((void *)entry_ptr, (size_t)0);

        if (result >= 0) {

            pass         = FALSE;
            failure_mssg = "Call to H5C_resize_entry with 0 new size succeeded.\n";
        }
        else {

            unpin_entry(0, 0);
        }
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_resize_entry_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_unprotect_ro_dirty_err()
 *
 * Purpose:    If an entry is protected read only, verify that unprotecting
 *         it dirty will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/3/07
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_unprotect_ro_dirty_err(void)
{
    const char *  fcn_name = "check_unprotect_ro_dirty_err()";
    herr_t        result;
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;

    TESTING("unprotect a read only entry dirty error");

    pass = TRUE;

    /* allocate a cache, protect an entry read only, and then unprotect it
     * with the dirtied flag set.  This should fail.  Destroy the cache
     * -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                               entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

        if (result >= 0) {

            pass         = FALSE;
            failure_mssg = "attempt to unprotect a ro entry dirty succeeded 1.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    /* allocate a another cache, protect an entry read only twice, and
     * then unprotect it with the dirtied flag set.  This should fail.
     * Unprotect it with no flags set twice and then destroy the cache.
     * This should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry_ro(file_ptr, 0, 0);
        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        result = H5C_unprotect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT, &(types[0]),
                               entry_ptr->addr, (void *)entry_ptr, H5C__DIRTIED_FLAG);

        if (result > 0) {

            pass         = FALSE;
            failure_mssg = "attempt to unprotect a ro entry dirty succeeded 2.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_unprotect_ro_dirty_err() */

/*-------------------------------------------------------------------------
 * Function:    check_protect_ro_rw_err()
 *
 * Purpose:    If an entry is protected read only, verify that protecting
 *         it rw will generate an error.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              4/9/07
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_protect_ro_rw_err(void)
{
    const char *  fcn_name = "check_protect_ro_rw_err()";
    H5F_t *       file_ptr = NULL;
    test_entry_t *entry_ptr;
    void *        thing_ptr = NULL;

    TESTING("protect a read only entry rw error");

    pass = TRUE;

    /* allocate a cache, protect an entry read only, and then try to protect
     * it again rw.  This should fail.
     *
     * Unprotect the entry and destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        protect_entry_ro(file_ptr, 0, 0);

        entry_ptr = &((entries[0])[0]);
    }

    if (pass) {

        thing_ptr =
            (H5C_cache_entry_t *)H5C_protect(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT,
                                             &(types[0]), entry_ptr->addr, NULL, H5C__NO_FLAGS_SET);

        if (thing_ptr != NULL) {

            pass         = FALSE;
            failure_mssg = "attempt to protect a ro entry rw succeeded.\n";
        }
    }

    if (pass) {

        unprotect_entry(file_ptr, 0, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_protect_ro_rw_err() */

/*-------------------------------------------------------------------------
 * Function:    check_evictions_enabled_err()
 *
 * Purpose:    Verify that H5C_get_evictions_enabled() and
 *              H5C_set_evictions_enabled() generate errors as expected.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              8/3/07
 *
 * Modifications:
 *
 *        None.
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_check_evictions_enabled_err(void)
{
    const char *fcn_name = "check_evictions_enabled_err()";
    herr_t      result;
    hbool_t     evictions_enabled;
    H5F_t *     file_ptr  = NULL;
    H5C_t *     cache_ptr = NULL;

    TESTING("get/set evictions enabled errors");

    pass = TRUE;

    /* allocate a cache.
     *
     * Call H5C_get_evictions_enabled(), passing it a NULL cache_ptr,
     * should fail.
     *
     * Repeat with a NULL evictions_enabled_ptr, should fail as well.
     *
     * Configure the cache to use auto cache resize.  Call
     * H5C_set_evictions_enabled() to disable evictions.  Should fail.
     *
     * Unprotect the entry and destroy the cache -- should succeed.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_get_evictions_enabled(NULL, &evictions_enabled);

        if (result == SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_evictions_enabled(cache_ptr, NULL);

        if (result == SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 2.\n";
        }
    }

    if (pass) {

        result = H5C_set_evictions_enabled(cache_ptr, TRUE);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_evictions_enabled failed().\n";
        }
    }

    if (pass) {

        (cache_ptr->resize_ctl).incr_mode = H5C_incr__threshold;

        result = H5C_get_evictions_enabled(cache_ptr, FALSE);

        if (result == SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 1.\n";
        }
        else if (cache_ptr->evictions_enabled == TRUE) {
        }

        (cache_ptr->resize_ctl).incr_mode = H5C_incr__off;
    }

    if (pass) {

        (cache_ptr->resize_ctl).decr_mode = H5C_decr__threshold;

        result = H5C_get_evictions_enabled(cache_ptr, FALSE);

        if (result == SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_evictions_enabled succeeded() 2.\n";
        }

        (cache_ptr->resize_ctl).decr_mode = H5C_decr__off;
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_evictions_enabled_err() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize()
 *
 * Purpose:    Exercise the automatic cache resizing functionality.
 *        The objective is to operate the auto-resize code in
 *        all possible modes.  Unfortunately, there are quite
 *        a few of them.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/29/04
 *
 * Modifications:
 *
 *              John Mainzer 1/8/08
 *              Added a basic set of tests for the flash cache size
 *              increment code.
 *
 *-------------------------------------------------------------------------
 */

hbool_t                rpt_fcn_called = FALSE;
enum H5C_resize_status rpt_status;

static void
test_rpt_fcn(H5_ATTR_UNUSED H5C_t *cache_ptr, H5_ATTR_UNUSED int32_t version, H5_ATTR_UNUSED double hit_rate,
             enum H5C_resize_status status, H5_ATTR_UNUSED size_t old_max_cache_size,
             H5_ATTR_UNUSED size_t new_max_cache_size, H5_ATTR_UNUSED size_t old_min_clean_size,
             H5_ATTR_UNUSED size_t new_min_clean_size)
{
    rpt_fcn_called = TRUE;
    rpt_status     = status;
}

static unsigned
check_auto_cache_resize(void)
{
    const char *        fcn_name      = "check_auto_cache_resize()";
    hbool_t             show_progress = FALSE;
    herr_t              result;
    int32_t             i;
    int32_t             checkpoint    = 0;
    H5F_t *             file_ptr      = NULL;
    H5C_t *             cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5f,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.1f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.05f};

    TESTING("automatic cache resizing");

    pass = TRUE;

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* allocate a cache, enable automatic cache resizing, and then force
     * the cache through all its operational modes.  Verify that all
     * performs as expected.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache not full -- should result in not
     * full status.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != not_full) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should result in increase
     * of cache size from .5 to 1 meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache not full -- should result in not
     * full status.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 1 to 2 meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 4.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 2 to 4 meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 4 to 8 meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 6.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 8 to 12 meg.  Note that max increase reduced the
     * size of the increase.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (12 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 7.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full again -- should result in increase
     * of cache size from 12 to 14 meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (14 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 8.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full and at maximum size -- should
     * in no change in size and a result of at_max_size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (14 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 9.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate with cache full and at maximum size -- should
     * result in a decrease from 14 to 13 Meg -- note that max decrease
     * reduced the size of the reduction
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (13 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 1024 * 1024 + 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 10.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* the current cache configuration is inconvenient for testing cache
     * size reduction, so lets change it some something easier to work
     * with.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1000 * 1000 + 10;

        auto_size_ctl.min_clean_fraction = 0.1f;

        auto_size_ctl.max_size = 8 * 1000 * 1000;
        auto_size_ctl.min_size = 500 * 1000;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1000 * 1000);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1000);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (400 * 1000 + 1))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate  -- should result in a decrease from ~4 to ~3
     * M -- note that max decrease reduces the size of the reduction
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (300 * 1000 + 1))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 11.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~3
     * to ~2 M -- again note that max decrease reduces the size of the
     * reduction.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (200 * 1000 + 1))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 12.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~2
     * to ~1 M -- again note that max decrease reduces the size of the
     * reduction, but only by five bites.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1 * 1000 * 1000 + 10)) ||
            (cache_ptr->min_clean_size != (100 * 1000 + 1))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 13.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease from ~1
     * to ~0.5 M -- max decrease is no longer a factor.  New size is five
     * bytes above the minimum.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (500 * 1000 + 5)) || (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 14.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again  -- should result in a decrease of five
     * bytes to the minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 15.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- Already at minimum size so no change in
     * cache size and result should be at_min_size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 16.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force in range hit rate  -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 900)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i + 1000);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i + 1000, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 17.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should
     * increase cache size from .5 to 1 M.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (1 * 1000 * 1000)) || (cache_ptr->min_clean_size != (100 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 18.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease to the
     * minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (500 * 1000)) ||
            (cache_ptr->min_clean_size != (50 * 1000))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 19.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * now do some tests with the maximum increase and decrease sizes
     * disabled.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 4.0f;

        auto_size_ctl.apply_max_increment = FALSE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.25f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease to the
     * minimum cache size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 20.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- should increase cache size
     * from 1 to 4 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 21.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again with cache full -- should increase cache
     * size from 4 to 16 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (16 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (8 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 22.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should result in a decrease cache size from
     * 16 to 4 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 23.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * We have tested the threshold increment and decrement modes.
     * must now test the ageout decrement mode.
     *
     * Reconfigure the cache for this testing.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 24.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 25.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 26.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 27.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2001 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2001 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 28.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (1001 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1001 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 29.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 30.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eigth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 31.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* ninth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 32.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* tenth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (1000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(1000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 33.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* eleventh epoch -- cache size reduction */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 34.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* twelth epoch -- at minimum size so no more ageouts */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 35.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* repeat the above test, but with max_decrement enabled to see
     * if that features works as it should.  Note that this will change
     * the structure of the test a bit.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 4.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 36.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 37.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 38.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 39.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (7 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 40.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (6 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 41.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- keep hit rate at 100%, and keep 2K entries active.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (5 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (5 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 42.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eigth epoch -- still 100% hit rate
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 43.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* ninth epoch --hit rate at 100%.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 44.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* tenth epoch -- still 100% hit rate
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 45.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eleventh epoch -- hit rate at 100% -- starting to stableize
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 46.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* twelth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 47.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* thirteenth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 48.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* fourteenth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1001 * 1024 + MONSTER_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * 512 + MONSTER_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 49.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* fifteenth epoch -- cache size reduction */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 50.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* sixteenth epoch -- at minimum size so no more ageouts */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 51.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* repeat the test yet again, this time with empty reserve enabled.
     * Again, some structural changes in the test are necessary.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.5f; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 1024 byte entries -- nothing should happen
     * for three epochs while the markers are inserted into the cache
     *
     * Note that hit rate will be zero, so the cache will attempt to
     * increase its size. Since we are already at max size, it will
     * not be able to.
     */
    if (pass) { /* first epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 52.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch */

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 53.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch */

        rpt_fcn_called = FALSE;
        i              = 2000;
        while ((pass) && (i < 3000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 54.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- If the hit rate were above the lower threshold,
     * we would see cache size reduction now.  However, nothing will
     * happen until we get the hit rate above the lower threshold.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 55.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- force the hit rate to 100%.  We should see cache size
     * reduction now.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (4002 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(4002 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 56.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2002 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2002 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 57.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force the hit rate to 100% again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 58.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eigth epoch -- force the hit rate to 100% again -- should be steady
     * state.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 3000;
        while ((pass) && (i < 4000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 59.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* now just bang on one entry -- after three epochs, this should
     * get all entries other than the one evicted, and the cache size
     * should be decreased to the minimum.
     */
    if (pass) { /* ninth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (int)(2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 60.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* tenth epoch */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->max_cache_size != (2000 * 1024)) ||
            (cache_ptr->min_clean_size != (2000 * 512))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 61.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* eleventh epoch -- cache size reduction */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 62.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* twelth epoch -- at minimum size so no more ageouts */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_min_size) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) || (cache_ptr->index_len != 2) ||
            (cache_ptr->index_size != MONSTER_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 63.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the test again, this time using the age out with threshold
     * mode.  To simplify the testing, set epochs to eviction to 1.
     *
     * Again, there are some minor structural changes in the test.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        /* NOTE: upper_hr_threshold MUST be type double (not float)
         * or the cache test will fail on 64-bit systems.
         */
        auto_size_ctl.upper_hr_threshold = H5_DOUBLE(0.999); /* for ease of testing */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 7.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 6.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 4K byte entries -- increment mode is off,
     * so cache size reduction should kick in as soon as we get the
     * hit rate above .999.
     */
    if (pass) { /* first epoch -- hit rate 0 */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 64.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch -- hit rate 0 */

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 65.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* third epoch -- hit rate 1.0 -- should see decrease */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 66.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- load up the cache again -- hit rate 0 */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 67.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- still loading up the cache -- hit rate 0 */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 68.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- force hit rate to .998 -- should be no reduction */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1002;
        while ((pass) && (i < 2002)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (1001 * LARGE_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1001 * LARGE_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 69.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- force hit rate to .999 -- should see reduction
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1003;
        while ((pass) && (i < 2003)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (1000 * MEDIUM_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != (1000 * MEDIUM_ENTRY_SIZE / 2))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 70.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* We have now tested all the major ageout modes individually.
     * Lets try them all together to look for unexpected interactions
     * and/or bugs.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1000 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1000 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999f; /* for ease of testing */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.5f; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 8.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 7.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fill the cache with 4K byte entries -- increment mode is threshold,
     * so the decrease code will not be executed until the hit rate exceeds
     * .75.
     */
    if (pass) { /* first epoch -- hit rate 0 */

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 71.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) { /* second epoch -- hit rate 0 */

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 72.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* third epoch -- force the hit rate to 1.0.  Should be no change
     * in the cache size due to the combination of the empty reserve
     * and the max decrease.  Max decrease will limit the evictions
     * in any one epoch, and the empty reserve will not permit cache
     * size reduction unless the specified empty reserve is maintained.
     *
     * In this epoch, all we should see is a reduction in the index size.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (7 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 73.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (6 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 74.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (5 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 75.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixth epoch -- hit rate still 1.0.  Index size should decrease,
     * but otherwise no change expected.  Note that the cache size is
     * now just on the edge of meeting the clean reserve.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 76.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* seventh epoch -- hit rate still 1.0.  No change in index size expected.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, LARGE_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 77.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eighth epoch -- start loading 1 KB entries.  Hit rate 0 so
     * decrease code shouldn't be called.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != at_max_size) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (5 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 78.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* ninth epoch -- access the 1 KB entries again, driving the hit rate
     * to 1.0.  Decrease code should be triggered, but the max decrease
     * should prevent the empty reserve from being met in this epoch.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1000 * 1024)) ||
            (cache_ptr->index_size != (4 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 79.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* tenth epoch -- access the 1 KB entries yet again, forcing hit rate
     * to 1.0.  Decrease code should be triggered, and the empty reserve
     * should finally be met.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (7 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (7 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (3 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 80.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* eleventh epoch -- access the 1 KB entries yet again, forcing hit rate
     * to 1.0.  Decrease code should be triggered, and the empty reserve
     * should be met again.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (6 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1000 * 1024)) ||
            (cache_ptr->index_size != (2 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 81.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* twelth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (5 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (5 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 82.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* thirteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (4 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 83.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fourteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (3 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1000 * 1024 / 2)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 84.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* fifteenth  epoch -- hit rate 1.0 -- decrease as before.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 85.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* sixteenth  epoch -- hit rate 1.0 -- should be stable now
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1000 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1000 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 86.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    /* now test the flash cache size increment code.  At least at present,
     * there should be no interaction between the regular auto-resize
     * code and the flash cache size increment code other than a reset
     * of the counter and stats collection used by the regular auto-resize
     * code.  Thus we do only limited tests of the two pieces of code
     * operating together.
     *
     * Start with simple test to verify that the flash cache increment
     * code increases the cache size when and as expected.
     */

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* allocate a cache, enable the flash cache size increase code, and
     * then force the flash size increase code through all its operational
     * modes.  Verify that all performs as expected.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* now repeat the above tests using the add space flash cache size
     * increment algorithm.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 64 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 1024 * 1024;
        auto_size_ctl.min_size = 5 * 1024;

        auto_size_ctl.epoch_length = 100;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (32 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        auto_size_ctl.flash_multiple  = 1.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999f; /* for ease of testing */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1000 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.5f; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 12.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (64 * 1024)) || (cache_ptr->min_clean_size != (32 * 1024)) ||
            (cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (0).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a huge entry into the cache */
    if (pass) {

        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 0);

        if (pass) {
            unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
        }

        if ((pass) && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                        (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                        (cache_ptr->index_size != HUGE_ENTRY_SIZE) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (1).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now load a monster entry.  Since a monster entry is larger than
     * half the size of the cache, and there is not sufficient space
     * for a monster entry in the cache, we will add space to the
     * cache to make room for the entry.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

        if (pass) {
            unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
        }

        if ((pass) && (((cache_ptr->max_cache_size != (80 * 1024)) ||
                        (cache_ptr->min_clean_size != (40 * 1024)) || (cache_ptr->index_len != 2) ||
                        (cache_ptr->index_size != (HUGE_ENTRY_SIZE + MONSTER_ENTRY_SIZE)) ||
                        (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (2).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a second monster entry.  Since the monster entry is larger
     * than half the size of the cache yet again, and there is not
     * sufficient space for the monster entry in the cache, we again
     * add space to the cache to make space for the entry.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (144 * 1024)) ||
                        (cache_ptr->min_clean_size != (72 * 1024)) || (cache_ptr->index_len != 3) ||
                        (cache_ptr->index_size != ((2 * MONSTER_ENTRY_SIZE) + HUGE_ENTRY_SIZE)) ||
                        (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (3).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load a third moster entry.  Should be no cache size increase this
     * time.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 2);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);

        if ((pass) &&
            (((cache_ptr->max_cache_size != (144 * 1024)) || (cache_ptr->min_clean_size != (72 * 1024)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != (2 * MONSTER_ENTRY_SIZE)) ||
              (cache_ptr->cache_accesses != 2)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (4).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* delete existing entries to prepare for next test, and reset
     * the size of the cache.
     */
    if (pass) {

        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 1);
        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 2);

        if (pass) {

            result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = FALSE;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
            }
        }

        if ((pass) && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                        (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 0) ||
                        (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (5).\n";
        }
    }

    /* repeat the above basic test, only this time, use inserts to add
     * entries to the cache, not protects.
     */

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* insert a huge entry into the cache */
    if (pass) {

        insert_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        /* protect and unprotect a couple times to increment cache_accesses */
        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);
        protect_entry(file_ptr, HUGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, HUGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                        (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                        (cache_ptr->index_size != HUGE_ENTRY_SIZE) || (cache_ptr->cache_accesses != 2)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (6).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now insert a monster entry.  Since a monster entry is larger than
     * half the size of the cache, and there is not sufficient space
     * for a monster entry in the cache, we will add space to the
     * cache to make room for the entry.
     */
    if (pass) {

        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 4, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (80 * 1024)) ||
                        (cache_ptr->min_clean_size != (40 * 1024)) || (cache_ptr->index_len != 2) ||
                        (cache_ptr->index_size != HUGE_ENTRY_SIZE + MONSTER_ENTRY_SIZE) ||
                        (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (7).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Insert a second monster entry.  Cache size should increase again.
     */
    if (pass) {

        insert_entry(file_ptr, MONSTER_ENTRY_TYPE, 5, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (144 * 1024)) ||
                        (cache_ptr->min_clean_size != (72 * 1024)) || (cache_ptr->index_len != 3) ||
                        (cache_ptr->index_size != 2 * MONSTER_ENTRY_SIZE + HUGE_ENTRY_SIZE) ||
                        (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (8).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Insert a third monster entry.  Should be no cache size increase this
     * time.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 6);

        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 6, H5C__NO_FLAGS_SET);

        if ((pass) &&
            (((cache_ptr->max_cache_size != (144 * 1024)) || (cache_ptr->min_clean_size != (72 * 1024)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != (2 * MONSTER_ENTRY_SIZE)) ||
              (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (9).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* delete existing entries to prepare for next test, and reset
     * the size of the cache.  We must also change the size of the needed
     * variable entries before we run the test, so will protect and
     * unprotect them now so as to get the correct initial size.
     */
    if (pass) {

        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 5);
        expunge_entry(file_ptr, MONSTER_ENTRY_TYPE, 6);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 1024, TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 1024, TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 1024, TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, 1024, TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, H5C__DIRTIED_FLAG);

        flush_cache(file_ptr, TRUE, FALSE, FALSE);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = FALSE;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
            }
        }

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 0) ||
                        (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (10).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now load the variable entries into the cache */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__NO_FLAGS_SET);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (11).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a variable entry, and re-size it to 3K.  Should be
     * no effect on the size of the cache.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (3 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 6 * 1024) || (cache_ptr->cache_accesses != 5)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (12).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect the variable entry again, and re-size it to 10K.  Should
     * resize the cache to 13 KB.  Note that cache_accesses will be 0
     * in this case, since cache_accesses is incremented on the protect.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (10 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                        (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (13).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a second variable entry, and re-size it to 10K.  Should
     * resize to 22 KB.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (10 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (14).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect a third variable entry, and re-size it to 10K.  Should
     * be no change in cache size.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (10 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (15).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* re-size the variable entries back down to their initial size, and
     * restore the cache to its initial size as well, in preparation
     * for the next test.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = FALSE;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 14.\n";
            }
        }

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (16).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now test flash cache resizes with pinned entries...
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 2 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (6 * 512)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 5 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (17).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                        (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (18).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (19).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (20).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Unpin the entries.  Note that no entries are evicted as we don't
     * load any entries.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__UNPIN_ENTRY_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (21).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* re-size the variable entries back down to their initial size, and
     * restore the cache to its initial size as well, in preparation
     * for the next test.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__DIRTIED_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, (1 * 1024), TRUE);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__DIRTIED_FLAG);

        if (pass) {

            auto_size_ctl.initial_size = 6 * 1024;
            result                     = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

            if (result != SUCCEED) {

                pass         = FALSE;
                failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
            }
        }

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (3 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 4 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (22).\n";
        }
    }

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 2 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (6 * 1024)) ||
                        (cache_ptr->min_clean_size != (6 * 512)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 5 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (23).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (13 * 1024)) ||
                        (cache_ptr->min_clean_size != (13 * 512)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 13 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (24).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 22 * 1024) || (cache_ptr->cache_accesses != 0)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (25).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__PIN_ENTRY_FLAG);
        resize_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, 10 * 1024, TRUE);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 1)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (26).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Unpin the entries.  Note that no entries are evicted as we don't
     * load any entries.
     */
    if (pass) {

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11, H5C__UNPIN_ENTRY_FLAG);

        protect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        unprotect_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12, H5C__UNPIN_ENTRY_FLAG);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 4) ||
                        (cache_ptr->index_size != 31 * 1024) || (cache_ptr->cache_accesses != 4)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (27).\n";
        }
    }

    /* We have finished a basic check of the flash cache size increment
     * code.  Tidy up for a more extensive test...
     */
    if (pass) {

        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 10);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 11);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 12);
        expunge_entry(file_ptr, VARIABLE_ENTRY_TYPE, 13);

        if ((pass) && (((cache_ptr->max_cache_size != (22 * 1024)) ||
                        (cache_ptr->min_clean_size != (11 * 1024)) || (cache_ptr->index_len != 0) ||
                        (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 4)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (28).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* ...and then reconfigure.   Note that we change the flash_multiple
     * and flash_threshold just to make sure that such changed perform
     * as expected.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 20 * 1024;
        auto_size_ctl.min_size = 4 * 1024;

        auto_size_ctl.epoch_length = 100;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.4f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.999f; /* for ease of testing */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (2 * 1024);

        auto_size_ctl.epochs_before_eviction = 1; /* for ease of testing */

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.5f; /* for ease of testing */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024)) || (cache_ptr->min_clean_size != (4 * 512)) ||
            (cache_ptr->index_len != 0) || (cache_ptr->index_size != 0) || (cache_ptr->cache_accesses != 0)) {

            pass         = FALSE;
            failure_mssg = "bad cache after initialization 15.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect a large entry -- no change in cache size since
     * a large entry will just fill the available space in the cache.
     */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if ((pass) &&
            (((cache_ptr->max_cache_size != (4 * 1024)) || (cache_ptr->min_clean_size != (4 * 512)) ||
              (cache_ptr->index_len != 1) || (cache_ptr->index_size != LARGE_ENTRY_SIZE) ||
              (cache_ptr->cache_accesses != 1) || (rpt_fcn_called == TRUE)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (29).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect another a large entry -- should trigger a
     * flash cache size increase to 12 KB (remember that flash_multiple is
     * set to 2.0).
     */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 1);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 1, H5C__NO_FLAGS_SET);

        if ((pass) &&
            (((cache_ptr->max_cache_size != (12 * 1024)) || (cache_ptr->min_clean_size != (12 * 512)) ||
              (cache_ptr->index_len != 2) || (cache_ptr->index_size != 2 * LARGE_ENTRY_SIZE) ||
              (cache_ptr->cache_accesses != 1) || (rpt_fcn_called != TRUE)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (30).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* protect and unprotect two more large entries -- shouldnt trigger a
     * flash cache size increase.
     */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 2);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 2, H5C__NO_FLAGS_SET);
        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 3);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 3, H5C__NO_FLAGS_SET);

        if ((pass) &&
            (((cache_ptr->max_cache_size != (12 * 1024)) || (cache_ptr->min_clean_size != (12 * 512)) ||
              (cache_ptr->index_len != 3) || (cache_ptr->index_size != 3 * LARGE_ENTRY_SIZE) ||
              (cache_ptr->cache_accesses != 3) || (rpt_fcn_called != FALSE)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (31).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* do many accesses of a single entry to talk the cache into reducing
     * its size to the minimum.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, TINY_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, TINY_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->max_cache_size != (4 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024)) || (cache_ptr->index_size != (1 * TINY_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (32).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Force another flash increase */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (4 * 1024 + 128)) ||
                        (cache_ptr->min_clean_size != (2 * 1024 + 64)) || (cache_ptr->index_len != 2) ||
                        (cache_ptr->index_size != LARGE_ENTRY_SIZE + TINY_ENTRY_SIZE) ||
                        (cache_ptr->cache_accesses != 1) || (rpt_fcn_called == FALSE) ||
                        (rpt_status != flash_increase)))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (33).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force regular size increase up to maximum */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 500)) {
            protect_entry(file_ptr, TINY_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, TINY_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((cache_ptr->max_cache_size != (20 * 1024)) || (cache_ptr->min_clean_size != (10 * 1024)) ||
            (rpt_fcn_called == FALSE) || (rpt_status != at_max_size)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache config (34).\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_disable()
 *
 * Purpose:    Test the various ways in which the resize code can
 *        be disabled.  Unfortunately, there are quite a few of them.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              12/16/04
 *
 * Modifications:
 *
 *              Added code to include the flash cache size increment
 *              code in this test.
 *                                                      JRM -- 1/10/08
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_disable(void)
{
    const char *        fcn_name      = "check_auto_cache_resize_disable()";
    hbool_t             show_progress = FALSE;
    herr_t              result;
    int32_t             i;
    int32_t             checkpoint    = 0;
    H5F_t *             file_ptr      = NULL;
    H5C_t *             cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5f,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 1.0f,
        /* double      flash_threshold        = */ 0.25f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.1f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.05f};

    TESTING("automatic cache resize disable");

    pass = TRUE;

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* allocate a cache, enable automatic cache resizing, and then force
     * the cache through all its operational modes.  Verify that all
     * performs as expected.
     */

    if (pass) {

        reset_entries();

        file_ptr = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));

        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "file_ptr NULL from setup_cache.";
        }
        else {

            cache_ptr = file_ptr->shared->cache;
        }
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /******************************************************************
     * So far, we have forced the auto cache resize through all modes
     * other than increase_disabled and decrease_disabled.  Force these
     * modes now.  Note that there are several ways we can reach these
     * modes.
     ******************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 1.0f; /* disable size increases */

        auto_size_ctl.apply_max_increment = FALSE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != increase_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != increase_disabled) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling increase through the lower
     * threshold instead of the increment.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0f; /* disable size increases */

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = FALSE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;
        auto_size_ctl.decrement          = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 4.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 6.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests yet again, disabling increase through the
     * incr_mode.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = FALSE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate with cache full -- increase disabled so should
     * be no change in cache size, and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 7.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- make sure that we haven't disabled decreases.
     * should result in a decrease cache size from 4 to 2 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 8.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate again -- increase disabled so should
     * be no change in cache size, and result should be increase_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_increase_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 9.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now, disable size decreases, and repeat the above tests.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 1.0f; /* disable size decreases */

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 4.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 10.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 11.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 12.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling decrease through the upper
     * threshold instead of the decrement.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0f; /* disable size decreases */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 13.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 14.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 15.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Repeat the above tests, disabling decrease through the decr_mode.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 7.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 6.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 16.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 17.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate again -- should be no change in cache size,
     * and result should be in_spec.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 18.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now do tests disabling size decrement in age out mode.
     *
     * Start by disabling size decrement by setting max_decrement to zero.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = 0; /* disable decrement */

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 8.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 7.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, TRUE, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 19.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 20.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 21.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 22.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This will see to it that there are
     * many entries that could be aged out were decreases enabled.
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 23.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now disable size decrement in age out mode via the empty reserve.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 1.0f; /* disable decrement */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 9.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 8.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, TRUE, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 24.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 25.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 26.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 27.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This will see to it that there are
     * many entries that could be aged out were decreases enabled.
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 28.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now work with age out with threshold.  One can argue that we should
     * repeat the above age out tests with age out with threshold, but the
     * same code is executed in both cases so I don't see the point.  If
     * that ever changes, this test should be updated.
     *
     * There is only one way of disabling decrements that is peculiar
     * to age out with threshold, which is to set the upper threshold
     * to 1.0.  Test this now.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 1.0f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 10.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 9.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        /* flush the cache and destroy all entries so we start from a known point */
        flush_cache(file_ptr, TRUE, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* load up the cache with small entries.  Note that it will take an
     * epoch for the ageout code to initialize itself if it is enabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 29.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Load up some more small entries.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 1000;
        while ((pass) && (i < 2000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != not_full) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 30.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now force a high hit rate so that the size increase code is
     * is satisfied.  We would see a decrease here if decrease were
     * possible, but the upper threshold cannot be met, so no decrease.
     *
     * rpt_status should be decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024)) || (cache_ptr->index_len != 2000) ||
            (cache_ptr->index_size != 2000 * SMALL_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 31.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- cache size should increase from 4 to 6 Meg.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != increase) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 32.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* just bang on a single entry.  This keeps the hit rate high, and sees
     * to it that there are many entries that could be aged out were
     * decreases enabled.
     *
     * Should be no change in cache size, and result should be
     * decrease_disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 999);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 999, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (cache_ptr->size_decrease_possible) || (rpt_status != decrease_disabled) ||
            (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 33.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /*********************************************************************
     * Finally, use the auto cache resize code to set the size of the
     * cache and keep it there.  Again, due to the complexity of the
     * interface, there are lots of ways of doing this.  We have to
     * check them all.
     *********************************************************************/

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 2 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0f; /* disable size increases */

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0f; /* disable size decreases */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 11.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 10.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 34.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (2 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 35.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.25f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 1.0f; /* disable size increment */

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 1.0f; /* disable size decrement */

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 12.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 11.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 36.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 37.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = FALSE;
        auto_size_ctl.initial_size     = 2 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 6 * 1024 * 1024; /* no resize */
        auto_size_ctl.min_size = 6 * 1024 * 1024; /* no resize */

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 13.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 12.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 38.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (6 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (3 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 39.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.25f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 1.0f; /* disable size increment */

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 1.0f; /* disable size decrement */

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 14.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 13.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 40.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (1 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 41.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.0f; /* disable size increment */

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 1.0f; /* disable size decrement */

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 15.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 14.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 42.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 43.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 16 * 1024 * 1024;
        auto_size_ctl.min_size = 1 * 1024 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 16.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 15.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force low hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 44.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* force high hit rate -- should be no response as the auto-resize
     * code should be disabled.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);

            if (pass) {
                unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((rpt_fcn_called) || (cache_ptr->resize_enabled) || (cache_ptr->size_increase_possible) ||
            (cache_ptr->size_decrease_possible) || (cache_ptr->max_cache_size != (4 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (2 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 45.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now test the flash cache size increment code to verify that it
     * is disabled when it should be.
     *
     * Since the flash size increase code doesn't look at hit rate, or
     * use epochs (other than to start a new epoch if a flash cache size
     * increase is triggered), we go about these tests somewhat differently
     * than the rest of the tests in this function.
     *
     * As of this writing, there is only one flash cache size increment
     * mode (add space), which is triggered whenever the size of a newly
     * loaded or inserted entry, or the delta between old and new entry
     * sizes exceeds some fraction of the current maximum cache size, and
     * the cache doesn't have enough free space to accomodate the new/
     * resize entry without performing evictions.  The range of permissible
     * values for the flash_threshold (0.1 to 1.0 as of this writing), and
     * for the flash_multiple (0.1 to 10.0) do not permit the facility to
     * be turned off by configuration.  Thus, flash cache size increases
     * can be disabled only via the flash_incr_mode, and by setting the
     * current max_cache_size equal to max_size.
     *
     * We have already tested the latter in check_auto_cache_resize(), so
     * we need only thest the former here.  Do this by disabling flash
     * cache size increments via the flash_incr_mode, and then creating
     * situations that would trigger flash cache size increases were that
     * code enabled.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 64 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 256 * 1024;
        auto_size_ctl.min_size = 32 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__threshold;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (2 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 1.0f;
        auto_size_ctl.flash_threshold = 0.25f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = TRUE;
        auto_size_ctl.max_decrement       = (1 * 1024);

        auto_size_ctl.epochs_before_eviction = 3;

        auto_size_ctl.apply_empty_reserve = TRUE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 17.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (64 * 1024)) || (cache_ptr->min_clean_size != (32 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 16.\n";
        }
    }

    /* We have reduced the max cache size to well below the current index
     * size.  Protect and unprotect an entry to allow the cache to evict
     * entries and get within bounds
     */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, LARGE_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, LARGE_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                        (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                        (cache_ptr->index_size != LARGE_ENTRY_SIZE) || (rpt_fcn_called != FALSE)))) {

            HDfprintf(stdout, "\nmax_cache_size = %ld.\n", (long)(cache_ptr->max_cache_size));
            HDfprintf(stdout, "min_clean_size = %ld.\n", (long)(cache_ptr->min_clean_size));
            HDfprintf(stdout, "index_len = %ld.\n", (long)(cache_ptr->index_len));
            HDfprintf(stdout, "index_size = %ld.\n", (long)(cache_ptr->index_size));
            HDfprintf(stdout, "rpt_fcn_called = %ld.\n", (long)(rpt_fcn_called));

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 46.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now protect and unprotect a monster entry.  If the flash cache
     * size increment code was active, this would trigger an increase.
     * Verify that it doesn't.
     *
     * This finishes the additional tests needed for the flash cache
     * size increase code.
     */
    if (pass) {

        rpt_fcn_called = FALSE;

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);

        if ((pass) && (((cache_ptr->max_cache_size != (64 * 1024)) ||
                        (cache_ptr->min_clean_size != (32 * 1024)) || (cache_ptr->index_len != 1) ||
                        (cache_ptr->index_size != MONSTER_ENTRY_SIZE) || (rpt_fcn_called != FALSE)))) {

            HDfprintf(stdout, "\nmax_cache_size = %ld.\n", (long)(cache_ptr->max_cache_size));
            HDfprintf(stdout, "min_clean_size = %ld.\n", (long)(cache_ptr->min_clean_size));
            HDfprintf(stdout, "index_len = %ld.\n", (long)(cache_ptr->index_len));
            HDfprintf(stdout, "index_size = %ld.\n", (long)(cache_ptr->index_size));
            HDfprintf(stdout, "rpt_fcn_called = %ld.\n", (long)(rpt_fcn_called));

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 47.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_disable() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_epoch_markers()
 *
 * Purpose:    Verify that the auto-resize code manages epoch markers
 *        correctly.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              12/16/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_epoch_markers(void)
{
    const char *        fcn_name      = "check_auto_cache_resize_epoch_markers()";
    hbool_t             show_progress = FALSE;
    herr_t              result;
    int32_t             i;
    int32_t             j;
    int32_t             checkpoint    = 0;
    H5F_t *             file_ptr      = NULL;
    H5C_t *             cache_ptr     = NULL;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5f,

        /* size_t      max_size               = */ (14 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.1f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.05f};

    TESTING("automatic cache resize epoch marker management");

    pass = TRUE;

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Now make sure that we are managing the epoch markers correctly.
     */

    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 2.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Since we just created the cache, there should be no epoch markers
     * active.  Verify that this is true.
     */

    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 1.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, MEDIUM_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != in_spec) ||
            (cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * MEDIUM_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 0.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        j = 2;
        while ((pass) && (j <= 10)) {

            rpt_fcn_called = FALSE;
            i              = (j - 2) * 1000;
            while ((pass) && (i < (j - 1) * 1000)) {
                protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

                if (pass) {
                    unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
                }
                i++;
            }

            if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->epoch_markers_active != j)) {

                pass         = FALSE;
                failure_mssg = "Unexpected # of epoch markers 2.\n";
            }

            j++;
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* we now have a full complement of epoch markers -- see if
     * we get the expected reduction.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 9000;
        while ((pass) && (i < 10000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) ||
            (cache_ptr->max_cache_size != (10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE)) ||
            (cache_ptr->min_clean_size != ((10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE) / 2)) ||
            (cache_ptr->index_size != (10 * 1000 * SMALL_ENTRY_SIZE + MEDIUM_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 1.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* now reduce the epochs before eviction, and see if the cache
     * deletes the extra markers
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 3.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* There should be exactly one active epoch marker at present.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 1) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 3.\n";
        }
    }

    /* Now do an epochs worth of accesses, and verify that everything
     * not accessed in this epoch gets evicted, and the cache size
     * is reduced.
     */
    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 9000;
        while ((pass) && (i < 10000)) {
            protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

            if (pass) {
                unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }

        if ((!rpt_fcn_called) || (rpt_status != decrease) || (cache_ptr->max_cache_size != (512 * 1024)) ||
            (cache_ptr->min_clean_size != (256 * 1024)) ||
            (cache_ptr->index_size != (1 * 1000 * SMALL_ENTRY_SIZE))) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 2.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* There should be exactly one active epoch marker at present...
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 1) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 4.\n";
        }
    }

    /* shift the decrement mode to threshold, and verify that we remove
     * all epoch markers.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 1;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 4.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after set resize re-config 3.\n";
        }
    }

    /* ... and now there should be none.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 5.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* shift the decrement mode to age out with threshold.  Set epochs
     * before eviction to 10 again.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 5.\n";
        }
    }

    /* Verify that there are no active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 6.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* build up a full set of epoch markers. */
    if (pass) {

        j = 1;
        while ((pass) && (j <= 10)) {

            rpt_fcn_called = FALSE;
            i              = (j - 1) * 1000;
            while ((pass) && (i < j * 1000)) {
                protect_entry(file_ptr, SMALL_ENTRY_TYPE, i);

                if (pass) {
                    unprotect_entry(file_ptr, SMALL_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
                }
                i++;
            }

            if ((!rpt_fcn_called) || (rpt_status != in_spec) || (cache_ptr->epoch_markers_active != j)) {

                pass         = FALSE;
                failure_mssg = "Unexpected # of epoch markers 7.\n";
            }

            j++;
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* Verify that there are now 10 active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 10) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 8.\n";
        }
    }

    /* shift the decrement mode to off.  This should cause all epoch
     * markers to be removed.
     */
    if (pass) {

        auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        auto_size_ctl.rpt_fcn = test_rpt_fcn;

        auto_size_ctl.set_initial_size = TRUE;
        auto_size_ctl.initial_size     = 8 * 1024 * 1024;

        auto_size_ctl.min_clean_fraction = 0.5f;

        auto_size_ctl.max_size = 8 * 1024 * 1024;
        auto_size_ctl.min_size = 512 * 1024;

        auto_size_ctl.epoch_length = 1000;

        auto_size_ctl.incr_mode = H5C_incr__off;

        auto_size_ctl.lower_hr_threshold = 0.75f;

        auto_size_ctl.increment = 2.0f;

        auto_size_ctl.apply_max_increment = TRUE;
        auto_size_ctl.max_increment       = (4 * 1024 * 1024);

        auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        auto_size_ctl.flash_multiple  = 2.0f;
        auto_size_ctl.flash_threshold = 0.5f;

        auto_size_ctl.decr_mode = H5C_decr__off;

        auto_size_ctl.upper_hr_threshold = 0.995f;

        auto_size_ctl.decrement = 0.5f;

        auto_size_ctl.apply_max_decrement = FALSE;
        auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        auto_size_ctl.epochs_before_eviction = 10;

        auto_size_ctl.apply_empty_reserve = FALSE;
        auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 6.\n";
        }
    }

    /* Verify that there are now no active epoch markers.
     */
    if (pass) {

        if (cache_ptr->epoch_markers_active != 0) {

            pass         = FALSE;
            failure_mssg = "Unexpected # of epoch markers 9.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    /* verify that we still have the expected number of entries in the cache,
     * and that the cache is of the expected size.
     */
    if (pass) {

        if ((cache_ptr->max_cache_size != (8 * 1024 * 1024)) ||
            (cache_ptr->min_clean_size != (4 * 1024 * 1024)) ||
            (cache_ptr->index_size != (10 * 1000 * SMALL_ENTRY_SIZE)) || (cache_ptr->index_len != 10000)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache size change results 3.\n";
        }
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (show_progress)
        HDfprintf(stderr, "check point %d\n", checkpoint++);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_epoch_markers() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_input_errs()
 *
 * Purpose:    Verify that H5C_set_cache_auto_resize_config() detects
 *        and rejects invalid input.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              10/29/04
 *
 * Modifications:
 *
 *         Added code to verify that errors in the flash cache size
 *              increment related fields are caught as well.
 *
 *                                              JRM -- 1/17/08
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_input_errs(void)
{
    const char *        fcn_name = "check_auto_cache_resize_input_errs()";
    herr_t              result;
    H5F_t *             file_ptr          = NULL;
    H5C_t *             cache_ptr         = NULL;
    H5C_auto_size_ctl_t ref_auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
        /* H5C_auto_resize_report_fcn rpt_fcn = */ test_rpt_fcn,

        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (512 * 1024),

        /* double      min_clean_fraction     = */ 0.5f,

        /* size_t      max_size               = */ (16 * 1024 * 1024),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 1000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__threshold,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__threshold,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.1f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.05f};

    H5C_auto_size_ctl_t invalid_auto_size_ctl;
    H5C_auto_size_ctl_t test_auto_size_ctl;

    TESTING("automatic cache resize input errors");

    pass = TRUE;

    /* allocate a cache, and set a reference automatic cache control
     * configuration.  Then feed H5C_set_cache_auto_resize_config()
     * invalid input, and verify that the correct error is returned,
     * and that the configuration is not modified.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &ref_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (512 * 1024)) || (cache_ptr->min_clean_size != (256 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 1.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 1.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(NULL, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 2.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 2.";
        }
    }

    /* check bad version rejection. */

    if (pass) {

        invalid_auto_size_ctl.version = -1; /* INVALID */
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad version.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 3.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 3.";
        }
    }

    /* check bad initial size rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 16 * 1024 * 1024 + 1;
        /* INVALID */

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad init size 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 4.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 4.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 1 * 1024 * 1024 - 1;
        /* INVALID */

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad init size 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 5.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 5.";
        }
    }

    /* test for invalid min clean fraction rejection. */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 1.00001f; /* INVALID */

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min clean frac 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 6.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 6.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = -0.00001f; /* INVALID */

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min clean frac 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 7.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 7.";
        }
    }

    /* test for invalid max_size and/or min_size rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = H5C__MAX_MAX_CACHE_SIZE + 1;
        /* INVALID */
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad max_size.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 8.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 8.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 1 * 1024 * 1024;     /* INVALID */
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024 + 1; /*PAIR */

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad size pair.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 9.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 9.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = H5C__MIN_MAX_CACHE_SIZE - 1;
        /* INVALID */
        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad min_size.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 10.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 10.";
        }
    }

    /* test for invalid epoch_length rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = H5C__MAX_AR_EPOCH_LENGTH + 1;
        /* INVALID */

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epoch len 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 11.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 11.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = H5C__MIN_AR_EPOCH_LENGTH - 1;
        /* INVALID */

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epoch len 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 12.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 12.";
        }
    }

    /* test for bad incr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = (enum H5C_cache_incr_mode) - 1; /* INVALID */

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad incr_mode 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 13.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 13.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = (enum H5C_cache_incr_mode)2; /* INVALID */

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad incr_mode 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 14.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 14.";
        }
    }

    /* check for bad upper and/or lower threshold rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.7f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 1.01f; /* INVALID */

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad upper threshold.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 15.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 15.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.8f; /* INVALID */

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.7f; /* INVALID */

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad threshold pair.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 16.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 16.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.5f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = -0.0001f; /* INVALID */

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad lower threshold.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 17.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 17.";
        }
    }

    /* test for bad increment rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 0.99999f; /* INVALID */

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.5f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad increment.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 18.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 18.";
        }
    }

    /* test for bad flash_incr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = (enum H5C_cache_flash_incr_mode) - 1; /* INVALID */
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_incr_mode.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 19.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 19.";
        }
    }

    /* test for bad flash_multiple rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 0.09f; /* INVALID */
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_multiple(1).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 20.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 20.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 10.01f; /* INVALID */
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_multiple(2).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 21.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 21.";
        }
    }

    /* test for bad flash_threshold rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 1.0f;
        invalid_auto_size_ctl.flash_threshold = 0.09f; /* INVALID */

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_threshold(1).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 22.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 22.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__add_space;
        invalid_auto_size_ctl.flash_multiple  = 1.0f;
        invalid_auto_size_ctl.flash_threshold = 1.001f; /* INVALID */

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad flash_threshold(2).\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 23.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 23.";
        }
    }

    /* test for bad decr_mode rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = (enum H5C_cache_decr_mode) - 1; /* INVALID */

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decr_mode 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 24.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 24.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = (enum H5C_cache_decr_mode)4; /* INVALID */

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decr_mode 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 25.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 25.";
        }
    }

    /* check for bad decrement rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 1.000001f; /* INVALID */

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decrement 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 26.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 26.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = -0.000001f; /* INVALID */

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad decrement 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 27.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 27.";
        }
    }

    /* check for rejection of bad epochs_before_eviction */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 0; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epochs_before_eviction 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 28.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 28.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = H5C__MAX_EPOCH_MARKERS + 1; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad epochs_before_eviction 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 29.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 29.";
        }
    }

    /* Check for bad apply_empty_reserve rejection */

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = 3;

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = -0.0000001f; /* INVALID */

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad empty_reserve 1.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 30.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 30.";
        }
    }

    if (pass) {

        invalid_auto_size_ctl.version = H5C__CURR_AUTO_SIZE_CTL_VER;
        invalid_auto_size_ctl.rpt_fcn = NULL;

        invalid_auto_size_ctl.set_initial_size = TRUE;
        invalid_auto_size_ctl.initial_size     = 4 * 1024 * 1024;

        invalid_auto_size_ctl.min_clean_fraction = 0.1f;

        invalid_auto_size_ctl.max_size = 16 * 1024 * 1024;
        invalid_auto_size_ctl.min_size = 1 * 1024 * 1024;

        invalid_auto_size_ctl.epoch_length = 5000;

        invalid_auto_size_ctl.incr_mode = H5C_incr__threshold;

        invalid_auto_size_ctl.lower_hr_threshold = 0.75f;

        invalid_auto_size_ctl.increment = 2.0f;

        invalid_auto_size_ctl.apply_max_increment = TRUE;
        invalid_auto_size_ctl.max_increment       = (2 * 1024 * 1024);

        invalid_auto_size_ctl.flash_incr_mode = H5C_flash_incr__off;
        invalid_auto_size_ctl.flash_multiple  = 2.0f;
        invalid_auto_size_ctl.flash_threshold = 0.5f;

        invalid_auto_size_ctl.decr_mode = H5C_decr__age_out_with_threshold;

        invalid_auto_size_ctl.upper_hr_threshold = 0.999f;

        invalid_auto_size_ctl.decrement = 0.9f;

        invalid_auto_size_ctl.apply_max_decrement = TRUE;
        invalid_auto_size_ctl.max_decrement       = (1 * 1024 * 1024);

        invalid_auto_size_ctl.epochs_before_eviction = H5C__MAX_EPOCH_MARKERS + 1; /* INVALID */

        invalid_auto_size_ctl.apply_empty_reserve = TRUE;
        invalid_auto_size_ctl.empty_reserve       = 0.05f;

        result = H5C_set_cache_auto_resize_config(cache_ptr, &invalid_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config accepted bad empty_reserve 2.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, &test_auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config failed 31.";
        }
        else if (!resize_configs_are_equal(&test_auto_size_ctl, &ref_auto_size_ctl, FALSE)) {

            pass         = FALSE;
            failure_mssg = "Unexpected auto resize config 31.";
        }
    }

    /* finally, before we finish, try feeding
     * H5C_get_cache_auto_resize_config invalid data.
     */

    if (pass) {

        result = H5C_get_cache_auto_resize_config(NULL, &test_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config((const H5C_t *)&test_auto_size_ctl, &test_auto_size_ctl);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config accepted bad cache_ptr.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_auto_resize_config(cache_ptr, NULL);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_auto_resize_config accepted NULL config ptr.\n";
        }
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_input_errs() */

/*-------------------------------------------------------------------------
 * Function:    check_auto_cache_resize_aux_fcns()
 *
 * Purpose:    Verify that the auxilary functions associated with
 *        the automatic cache resize capability are operating
 *        correctly.  These functions are:
 *
 *            H5C_get_cache_size()
 *            H5C_get_cache_hit_rate()
 *            H5C_reset_cache_hit_rate_stats()
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              11/4/04
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_auto_cache_resize_aux_fcns(void)
{
    const char *        fcn_name = "check_auto_cache_resize_aux_fcns()";
    herr_t              result;
    int32_t             i;
    H5F_t *             file_ptr  = NULL;
    H5C_t *             cache_ptr = NULL;
    double              hit_rate;
    size_t              max_size;
    size_t              min_clean_size;
    size_t              cur_size;
    int32_t             cur_num_entries;
    H5C_auto_size_ctl_t auto_size_ctl = {
        /* int32_t     version                = */ H5C__CURR_AUTO_SIZE_CTL_VER,
#if 1
        /* H5C_auto_resize_report_fcn rpt_fcn = */ NULL,
#else
        /* H5C_auto_resize_report_fcn rpt_fcn = */ H5C_def_auto_resize_rpt_fcn,
#endif
        /* hbool_t     set_initial_size       = */ TRUE,
        /* size_t      initial_size           = */ (1 * 1024 * 1024),

        /* double      min_clean_fraction     = */ 0.5f,

        /* size_t      max_size               = */ (16 * 1024 * 1025),
        /* size_t      min_size               = */ (512 * 1024),

        /* int64_t     epoch_length           = */ 50000,

        /* enum H5C_cache_incr_mode incr_mode = */ H5C_incr__off,

        /* double     lower_hr_threshold      = */ 0.75f,

        /* double      increment              = */ 2.0f,

        /* hbool_t     apply_max_increment    = */ TRUE,
        /* size_t      max_increment          = */ (4 * 1024 * 1024),

        /* enum H5C_cache_flash_incr_mode       */
        /*                    flash_incr_mode = */ H5C_flash_incr__off,
        /* double      flash_multiple         = */ 2.0f,
        /* double      flash_threshold        = */ 0.5f,

        /* enum H5C_cache_decr_mode decr_mode = */ H5C_decr__off,

        /* double      upper_hr_threshold     = */ 0.995f,

        /* double      decrement              = */ 0.9f,

        /* hbool_t     apply_max_decrement    = */ TRUE,
        /* size_t      max_decrement          = */ (1 * 1024 * 1024),

        /* int32_t     epochs_before_eviction = */ 3,

        /* hbool_t     apply_empty_reserve    = */ TRUE,
        /* double      empty_reserve          = */ 0.5f
    };

    TESTING("automatic cache resize auxilary functions");

    pass = TRUE;

    /* allocate a cache, and then test the various auxilary functions.
     */

    if (pass) {

        reset_entries();

        file_ptr  = setup_cache((size_t)(2 * 1024), (size_t)(1 * 1024));
        cache_ptr = file_ptr->shared->cache;
    }

    if (pass) {

        result = H5C_set_cache_auto_resize_config(cache_ptr, &auto_size_ctl);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_set_cache_auto_resize_config failed 1.\n";
        }
    }

    if (pass) {

        if ((cache_ptr->max_cache_size != (1 * 1024 * 1024)) || (cache_ptr->min_clean_size != (512 * 1024))) {

            pass         = FALSE;
            failure_mssg = "bad cache size after initialization.\n";
        }
    }

    /* lets start with the H5C_get_cache_hit_rate(),
     * H5C_reset_cache_hit_rate_stats() pair.
     */

    if (pass) {

        if ((H5C_get_cache_hit_rate(NULL, &hit_rate) != FAIL) ||
            (H5C_get_cache_hit_rate(cache_ptr, NULL) != FAIL)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate accepts bad params.\n";
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (hit_rate > FP_EPSILON) { /* i.e. hit_rate != 0.0 */

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 1.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (hit_rate > FP_EPSILON) { /* i.e. hit_rate != 0.0 */

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 2.\n";
        }
        else if ((cache_ptr->cache_accesses != 1000) || (cache_ptr->cache_hits != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = FALSE;
            failure_mssg = "Report function called?.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, 0);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!DBL_REL_EQUAL(hit_rate, 0.5f, FP_EPSILON)) { /* i.e. hit_rate != 0.5 */

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 3.\n";
        }
        else if ((cache_ptr->cache_accesses != 2000) || (cache_ptr->cache_hits != 1000)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = FALSE;
            failure_mssg = "Report function called?.\n";
        }
    }

    if (pass) {

        result = H5C_reset_cache_hit_rate_stats(NULL);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_reset_cache_hit_rate_stats accepted NULL cache_ptr.\n";
        }
        else if ((cache_ptr->cache_accesses != 2000) || (cache_ptr->cache_hits != 1000)) {

            pass         = FALSE;
            failure_mssg = "Failed call to H5C_reset_cache_hit_rate_stats altered stats?\n";
        }
    }

    if (pass) {

        result = H5C_reset_cache_hit_rate_stats(cache_ptr);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_reset_cache_hit_rate_stats failed.\n";
        }
        else if ((cache_ptr->cache_accesses != 0) || (cache_ptr->cache_hits != 0)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
    }

    if (pass) {

        rpt_fcn_called = FALSE;
        i              = 0;
        while ((pass) && (i < 1000)) {
            protect_entry(file_ptr, PICO_ENTRY_TYPE, i + 500);

            if (pass) {

                unprotect_entry(file_ptr, PICO_ENTRY_TYPE, i + 500, H5C__NO_FLAGS_SET);
            }
            i++;
        }
    }

    if (pass) {

        result = H5C_get_cache_hit_rate(cache_ptr, &hit_rate);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate failed.\n";
        }
        else if (!DBL_REL_EQUAL(hit_rate, 0.5F, FP_EPSILON)) { /* i.e. hit_rate != 0.5 */

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_hit_rate returned unexpected hit rate 4.\n";
        }
        else if ((cache_ptr->cache_accesses != 1000) || (cache_ptr->cache_hits != 500)) {

            pass         = FALSE;
            failure_mssg = "Unexpected cache hit rate stats.\n";
        }
        else if (rpt_fcn_called) {

            pass         = FALSE;
            failure_mssg = "Report function called?.\n";
        }
    }

    /***************************************************
     * So much for testing H5C_get_cache_hit_rate() and
     * H5C_reset_cache_hit_rate_stats().  Now on to
     * H5C_get_cache_size().
     ***************************************************/

    if (pass) {

        result = H5C_get_cache_size(NULL, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != FAIL) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size accepted NULL cache_ptr.\n";
        }
    }

    if (pass) {

        max_size        = 0;
        min_clean_size  = 0;
        cur_size        = 0;
        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 1.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 1.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 1.\n";
        }
        else if (cur_size != (1500 * PICO_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 1.\n";
        }
        else if (cur_num_entries != 1500) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 1.\n";
        }
    }

    /* read a larger entry so that cur_size and cur_num_entries will be
     * different.
     */
    if (pass) {

        protect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0);
    }

    if (pass) {
        unprotect_entry(file_ptr, MONSTER_ENTRY_TYPE, 0, H5C__NO_FLAGS_SET);
    }

    if (pass) {

        max_size        = 0;
        min_clean_size  = 0;
        cur_size        = 0;
        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, &min_clean_size, &cur_size, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 2.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 2.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 2.\n";
        }
        else if (cur_size != ((1500 * PICO_ENTRY_SIZE) + MONSTER_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 2.\n";
        }
        else if (cur_num_entries != 1501) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 2.\n";
        }
    }

    if (pass) {

        max_size = 0;

        result = H5C_get_cache_size(cache_ptr, &max_size, NULL, NULL, NULL);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 3.\n";
        }
        else if (max_size != (1 * 1024 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected max_size 3.\n";
        }
    }

    if (pass) {

        min_clean_size = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, &min_clean_size, NULL, NULL);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 4.\n";
        }
        else if (min_clean_size != (512 * 1024)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected min_clean_size 4.\n";
        }
    }

    if (pass) {

        cur_size = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, NULL, &cur_size, NULL);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 5.\n";
        }
        else if (cur_size != ((1500 * PICO_ENTRY_SIZE) + MONSTER_ENTRY_SIZE)) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_size 5.\n";
        }
    }

    if (pass) {

        cur_num_entries = 0;

        result = H5C_get_cache_size(cache_ptr, NULL, NULL, NULL, &cur_num_entries);

        if (result != SUCCEED) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size failed 6.\n";
        }
        else if (cur_num_entries != 1501) {

            pass         = FALSE;
            failure_mssg = "H5C_get_cache_size reports unexpected cur_num_entries 2.\n";
        }
    }

    if (cache_ptr) {

        takedown_cache(file_ptr, FALSE, FALSE);
    }

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    if (!pass) {

        HDfprintf(stdout, "%s: failure_mssg = \"%s\".\n", fcn_name, failure_mssg);
    }

    return (unsigned)!pass;

} /* check_auto_cache_resize_aux_fcns() */

/*-------------------------------------------------------------------------
 * Function:    check_metadata_blizzard_absence()
 *
 * Purpose:    Test to verify that a 'metadata blizzard' can not occur
 *              upon insertion into the cache.
 *
 *              A 'metadata blizzard' in this context occurs when the cache
 *              gets completely filled with all dirty entries. Upon needing
 *              to make space in the cache, the cache then has no clean
 *              entries ready to evict, and must clean every dirty entry
 *              in the cache first, due to the second chance replacement
 *              policy. (i.e. after cleaning an entry, it is bumped to the
 *              top of the LRU to make a second pass before eviction).
 *              The massive amount of sequential writes to disk while
 *              flushing the entire cache is what constitutes a 'metadata
 *              blizzard'.
 *
 * Return:    void
 *
 * Programmer:    Mike McGreevy
 *              <mamcgree@hdfgroup.org>
 *              12/16/08
 *
 * Modifications:
 *
 *-------------------------------------------------------------------------
 */

static unsigned
check_metadata_blizzard_absence(hbool_t fill_via_insertion)
{
    const char *fcn_name      = "check_metadata_blizzard_absence";
    int         entry_type    = HUGE_ENTRY_TYPE;
    size_t      entry_size    = HUGE_ENTRY_SIZE; /* 16 KB */
    H5F_t *     file_ptr      = NULL;
    H5C_t *     cache_ptr     = NULL;
    hbool_t     show_progress = FALSE;
    int32_t     checkpoint    = 0;
    int32_t     entry_idx     = 0;
    int32_t     i;

    /* Expected loaded status of entries depends on how they get into
     * the cache. Insertions = not loaded, protect/unprotect = loaded.
     */
    hbool_t loaded = (hbool_t) !(fill_via_insertion);

    /* Set up the expected array. This is used to maintain a table of the
     * expected status of every entry used in this test.
     */
    /* clang-format off */
    struct expected_entry_status expected[150] =
    {
      /* entry        entry            in    at main                                                       */
      /* type:        index:    size:        cache:    addr:    dirty:    prot:    pinned:    loaded: clrd:    flshd:    dest: */
      { HUGE_ENTRY_TYPE, 0,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 1,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 2,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 3,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 4,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 5,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 6,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 7,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 8,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 9,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 10,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 11,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 12,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 13,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 14,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 15,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 16,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 17,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 18,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 19,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 20,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 21,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 22,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 23,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 24,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 25,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 26,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 27,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 28,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 29,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 30,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 31,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 32,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 33,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 34,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 35,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 36,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 37,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 38,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 39,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 40,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 41,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 42,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 43,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 44,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 45,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 46,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 47,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 48,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 49,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 50,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 51,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 52,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 53,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 54,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 55,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 56,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 57,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 58,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 59,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 60,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 61,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 62,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 63,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 64,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 65,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 66,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 67,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 68,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 69,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 70,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 71,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 72,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 73,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 74,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 75,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 76,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 77,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 78,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 79,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 80,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 81,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 82,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 83,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 84,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 85,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 86,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 87,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 88,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 89,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 90,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 91,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 92,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 93,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 94,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 95,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 96,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 97,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 98,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 99,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 100,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 101,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 102,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 103,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 104,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 105,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 106,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 107,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 108,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 109,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 110,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 111,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 112,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 113,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 114,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 115,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 116,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 117,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 118,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 119,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 120,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 121,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 122,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 123,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 124,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 125,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 126,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 127,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 128,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 129,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 130,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 131,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 132,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 133,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 134,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 135,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 136,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 137,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 138,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 139,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 140,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 141,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 142,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 143,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 144,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 145,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 146,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 147,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 148,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE },
      { HUGE_ENTRY_TYPE, 149,    HUGE_ENTRY_SIZE, FALSE,    TRUE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE,    FALSE }
    };
    /* clang-format on */

    pass = TRUE;

    if (fill_via_insertion) {

        TESTING("to ensure metadata blizzard absence when inserting");
    }
    else {

        TESTING("to ensure metadata blizzard absence on protect/unprotect");
    }

    if (show_progress) /* 0 */
        HDfprintf(stdout, "\n%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Set up the cache.
         *
         * The max_cache_size should have room for 50 entries.
         * The min_clean_size is half of that, or 25 entries.
         */
        file_ptr = setup_cache((size_t)(50 * entry_size),  /* max_cache_size */
                               (size_t)(25 * entry_size)); /* min_clean_size */

        if (file_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "bad return from cache intialization.\n";
        }
        else
            cache_ptr = file_ptr->shared->cache;
    }

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 1:
     *
     *    Inserting dirty entries into an empty cache, until the cache
     *    violates the min_clean_size requirement. The expected result is
     *    that none of the inserted entries during this phase will get
     *    flushed or evicted.
     *
     *    This verifies that while maintaining min_clean_size, we don't go
     *    overboard and flush entries that we don't need to flush.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert 26 entries (indexes 0 through 25) into the cache.
         *
         * Note that we are inserting 26 entries, and not 25, because the cache
         * will only try to adhere to the min_clean_size if it's currently
         * being violated. Thus, on insertion of the 26th entry, since the
         * min_clean_size will not be violated, it will accept the insertion
         * without having to make clean space.
         */

        for (entry_idx = 0; entry_idx < 26; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* Change expected values, and verify the status of the entries
             * after each insertion
             */
            expected[entry_idx].in_cache = TRUE;
            expected[entry_idx].is_dirty = TRUE;
            expected[entry_idx].loaded   = (unsigned char)loaded;

            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 2:
     *
     *    Inserting entries into a cache that violates the min_clean_size,
     *    until the cache is full. The expected result is that each insertion
     *    will result in the flushing of a dirty entry in the cache.
     *
     *    This verifies that we maintain the min_clean_size. By doing so, we
     *    prevent building the situation in which a 'metadata blizzard' would
     *    occur (i.e., the cache being completely filled with dirty entries).
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert the 27th entry (index = 26) into the cache.
         *
         * This should cause the cache to flush its least recently used entry
         * before the insertion because it doesn't satisfy the min_clean_size
         * constraint.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 27 entries in the cache, and
         * entry number 0 has been cleaned.
         *
         * Changes from last entry verification:
         *   - entry w/ index 0 has now been flushed and is now clean.
         *   - entry w/ index 26 is now in the cache and dirty.
         */

        /* entry w/ index 0 has now been flushed and is now clean. */
        expected[0].flushed  = TRUE;
        expected[0].is_dirty = FALSE;

        /* entry w/ index 26 is now in the cache and dirty. */
        expected[26].in_cache = TRUE;
        expected[26].is_dirty = TRUE;
        expected[26].loaded   = (unsigned char)loaded;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            26,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert the 28th entry (index = 27) into the cache.
         *
         * This should, once again, cause the cache to flush its least
         * recently used entry before the insertion as it again does not
         * satisfy the min_clean_size constraint.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Expected status is that there are 28 entries in the cache, and
         * entry numbers 0 and 1 have been cleaned.
         *
         * Changes from last entry verification:
         *   - entry w/ index 1 has now been flushed and is now clean.
         *   - entry w/ index 27 is now in the cache and dirty.
         */

        /* entry w/ index 1 has now been flushed and is now clean. */
        expected[1].flushed  = TRUE;
        expected[1].is_dirty = FALSE;

        /* entry w/ index 27 is now in the cache and dirty. */
        expected[27].in_cache = TRUE;
        expected[27].is_dirty = TRUE;
        expected[27].loaded   = (unsigned char)loaded;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            27,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Fill out the rest of the cache with entries */
        /* Verify expected status of entries after each insertion */
        for (entry_idx = entry_idx; entry_idx < 50; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* Expected staus is that after each insertion, the entry
             * inserted 26 insertions ago has been flushed, and the
             * entry currently getting inserted is now in the cache and
             * dirty.
             */
            expected[entry_idx - 26].flushed  = TRUE;
            expected[entry_idx - 26].is_dirty = FALSE;

            expected[entry_idx].in_cache = TRUE;
            expected[entry_idx].is_dirty = TRUE;
            expected[entry_idx].loaded   = (unsigned char)loaded;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }

        /* Verify that the cache is now full */
        if (cache_ptr->cache_full != TRUE) {

            pass         = FALSE;
            failure_mssg = "cache not completely filled.\n";
        }
    }

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 3:
     *
     *    Inserting entries into a cache that is completely full. Insertions
     *    of new entries will force evictions of old entries, but since the
     *    min_clean_size has been maintained, doing so will not result in
     *    the entire cache getting flushed in order to evict a single entry,
     *    as a clean entry will be available to flush reasonably close to
     *    the bottom of the LRU.
     *
     *    This verifies that with a maintained min_clean_size, a metadata
     *    blizzard does not occur on insertion.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Insert the 51st entry (index = 50) into the cache.
         *
         * The cache is full prior to the insertion, so it will
         * have to evict in order to make room for the new entry.
         */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entry w/ index 0 has been evicted.
         *   - entries w/ indices 24,25 have now been flushed and are clean.
         *   - entry w/ index 50 is now in the cache and dirty.
         */

        /* entry w/ index 0 has been evicted. */
        expected[0].in_cache  = FALSE;
        expected[0].destroyed = TRUE;

        /* entries w/ indices 24,25 have now been flushed and are clean. */
        expected[24].flushed  = TRUE;
        expected[24].is_dirty = FALSE;
        expected[25].flushed  = TRUE;
        expected[25].is_dirty = FALSE;

        /* entry w/ index 50 is now in the cache and dirty */
        expected[50].in_cache = TRUE;
        expected[50].is_dirty = TRUE;
        expected[50].loaded   = (unsigned char)loaded;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            50,        /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert 49 more entries (indices 51-99) into the cache.
         *
         * The cache will be flushing an entry on each insertion, and
         * evicting an entry on each insertion.
         *
         * After each insertion, verify the expected status of the
         * entries in the cache.
         */
        for (entry_idx = entry_idx; entry_idx < 100; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache = TRUE;
            expected[entry_idx].is_dirty = TRUE;
            expected[entry_idx].loaded   = (unsigned char)loaded;

            /* The entry inserted 50 insertions ago has been evicted */
            expected[entry_idx - 50].in_cache  = FALSE;
            expected[entry_idx - 50].destroyed = TRUE;

            /* If the newly inserted entry is among the first 24
             * insertions in this loop, then the insertion will
             * have resulted in a flush of the entry inserted
             * 25 insertions ago. */
            if (entry_idx < 75) {

                expected[entry_idx - 25].flushed  = TRUE;
                expected[entry_idx - 25].is_dirty = FALSE;
            }
            /* If the newly inserted entry is among the last
             * 25 insertions in this loop, then the insertion will
             * have resulted in a flush of the entry inserted 26
             * insertions ago. This switch is because there was two
             * consecutive clean entries in the cache (due to 51/49
             * dirty/clean ratio when full), so instead of
             * flush-then-evict, it switches to evict-then-flush. */
            else {

                expected[entry_idx - 26].flushed  = TRUE;
                expected[entry_idx - 26].is_dirty = FALSE;
            }

            /* Verify this expected status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* expected */
        }
    }

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    /* ========================================================================
     * ========================================================================
     *  Phase 4:
     *
     *    Flushing the entire cache, and then inserting entries into a cache
     *    that is completely full, but all clean.
     *
     *    Phases 1 and 2 are then repeated. Rather than inserting dirty entries
     *    into an empty cache, we're inserting into a full cache that's all
     *    clean, thus an eviction occurs before each insertion.
     *
     *    When the cache finally hits the point of violating the
     *    min_clean_size, the bottom half of the LRU will be filled with
     *    clean entries and the top half will be filled with recently inserted
     *    dirty entries. We'll then verify that an insertion will only evict
     *    one entry and flush one entry, and no more.
     *
     * ========================================================================
     * ========================================================================
     */

    if (pass) {

        /* Flush the cache.
         *
         * We're doing this so we can repeat the above insertions, but
         * starting from a cache filled with clean entries as opposed
         * to an empty cache.
         */

        flush_cache(file_ptr, /* H5F_t * file_ptr */
                    FALSE,    /* hbool_t destory_entries */
                    FALSE,    /* hbool_t dump_stats */
                    FALSE);   /* hbool_t dump_detailed_stats */

        /* Verify that the cache is clean */
        verify_clean();

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entries w/ indices 74-99 have been flushed.
         */

        /* entries w/ indices 74-99 have been flushed. */
        for (i = 74; i < 100; i++) {

            expected[i].flushed  = TRUE;
            expected[i].is_dirty = FALSE;
        }
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            0,         /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert 26 entries (indexes 100 through 125) into the cache.
         *
         * The cache will evict 26 entries since it's currently full with
         * all clean entries. None of the entries we're inserting now
         * will get cleaned, however.
         */

        for (entry_idx = 100; entry_idx < 126; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache = TRUE;
            expected[entry_idx].is_dirty = TRUE;
            expected[entry_idx].loaded   = (unsigned char)loaded;

            /* The entry with ID minus 50 will have been evicted */
            expected[entry_idx - 50].in_cache  = FALSE;
            expected[entry_idx - 50].destroyed = TRUE;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert the 127th entry (index = 126) into the cache. */
        if (fill_via_insertion) {
            insert_entry(file_ptr,           /* H5F_t * file_ptr */
                         entry_type,         /* int32_t type */
                         entry_idx++,        /* int32_t idx */
                         H5C__NO_FLAGS_SET); /* unsigned int flags */
        }
        else {
            protect_entry(file_ptr,   /* H5F_t * file_ptr */
                          entry_type, /* int32_t type */
                          entry_idx); /* int32-t idx */

            unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                            entry_type,         /* int32_t type */
                            entry_idx++,        /* int32_t idx */
                            H5C__DIRTIED_FLAG); /* unsigned int flags */
        }

        /* Verify the status of the entries.
         *
         * Changes from last entry verification:
         *   - entry w/ index 76 is evicted.
         *   - entry w/ index 100 is cleaned.
         *   - entry w/ index 126 is now in the cache and dirty.
         */

        /* entry w/ index 76 has been evicted. */
        expected[76].in_cache  = FALSE;
        expected[76].destroyed = TRUE;

        /* entry w/ index 100 has now been flushed and is now clean. */
        expected[100].flushed  = TRUE;
        expected[100].is_dirty = FALSE;

        /* entry w/ index 26 is now in the cache and dirty. */
        expected[126].in_cache = TRUE;
        expected[126].is_dirty = TRUE;
        expected[126].loaded   = (unsigned char)loaded;

        /* verify the status */
        verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                            126,       /* int tag */
                            150,       /* int num_entries */
                            expected); /* expected */
    }

    if (show_progress) /* 10 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* Insert entries w/ indices 127 through 149 into the cache */
        for (entry_idx = 127; entry_idx < 150; entry_idx++) {

            if (fill_via_insertion) {
                insert_entry(file_ptr,           /* H5F_t * file_ptr */
                             entry_type,         /* int32_t type */
                             entry_idx,          /* int32_t idx */
                             H5C__NO_FLAGS_SET); /* unsigned int flags */
            }
            else {
                protect_entry(file_ptr,   /* H5F_t * file_ptr */
                              entry_type, /* int32_t type */
                              entry_idx); /* int32-t idx */

                unprotect_entry(file_ptr,           /* H5F_t * file_ptr */
                                entry_type,         /* int32_t type */
                                entry_idx,          /* int32_t idx */
                                H5C__DIRTIED_FLAG); /* unsigned int flags */
            }

            /* This past inserted entry is now in the cache and dirty */
            expected[entry_idx].in_cache = TRUE;
            expected[entry_idx].is_dirty = TRUE;
            expected[entry_idx].loaded   = (unsigned char)loaded;

            /* The entry with ID minus 50 will have been evicted */
            expected[entry_idx - 50].in_cache  = FALSE;
            expected[entry_idx - 50].destroyed = TRUE;

            /* The entry with ID minus 26 will now be clean */
            expected[entry_idx - 26].flushed  = TRUE;
            expected[entry_idx - 26].is_dirty = FALSE;

            /* verify the status */
            verify_entry_status(cache_ptr, /* H5C_t * cache_ptr */
                                entry_idx, /* int tag */
                                150,       /* int num_entries */
                                expected); /* struct expected_entry_staus[] */
        }
    }

    if (show_progress) /* 11 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {

        /* We're done with testing. We can take down the cache. */
        takedown_cache(file_ptr, FALSE, FALSE);
        reset_entries();
    }

    if (show_progress) /* 12 */
        HDfprintf(stdout, "%s: check point %d -- pass %d\n", fcn_name, checkpoint++, pass);

    if (pass) {
        PASSED();
    }
    else {
        H5_FAILED();
    }

    return (unsigned)!pass;

} /* check_metadata_blizzard_absence() */

/*-------------------------------------------------------------------------
 *
 * Function:    check_if_write_permitted
 *
 * Purpose:     Determine if a write is permitted under the current
 *              circumstances, and set *write_permitted_ptr accordingly.
 *              As a general rule it is, but when we are running in parallel
 *              mode with collective I/O, we must ensure that a read cannot
 *              cause a write.
 *
 *              In the event of failure, the value of *write_permitted_ptr
 *              is undefined.
 *
 * Return:      Non-negative on success/Negative on failure.
 *
 * Programmer:  John Mainzer, 5/15/04
 *
 *-------------------------------------------------------------------------
 */

herr_t
check_write_permitted(const H5F_t H5_ATTR_UNUSED *f, hid_t H5_ATTR_UNUSED dxpl_id,
                      hbool_t *write_permitted_ptr)
{

    HDassert(write_permitted_ptr);
    *write_permitted_ptr = write_permitted;

    return (SUCCEED);

} /* check_write_permitted() */

/*-------------------------------------------------------------------------

/*-------------------------------------------------------------------------
 * Function:    setup_cache()
 *
 * Purpose:    Allocate a cache of the desired size and configure it for
 *        use in the test bed.  Return a pointer to the new cache
 *        structure.
 *
 * Return:    Pointer to new cache, or NULL on failure.
 *
 * Programmer:    John Mainzer
 *              6/11/04
 *
 *-------------------------------------------------------------------------
 */

H5F_t *
setup_cache(size_t max_cache_size, size_t min_clean_size)
{
    const char *fcn_name = "setup_cache()";
    char        filename[512];
    hbool_t     show_progress = FALSE;
    hbool_t     verbose       = TRUE;
    int         mile_stone    = 1;
    hid_t       fid           = -1;
    H5F_t *     file_ptr      = NULL;
    H5C_t *     cache_ptr     = NULL;
    H5F_t *     ret_val       = NULL;
    haddr_t     actual_base_addr;
    hid_t       fapl_id = H5P_DEFAULT;

    if (show_progress) /* 1 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    saved_fid = -1;

    /* setup the file name */
    if (pass) {

        if (h5_fixname(FILENAME[0], H5P_DEFAULT, filename, sizeof(filename)) == NULL) {

            pass         = FALSE;
            failure_mssg = "h5_fixname() failed.\n";
        }
    }

    if (show_progress) /* 2 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if ((pass) && (try_core_file_driver)) {

        if ((fapl_id = H5Pcreate(H5P_FILE_ACCESS)) == FAIL) {

            pass         = FALSE;
            failure_mssg = "H5Pcreate(H5P_FILE_ACCESS) failed.\n";
        }
        else if (H5Pset_fapl_core(fapl_id, MAX_ADDR, FALSE) < 0) {

            H5Pclose(fapl_id);
            fapl_id      = H5P_DEFAULT;
            pass         = FALSE;
            failure_mssg = "H5P_set_fapl_core() failed.\n";
        }
        else if ((fid = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, fapl_id)) < 0) {

            core_file_driver_failed = TRUE;

            if (verbose) {
                HDfprintf(stdout, "%s: H5Fcreate() with CFD failed.\n", fcn_name);
            }
        }
        else {

            saved_fapl_id = fapl_id;
        }
    }

    if (show_progress) /* 3 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    /* if we either aren't using the core file driver, or a create
     * with the core file driver failed, try again with a regular file.
     * If this fails, we are cooked.
     */
    if ((pass) && (fid < 0)) {

        fid = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, fapl_id);

        saved_fid = fid;

        if (fid < 0) {

            pass         = FALSE;
            failure_mssg = "H5Fcreate() failed.";

            if (verbose) {
                HDfprintf(stdout, "%s: H5Fcreate() failed.\n", fcn_name);
            }
        }
    }

    if (show_progress) /* 4 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        HDassert(fid >= 0);

        saved_fid = fid;

        if (H5Fflush(fid, H5F_SCOPE_GLOBAL) < 0) {

            pass         = FALSE;
            failure_mssg = "H5Fflush() failed.";

            if (verbose) {
                HDfprintf(stdout, "%s: H5Fflush() failed.\n", fcn_name);
            }
        }
        else {

            file_ptr = (H5F_t *)H5I_object_verify(fid, H5I_FILE);

            if (file_ptr == NULL) {

                pass         = FALSE;
                failure_mssg = "Can't get file_ptr.";

                if (verbose) {
                    HDfprintf(stdout, "%s: H5Fflush() failed.\n", fcn_name);
                }
            }
        }
    }

    if (show_progress) /* 5 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        /* A bit of fancy footwork here:
         *
         * The call to H5Fcreate() allocates an instance of H5C_t,
         * initializes it, and stores its address in f->shared->cache.
         *
         * We don't want to use this cache, as it has a bunch of extra
         * initialization that may change over time, and in any case
         * it will not in general be configured the way we want it.
         *
         * We used to deal with this problem by storing the file pointer
         * in another instance of H5C_t, and then ignoring the original
         * version.  However, this strategy doesn't work any more, as
         * we can't store the file pointer in the instance of H5C_t,
         * and we have modified many cache routines to use a file
         * pointer to look up the target cache.
         *
         * Thus we now make note of the address of the instance of
         * H5C_t created by the call to H5Fcreate(), set
         * file_ptr->shared->cache to NULL, call H5C_create()
         * to allocate a new instance of H5C_t for test purposes,
         * and store than new instance's address in
         * file_ptr->shared->cache.
         *
         * On shut down, we call H5C_dest on our instance of H5C_t,
         * set file_ptr->shared->cache to point to the original
         * instance, and then close the file normally.
         */

        HDassert(saved_cache == NULL);

        saved_cache = file_ptr->shared->cache;

        file_ptr->shared->cache = NULL;

        cache_ptr = H5C_create(max_cache_size, min_clean_size, (NUMBER_OF_ENTRY_TYPES - 1),
                               (const char **)entry_type_names, check_write_permitted, TRUE, NULL, NULL);

        file_ptr->shared->cache = cache_ptr;
    }

    if (show_progress) /* 6 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        if (cache_ptr == NULL) {

            pass         = FALSE;
            failure_mssg = "H5C_create() failed.";

            if (verbose) {
                HDfprintf(stdout, "%s: H5C_create() failed.\n", fcn_name);
            }
        }
        else if (cache_ptr->magic != H5C__H5C_T_MAGIC) {

            pass         = FALSE;
            failure_mssg = "Bad cache_ptr magic.";

            if (verbose) {
                HDfprintf(stdout, "%s: Bad cache_ptr magic.\n", fcn_name);
            }
        }
    }

    if (show_progress) /* 7 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) { /* allocate space for test entries */

        actual_base_addr =
            H5MF_alloc(file_ptr, H5FD_MEM_DEFAULT, H5P_DEFAULT, (hsize_t)(ADDR_SPACE_SIZE + BASE_ADDR));

        if (actual_base_addr == HADDR_UNDEF) {

            pass         = FALSE;
            failure_mssg = "H5MF_alloc() failed.";

            if (verbose) {
                HDfprintf(stdout, "%s: H5MF_alloc() failed.\n", fcn_name);
            }
        }
        else if (actual_base_addr > BASE_ADDR) {

            /* If this happens, must increase BASE_ADDR so that the
             * actual_base_addr is <= BASE_ADDR.  This should only happen
             * if the size of the superblock is increase.
             */
            pass         = FALSE;
            failure_mssg = "actual_base_addr > BASE_ADDR";

            if (verbose) {
                HDfprintf(stdout, "%s: actual_base_addr > BASE_ADDR.\n", fcn_name);
            }
        }

        saved_actual_base_addr = actual_base_addr;
    }

    if (show_progress) /* 8 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    if (pass) {

        H5C_stats__reset(cache_ptr);

        ret_val = file_ptr;
    }

    if (show_progress) /* 9 */
        HDfprintf(stdout, "%s() - %0d -- pass = %d\n", fcn_name, mile_stone++, (int)pass);

    return (ret_val);
} /* setup_cache() */

/*-------------------------------------------------------------------------
 * Function:    takedown_cache()
 *
 * Purpose:    Flush the specified cache and disable it.  If requested,
 *        dump stats first.  If pass is FALSE, do nothing.
 *
 * Return:    void
 *
 * Programmer:    John Mainzer
 *              9/14/07
 *
 *-------------------------------------------------------------------------
 */

void
takedown_cache(H5F_t *file_ptr, hbool_t dump_stats, hbool_t dump_detailed_stats)
{
    char filename[512];

    if (file_ptr != NULL) {
        H5C_t *cache_ptr = file_ptr->shared->cache;

        if (dump_stats) {

            H5C_stats(cache_ptr, "test cache", dump_detailed_stats);
        }

        flush_cache(file_ptr, TRUE, FALSE, FALSE);

        H5C_dest(file_ptr, H5P_DATASET_XFER_DEFAULT, H5P_DATASET_XFER_DEFAULT);

        if (saved_cache != NULL) {

            file_ptr->shared->cache = saved_cache;
            saved_cache             = NULL;
        }
    }

    if (saved_fapl_id != H5P_DEFAULT) {

        H5Pclose(saved_fapl_id);
        saved_fapl_id = H5P_DEFAULT;
    }

    if (saved_fid != -1) {

        if (H5F_addr_defined(saved_actual_base_addr)) {

            if (NULL == file_ptr) {
                file_ptr = (H5F_t *)H5I_object_verify(saved_fid, H5I_FILE);
                HDassert(file_ptr);
            }

            H5MF_xfree(file_ptr, H5FD_MEM_DEFAULT, H5P_DEFAULT, saved_actual_base_addr,
                       (hsize_t)(ADDR_SPACE_SIZE + BASE_ADDR));
            saved_actual_base_addr = HADDR_UNDEF;
        }

        if (H5Fclose(saved_fid) < 0) {

            pass         = FALSE;
            failure_mssg = "couldn't close test file.";
        }
        else {

            saved_fid = -1;
        }

        if ((!try_core_file_driver) || (core_file_driver_failed)) {

            if (h5_fixname(FILENAME[0], H5P_DEFAULT, filename, sizeof(filename)) == NULL) {

                pass         = FALSE;
                failure_mssg = "h5_fixname() failed.\n";
            }

            if (HDremove(filename) < 0) {

                pass         = FALSE;
                failure_mssg = "couldn't delete test file.";
            }
        }
    }

    return;

} /* takedown_cache() */

/*-------------------------------------------------------------------------
 * Function:    main
 *
 * Return:      EXIT_SUCCESS/EXIT_FAILURE
 *
 * Programmer:  John Mainzer
 *              6/24/04
 *
 *-------------------------------------------------------------------------
 */

int
main(void)
{
    unsigned nerrs = 0;

    H5open();

    skip_long_tests = FALSE;

#ifdef NDEBUG
    run_full_test = TRUE;
#else  /* NDEBUG */
    run_full_test = FALSE;
#endif /* NDEBUG */

    nerrs += smoke_check_1();
    nerrs += smoke_check_2();
    nerrs += smoke_check_3();
    nerrs += smoke_check_4();
    nerrs += smoke_check_5();
    nerrs += smoke_check_6();
    nerrs += smoke_check_7();
    nerrs += smoke_check_8();
    nerrs += smoke_check_9();
    nerrs += smoke_check_10();

    nerrs += write_permitted_check();
    nerrs += check_insert_entry();
    nerrs += check_flush_cache();
    nerrs += check_get_entry_status();
    nerrs += check_expunge_entry();
    nerrs += check_multiple_read_protect();
    nerrs += check_move_entry();
    nerrs += check_pin_protected_entry();
    nerrs += check_resize_entry();
    nerrs += check_evictions_enabled();
    nerrs += check_flush_protected_err();
    nerrs += check_destroy_pinned_err();
    nerrs += check_destroy_protected_err();
    nerrs += check_duplicate_insert_err();
    nerrs += check_move_err();
    nerrs += check_double_pin_err();
    nerrs += check_double_unpin_err();
    nerrs += check_pin_entry_errs();
    nerrs += check_double_protect_err();
    nerrs += check_double_unprotect_err();
    nerrs += check_mark_entry_dirty_errs();
    nerrs += check_expunge_entry_errs();
    nerrs += check_resize_entry_errs();
    nerrs += check_unprotect_ro_dirty_err();
    nerrs += check_protect_ro_rw_err();
    nerrs += check_check_evictions_enabled_err();
    nerrs += check_auto_cache_resize();
    nerrs += check_auto_cache_resize_disable();
    nerrs += check_auto_cache_resize_epoch_markers();
    nerrs += check_auto_cache_resize_input_errs();
    nerrs += check_auto_cache_resize_aux_fcns();
    nerrs += check_metadata_blizzard_absence(TRUE);
    nerrs += check_metadata_blizzard_absence(FALSE);

    return (nerrs > 0);
}
